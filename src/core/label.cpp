#include "medusa/label.hpp"
#include <algorithm>
#include <sstream>
#include <fmt/format.h>
#include <boost/algorithm/string.hpp>

MEDUSA_NAMESPACE_BEGIN

Label::Label(Address const& rAddress, u16 Type)
  : m_Name()
  , m_Type(Type | AutoGenerated)
  , m_Version()
{
  std::string Prefix;
  switch (Type & CellMask)
  {
  default:
  case Code:     Prefix = "lbl_"; break;
  case Function: Prefix = "fcn_"; break;
  case Data:     Prefix = "dat_"; break;
  case String:   Prefix = "str_"; break;
  }
  m_Name = Prefix + rAddress.ToString();
  std::replace(std::begin(m_Name), std::end(m_Name), ':', '_');
}

Label::Label(std::string const& rName, u16 Type, u16 Version)
  : m_Name(rName)
  , m_Type(Type)
  , m_Version(Version)
{
}

Label::~Label(void)
{
}

std::string Label::Dump(void) const
{
  std::ostringstream oss;
  oss << std::hex << std::showbase;

  char TypeBuf[4];
  switch (m_Type & CellMask)
  {
  case Data:     TypeBuf[0] = 'd'; break;
  case Function: TypeBuf[0] = 'f'; break;
  case Code:     TypeBuf[0] = 'c'; break;
  case String:   TypeBuf[0] = 's'; break;
  default:       TypeBuf[0] = '-'; break;
  }
  switch (m_Type & AccessMask)
  {
  case Imported: TypeBuf[1] = 'i'; break;
  case Exported: TypeBuf[1] = 'e'; break;
  case Global:   TypeBuf[1] = 'g'; break;
  case Local:    TypeBuf[1] = 'l'; break;
  default:       TypeBuf[1] = '-'; break;
  }
  TypeBuf[2] = (m_Type & AutoGenerated) ? 'a' : '-';
  TypeBuf[3] = '\0';

  oss
    << "lbl(" << m_Name
    << " "   << TypeBuf
    << " "   << m_Version
    << ")";
  return oss.str();
}

std::string Label::GetLabel(void) const
{
  std::string Result;

  if ((m_Type & CellMask) == String)
  {
    size_t Limit = 0x10;
    bool Maj = true;
    for (auto RawChr : m_Name)
    {
      std::string CurChr = _ConvertToLabel(RawChr);
      if (CurChr.empty())
      {
        Maj = true;
        continue;
      }
      boost::to_lower(CurChr);
      if (Maj)
      {
        Maj = false;
        boost::to_upper(CurChr);
      }
      Result += CurChr;

      if (!--Limit)
        break;
    }
  }
  else
    for (auto RawChr : m_Name)
    {
      std::string CurChr = _ConvertToLabel(RawChr);
      if (CurChr.empty())
        continue;
      Result += CurChr;
    }

  if (Result.empty())
    Result = "";

  if (m_Version == 0)
    return Result;

  return fmt::format("{}.{}", Result, m_Version);
}

void Label::IncrementVersion(void)
{
  ++m_Version;
}

bool Label::IsAutoGenerated(void) const
{
  return (m_Type & AutoGenerated) ? true : false;
}

bool Label::operator<(Label const& rLabel) const
{
  auto StrDiff = m_Name.compare(rLabel.m_Name);

  if (StrDiff == 0)
    return m_Version < rLabel.m_Version;

  return StrDiff < 0;
}

bool Label::operator==(Label const& rLabel) const
{
  return m_Name == rLabel.m_Name && m_Type == rLabel.m_Type && m_Version == rLabel.m_Version;
}

std::string Label::_ConvertToLabel(char c)
{
  /*
  In VC debug, isalnum can assert...
  src: http://msdn.microsoft.com/en-us/library/k84c0490(v=vs.71).aspx
  When used with a debug CRT library, isalnum will display a CRT assert if passed a parameter that isn't EOF or in the range of 0 through 0xFF.
  When used with a debug CRT library, isalnum will use the parameter as an index into an array, with undefined results if the parameter isn't EOF or in the range of 0 through 0xFF.
  */
  int n = c;
  if (n < 0 || n > 0xff)
    return "\0";
  switch (c)
  {
  case '\a': return "BL";  // bell
  case '\b': return "BS";  // backspace
  case '\t': return "HT";  // horizontal tab
  case '\n': return "NL";  // new line
  case '\v': return "VT";  // vertical tab
  case '\f': return "FF";  // form feed
  case '\r': return "CR";  // carriage return
  case ' ' : return "SP";  // space
  case '/' : return "SL";  // slash
  case '\\': return "BSL"; // backslash
  case '(' : return "OP";  // open parenthese
  case ')' : return "CP";  // close parenthese
  case '[' : return "OSB"; // open square bracket
  case ']' : return "CSB"; // close square 
  case '{' : return "OCB"; // open curly bracket
  case '}' : return "CCB"; // close curly bracket
  case '<' : return "OAB"; // open angle bracket
  case '>' : return "CAB"; // close angle bracket
  case '%' : return "PC";  // percent
  case '&' : return "AS";  // ampersand
  case '^' : return "CA";  // carret
  case '|' : return "PI";  // pipe
  case '+' : return "PL";  // plus
  case '-' : return "MI";  // minus
  case '*' : return "ST";  // star
  case ',' : return "CO";  // comma
  case ';' : return "SC";  // semi-colon
  case '\'': return "QU";  // quote
  case '"' : return "DQ";  // double-quote
  }
  if (!isalnum(c) && c != '!' && c != ':' && c != '?'
      && c != '_' && c != '@' && c != '`' && c != '.')
    return "\0";
  return std::string(1, c);
}

MEDUSA_NAMESPACE_END
