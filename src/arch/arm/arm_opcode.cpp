/* This file has been automatically generated, you must _NOT_ edit it directly. (Sun Apr 10 21:54:52 2016) */
#include "arm_architecture.hpp"
#include "arm_helper.hpp"
const char *ArmArchitecture::m_Mnemonic[0x13a] =
{
  "unknown",
  "adc",
  "adcs",
  "add",
  "adds",
  "addw",
  "adr",
  "and",
  "ands",
  "asr",
  "asrs",
  "b",
  "bfc",
  "bfi",
  "bic",
  "bics",
  "bkpt",
  "bl",
  "blx",
  "bx",
  "bxj",
  "cb",
  "cdp",
  "cdp2",
  "chka",
  "clrex",
  "clz",
  "cmn",
  "cmp",
  "dbg",
  "dmb",
  "dsb",
  "eor",
  "eors",
  "fldmx",
  "fstmx",
  "hb",
  "hblp",
  "hbp",
  "isb",
  "it",
  "ldc",
  "ldc2",
  "ldm",
  "ldmda",
  "ldmdb",
  "ldmib",
  "ldr",
  "ldrb",
  "ldrbt",
  "ldrd",
  "ldrex",
  "ldrexb",
  "ldrexd",
  "ldrexh",
  "ldrh",
  "ldrht",
  "ldrsb",
  "ldrsbt",
  "ldrsh",
  "ldrsht",
  "ldrt",
  "leavex",
  "lsl",
  "lsls",
  "lsr",
  "lsrs",
  "mcr",
  "mcr2",
  "mcrr",
  "mcrr2",
  "mla",
  "mls",
  "mov",
  "movs",
  "movt",
  "movw",
  "mrc",
  "mrc2",
  "mrrc",
  "mrrc2",
  "mrs",
  "msr",
  "mul",
  "muls",
  "mvn",
  "mvns",
  "nop",
  "orn",
  "orr",
  "orrs",
  "pkhtb",
  "pld",
  "pli",
  "pop",
  "push",
  "qadd",
  "qadd16",
  "qadd8",
  "qasx",
  "qdadd",
  "qdsub",
  "qsax",
  "qsub",
  "qsub16",
  "qsub8",
  "rbit",
  "rev",
  "rev16",
  "revsh",
  "ror",
  "rors",
  "rrx",
  "rsb",
  "rsbs",
  "rsc",
  "sadd16",
  "sadd8",
  "sasx",
  "sbc",
  "sbcs",
  "sbfx",
  "sdiv",
  "sel",
  "setend",
  "sev",
  "shadd16",
  "shadd8",
  "shasx",
  "shsax",
  "shsub16",
  "shsub8",
  "smla",
  "smlad",
  "smlal",
  "smlald",
  "smlaw",
  "smlsd",
  "smlsld",
  "smmla",
  "smmls",
  "smmul",
  "smuad",
  "smul",
  "smull",
  "smulw",
  "smusd",
  "ssat",
  "ssat16",
  "ssax",
  "ssub16",
  "ssub8",
  "stc",
  "stc2",
  "stm",
  "stmda",
  "stmdb",
  "stmib",
  "str",
  "strb",
  "strbt",
  "strd",
  "strex",
  "strexb",
  "strexd",
  "strexh",
  "strh",
  "strht",
  "strt",
  "sub",
  "subs",
  "subw",
  "svc",
  "swp",
  "sxtab",
  "sxtab16",
  "sxtah",
  "sxtb",
  "sxtb16",
  "sxth",
  "tbh",
  "teq",
  "tst",
  "uadd16",
  "uadd8",
  "uasx",
  "ubfx",
  "udiv",
  "uhadd16",
  "uhadd8",
  "uhasx",
  "uhsax",
  "uhsub16",
  "uhsub8",
  "umaal",
  "umlal",
  "umull",
  "uqadd16",
  "uqadd8",
  "uqasx",
  "uqsax",
  "uqsub16",
  "uqsub8",
  "usad8",
  "usada8",
  "usat",
  "usat16",
  "usax",
  "usub16",
  "usub8",
  "uxtab",
  "uxtab16",
  "uxtah",
  "uxtb",
  "uxtb16",
  "uxth",
  "v",
  "vaba",
  "vabal",
  "vabd",
  "vabdl",
  "vabs",
  "vadd",
  "vaddhn",
  "vaddl",
  "vaddw",
  "vand",
  "vbic",
  "vceq",
  "vcge",
  "vcgt",
  "vcle",
  "vcls",
  "vclt",
  "vclz",
  "vcmp",
  "vcnt",
  "vcvt",
  "vdiv",
  "vdup",
  "veor",
  "vext",
  "vh",
  "vld1",
  "vldm",
  "vldr",
  "vmov",
  "vmovl",
  "vmovn",
  "vmrs",
  "vmsr",
  "vmul",
  "vmull",
  "vmvn",
  "vneg",
  "vnmla",
  "vnmls",
  "vnmul",
  "vorn",
  "vorr",
  "vp",
  "vpadal",
  "vpadd",
  "vpaddl",
  "vpop",
  "vpush",
  "vqabs",
  "vqadd",
  "vqd",
  "vqdmulh",
  "vqdmull",
  "vqmov",
  "vqneg",
  "vqrdmulh",
  "vqrshl",
  "vqrshr",
  "vqshl",
  "vqshr",
  "vqsub",
  "vraddhn",
  "vrecpe",
  "vrecps",
  "vrev",
  "vrhadd",
  "vrshl",
  "vrshr",
  "vrshrn",
  "vrsqrte",
  "vrsqrts",
  "vrsra",
  "vrsubhn",
  "vshl",
  "vshll",
  "vshr",
  "vshrn",
  "vsli",
  "vsqrt",
  "vsra",
  "vsri",
  "vst1",
  "vstm",
  "vstr",
  "vsub",
  "vsubhn",
  "vsubl",
  "vsubw",
  "vswp",
  "vtrn",
  "vtst",
  "vuzp",
  "vzip",
  "wfe",
  "wfi",
  "yield"
};
bool ArmArchitecture::Disassemble(BinaryStream const& rBinStrm, OffsetType Offset, Instruction& rInsn, u8 Mode)
{
  rInsn.SetArchitectureTag(GetTag());
  rInsn.SetMode(Mode);

  switch (Mode)
  {
  case ARM_ModeArm:
    return DisassembleArm(rBinStrm, Offset, rInsn);
  case ARM_ModeThumb:
    return DisassembleThumb(rBinStrm, Offset, rInsn);
  default:
    return false;
  }
}
bool ArmArchitecture::DisassembleArm(BinaryStream const& rBinStrm, OffsetType Offset, Instruction& rInsn)
{
  u32 Opcode32;
  if (!rBinStrm.Read(Offset, Opcode32))
    return false;

  if ((Opcode32 & 0xffffffff) == 0xf57ff01f)
    // CLREX - [] - ['1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '1', '1', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '0', '0', '1', '(1)', '(1)', '(1)', '(1)']
    return Instruction_CLREX_A1_ffffffff_f57ff01f(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xfffffdff) == 0xf1010000)
    // SETEND <endian_specifier> - [] - ['1', '1', '1', '1', '0', '0', '0', '1', '0', '0', '0', '0', '(0)', '(0)', '(0)', '1', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', 'E#1', '(0)', '0', '0', '0', '0', '(0)', '(0)', '(0)', '(0)']
    return Instruction_SETEND_A1_fffffdff_f1010000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfffffff0)
  {
  case 0xf57ff040:
    // DSB #<option> - [] - ['1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '1', '1', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '1', '0', '0', 'option#4']
    return Instruction_DSB_A1_fffffff0_f57ff040(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf57ff050:
    // DMB #<option> - [] - ['1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '1', '1', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '1', '0', '1', 'option#4']
    return Instruction_DMB_A1_fffffff0_f57ff050(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf57ff060:
    // ISB #<option> - [] - ['1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '1', '1', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '1', '1', '0', 'option#4']
    return Instruction_ISB_A1_fffffff0_f57ff060(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fffffff)
  {
  case 0x0320f000:
    // NOP<c> - [] - ['cond#4', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0', '0', '0', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '0', '0', '0', '0', '0', '0', '0']
    return Instruction_NOP_A1_0fffffff_0320f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0320f001:
    // YIELD<c> - [] - ['cond#4', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0', '0', '0', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '0', '0', '0', '0', '0', '0', '1']
    return Instruction_YIELD_A1_0fffffff_0320f001(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0320f002:
    // WFE<c> - [] - ['cond#4', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0', '0', '0', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '0', '0', '0', '0', '0', '1', '0']
    return Instruction_WFE_A1_0fffffff_0320f002(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0320f003:
    // WFI<c> - [] - ['cond#4', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0', '0', '0', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '0', '0', '0', '0', '0', '1', '1']
    return Instruction_WFI_A1_0fffffff_0320f003(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0320f004:
    // SEV<c> - [] - ['cond#4', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0', '0', '0', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '0', '0', '0', '0', '1', '0', '0']
    return Instruction_SEV_A1_0fffffff_0320f004(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0ffffff0)
  {
  case 0x012fff10:
    // BX<c> Rm - ['call'] - ['cond#4', '0', '0', '0', '1', '0', '0', '1', '0', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '0', '0', '0', '1', 'Rm#4']
    return Instruction_BX_A1_0ffffff0_012fff10(rBinStrm, Offset, Opcode32, rInsn);
  case 0x012fff20:
    // BXJ<c> <Rm> - ['call'] - ['cond#4', '0', '0', '0', '1', '0', '0', '1', '0', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '0', 'Rm#4']
    return Instruction_BXJ_A1_0ffffff0_012fff20(rBinStrm, Offset, Opcode32, rInsn);
  case 0x012fff30:
    // BLX<c> <Rm> - ['call'] - ['cond#4', '0', '0', '0', '1', '0', '0', '1', '0', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rm#4']
    return Instruction_BLX_A1_0ffffff0_012fff30(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0320f0f0:
    // DBG<c> #<option> - [] - ['cond#4', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0', '0', '0', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '1', '1', '1', '1', 'option#4']
    return Instruction_DBG_A1_0ffffff0_0320f0f0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fff0fff)
  {
  case 0x010f0000:
    // MRS<c> <Rd>, <spec_reg> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '0', '0', '0', '(1)', '(1)', '(1)', '(1)', 'Rd#4', '(0)', '(0)', '(0)', '(0)', '0', '0', '0', '0', '(0)', '(0)', '(0)', '(0)']
    return Instruction_MRS_A1_0fff0fff_010f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x049d0004:
    // POP<c> <Rt> - ['could_ret'] - ['cond#4', '0', '1', '0', '0', '1', '0', '0', '1', '1', '1', '0', '1', 'Rt#4', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '0', '0']
    return Instruction_POP_A2_0fff0fff_049d0004(rBinStrm, Offset, Opcode32, rInsn);
  case 0x052d0004:
    // PUSH<c> <Rt> - [] - ['cond#4', '0', '1', '0', '1', '0', '0', '1', '0', '1', '1', '0', '1', 'Rt#4', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '0', '0']
    return Instruction_PUSH_A2_0fff0fff_052d0004(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0ee10a10:
    // VMSR<c> FPSCR, <Rt> - [] - ['cond#4', '1', '1', '1', '0', '1', '1', '1', '0', '0', '0', '0', '1', 'Rt#4', '1', '0', '1', '0', '0', '(0)', '(0)', '1', '(0)', '(0)', '(0)', '(0)']
    return Instruction_VMSR_A1_0fff0fff_0ee10a10(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0ef10a10:
    // VMRS<c> <Rt>, FPSCR - [] - ['cond#4', '1', '1', '1', '0', '1', '1', '1', '1', '0', '0', '0', '1', 'Rt#4', '1', '0', '1', '0', '0', '(0)', '(0)', '1', '(0)', '(0)', '(0)', '(0)']
    return Instruction_VMRS_A1_0fff0fff_0ef10a10(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0ff3fff0) == 0x0120f000)
    // MSR<c> <spec_reg>, <Rn> - [] - ['cond#4', '0', '0', '0', '1', '0', '0', '1', '0', 'mask#2', '0', '0', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '0', '0', '0', 'Rn#4']
    return Instruction_MSR_A1_0ff3fff0_0120f000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0x0fbf0e7f) == 0x0eb50a40)
    // VCMP{E}<c>.F32 <Sd>, #0.0 - ['support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '1', '0', '1', 'Vd#4', '1', '0', '1', 'sz#1', 'E#1', '1', '(0)', '0', '(0)', '(0)', '(0)', '(0)']
    return Instruction_VCMP_A2_0fbf0e7f_0eb50a40(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffb30fd0)
  {
  case 0xf3b20200:
    // VMOVN<c>.<dt> <Dd>, <Qm> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '1', '0', '0', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VMOVN_A1_ffb30fd0_f3b20200(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b20300:
    // VSHLL<c>.<type><size> <Qd>, <Dm>, #<imm> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '1', '1', '0', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VSHLL_A2_ffb30fd0_f3b20300(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fff0ff0)
  {
  case 0x016f0f10:
    // CLZ<c> <Rd>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '1', '1', '0', '(1)', '(1)', '(1)', '(1)', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '0', '1', 'Rm#4']
    return Instruction_CLZ_A1_0fff0ff0_016f0f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06bf0f30:
    // REV<c> <Rd>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '1', '1', '(1)', '(1)', '(1)', '(1)', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rm#4']
    return Instruction_REV_A1_0fff0ff0_06bf0f30(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06bf0fb0:
    // REV16<c> <Rd>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '1', '1', '(1)', '(1)', '(1)', '(1)', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '1', '1', 'Rm#4']
    return Instruction_REV16_A1_0fff0ff0_06bf0fb0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06ff0f30:
    // RBIT<c> <Rd>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '1', '1', '1', '(1)', '(1)', '(1)', '(1)', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rm#4']
    return Instruction_RBIT_A1_0fff0ff0_06ff0f30(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06ff0fb0:
    // REVSH<c> <Rd>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '1', '1', '1', '(1)', '(1)', '(1)', '(1)', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '1', '1', 'Rm#4']
    return Instruction_REVSH_A1_0fff0ff0_06ff0fb0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0ff00fff)
  {
  case 0x01900f9f:
    // LDREX<c> <Rt>, [<Rn>] - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '0', '1', 'Rn#4', 'Rt#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', '(1)', '(1)', '(1)', '(1)']
    return Instruction_LDREX_A1_0ff00fff_01900f9f(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01b00f9f:
    // LDREXD<c> <Rt>, <Rt2>, [<Rn>] - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', '1', 'Rn#4', 'Rt#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', '(1)', '(1)', '(1)', '(1)']
    return Instruction_LDREXD_A1_0ff00fff_01b00f9f(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01d00f9f:
    // LDREXB<c> <Rt>, [<Rn>] - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '1', '0', '1', 'Rn#4', 'Rt#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', '(1)', '(1)', '(1)', '(1)']
    return Instruction_LDREXB_A1_0ff00fff_01d00f9f(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01f00f9f:
    // LDREXH<c> <Rt>, [<Rn>] - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '1', '1', '1', 'Rn#4', 'Rt#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', '(1)', '(1)', '(1)', '(1)']
    return Instruction_LDREXH_A1_0ff00fff_01f00f9f(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffb30ed0) == 0xf3b20600)
    // VCVT<c>.F16.F32 <Dd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '1', '1', 'op#1', '0', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VCVT_A1_ffb30ed0_f3b20600(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffb30f90)
  {
  case 0xf3b00400:
    // VCLS<c>.<dt> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '0', '0', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCLS_A1_ffb30f90_f3b00400(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b00480:
    // VCLZ<c>.<dt> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '0', '0', '1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCLZ_A1_ffb30f90_f3b00480(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b00500:
    // VCNT<c>.8 <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '0', '1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCNT_A1_ffb30f90_f3b00500(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b00580:
    // VMVN<c> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '0', '1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VMVN_A1_ffb30f90_f3b00580(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b00700:
    // VQABS<c>.<dt> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '1', '1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VQABS_A1_ffb30f90_f3b00700(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b00780:
    // VQNEG<c>.<dt> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '1', '1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VQNEG_A1_ffb30f90_f3b00780(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b20000:
    // VSWP<c> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '0', '0', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VSWP_A1_ffb30f90_f3b20000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b20080:
    // VTRN<c>.<size> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '0', '0', '1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VTRN_A1_ffb30f90_f3b20080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b20100:
    // VUZP<c>.<size> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '0', '1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VUZP_A1_ffb30f90_f3b20100(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b20180:
    // VZIP<c>.<size> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '0', '1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VZIP_A1_ffb30f90_f3b20180(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xff7ff000) == 0xf55ff000)
    // PLD [PC,#-0] - [] - ['1', '1', '1', '1', '0', '1', '0', '1', 'U#1', '(1)', '0', '1', '1', '1', '1', '1', '(1)', '(1)', '(1)', '(1)', 'imm#12']
    return Instruction_PLD_A1_ff7ff000_f55ff000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0fef0ff0)
  {
  case 0x01a00000:
    // MOV{S}<c> <Rd>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', '0', '0', '0', '0', '0', '0', '0', '0', 'Rm#4']
    return Instruction_MOV_A1_0fef0ff0_01a00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01a00060:
    // RRX{S}<c> <Rd>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', '0', '0', '0', '0', '0', '1', '1', '0', 'Rm#4']
    return Instruction_RRX_A1_0fef0ff0_01a00060(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffb30f10)
  {
  case 0xf3b00200:
    // VPADDL<c>.<dt> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '0', '1', '0', 'op#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VPADDL_A1_ffb30f10_f3b00200(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b00600:
    // VPADAL<c>.<dt> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '1', '0', 'op#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VPADAL_A1_ffb30f10_f3b00600(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b20200:
    // VQMOV{op}N<c>.<type><size> <Dd>, <Qm> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '1', '0', 'op2#2', 'M#1', '0', 'Vm#4']
    return Instruction_VQMOV_A1_ffb30f10_f3b20200(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0fe00f7f) == 0x0e000a10)
    // VMOV<c> <Rt>, <Sn> - ['support it block'] - ['cond#4', '1', '1', '1', '0', '0', '0', '0', 'op#1', 'Vn#4', 'Rt#4', '1', '0', '1', '0', 'N#1', '(0)', '(0)', '1', '(0)', '(0)', '(0)', '(0)']
    return Instruction_VMOV_A1_0fe00f7f_0e000a10(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0fff03f0)
  {
  case 0x068f0070:
    // SXTB16<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '0', '0', '1', '1', '1', '1', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
    return Instruction_SXTB16_A1_0fff03f0_068f0070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06af0070:
    // SXTB<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '1', '0', '1', '1', '1', '1', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
    return Instruction_SXTB_A1_0fff03f0_06af0070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06bf0070:
    // SXTH<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '1', '1', '1', '1', '1', '1', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
    return Instruction_SXTH_A1_0fff03f0_06bf0070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06cf0070:
    // UXTB16<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '1', '0', '0', '1', '1', '1', '1', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
    return Instruction_UXTB16_A1_0fff03f0_06cf0070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06ef0070:
    // UXTB<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '1', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
    return Instruction_UXTB_A1_0fff03f0_06ef0070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06ff0070:
    // UXTH<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
    return Instruction_UXTH_A1_0fff03f0_06ff0070(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffb30e90)
  {
  case 0xf3b30400:
    // VRECPE<c>.<dt> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '1', 'Vd#4', '0', '1', '0', 'F#1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VRECPE_A1_ffb30e90_f3b30400(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b30480:
    // VRSQRTE<c>.<dt> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '1', 'Vd#4', '0', '1', '0', 'F#1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VRSQRTE_A1_ffb30e90_f3b30480(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffb30b90)
  {
  case 0xf3b10000:
    // VCGT<c>.<dt> <Dd>, <Dm>, #0 - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '0', '0', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCGT_A1_ffb30b90_f3b10000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b10080:
    // VCGE<c>.<dt> <Dd>, <Dm>, #0 - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '0', '0', '1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCGE_A1_ffb30b90_f3b10080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b10100:
    // VCEQ<c>.<dt> <Dd>, <Dm>, #0 - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '0', '1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCEQ_A1_ffb30b90_f3b10100(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b10180:
    // VCLE<c>.<dt> <Dd>, <Dm>, #0 - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '0', '1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCLE_A1_ffb30b90_f3b10180(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b10200:
    // VCLT<c>.<dt> <Dd>, <Dm>, #0 - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '1', '0', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCLT_A1_ffb30b90_f3b10200(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b10300:
    // VABS<c>.<dt> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '1', '1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VABS_A1_ffb30b90_f3b10300(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b10380:
    // VNEG<c>.<dt> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '1', '1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VNEG_A1_ffb30b90_f3b10380(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfe870fd0) == 0xf2800a10)
    // VMOVL<c>.<dt> <Qd>, <Dm> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'imm#3', '0', '0', '0', 'Vd#4', '1', '0', '1', '0', '0', '0', 'M#1', '1', 'Vm#4']
    return Instruction_VMOVL_A1_fe870fd0_f2800a10(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffb30e10)
  {
  case 0xf3b00000:
    // VREV<n><c>.<size> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '0', '0', 'op2#2', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VREV_A1_ffb30e10_f3b00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b30600:
    // VCVT<c>.<Td>.<Tm> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '1', 'Vd#4', '0', '1', '1', 'op#2', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCVT_A1_ffb30e10_f3b30600(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffb00f90) == 0xf3b00c00)
    // VDUP<c>.<size> <Dd>, <Dm[x]> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'imm#4', 'Vd#4', '1', '1', '0', '0', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VDUP_A1_ffb00f90_f3b00c00(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0fbf0ed0)
  {
  case 0x0eb00a40:
    // VMOV<c>.F32 <Sd>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '0', '0', '0', 'Vd#4', '1', '0', '1', 'sz#1', '0', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VMOV_A2_0fbf0ed0_0eb00a40(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0eb00ac0:
    // VABS<c>.F32 <Sd>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '0', '0', '0', 'Vd#4', '1', '0', '1', 'sz#1', '1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VABS_A2_0fbf0ed0_0eb00ac0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0eb10a40:
    // VNEG<c>.F32 <Sd>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '0', '0', '1', 'Vd#4', '1', '0', '1', 'sz#1', '0', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VNEG_A2_0fbf0ed0_0eb10a40(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0eb10ac0:
    // VSQRT<c>.F32 <Sd>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '0', '0', '1', 'Vd#4', '1', '0', '1', 'sz#1', '1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VSQRT_A1_0fbf0ed0_0eb10ac0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0eb70ac0:
    // VCVT<c>.F32.F64 <Sd>, <Dm> - ['support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '1', '1', '1', 'Vd#4', '1', '0', '1', 'sz#1', '1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VCVT_A1_0fbf0ed0_0eb70ac0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0ff00ff0)
  {
  case 0x01000050:
    // QADD<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '0', '0', '0', 'Rn#4', 'Rd#4', '(0)', '(0)', '(0)', '(0)', '0', '1', '0', '1', 'Rm#4']
    return Instruction_QADD_A1_0ff00ff0_01000050(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01200050:
    // QSUB<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '0', '1', '0', 'Rn#4', 'Rd#4', '(0)', '(0)', '(0)', '(0)', '0', '1', '0', '1', 'Rm#4']
    return Instruction_QSUB_A1_0ff00ff0_01200050(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01400050:
    // QDADD<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '1', '0', '0', 'Rn#4', 'Rd#4', '(0)', '(0)', '(0)', '(0)', '0', '1', '0', '1', 'Rm#4']
    return Instruction_QDADD_A1_0ff00ff0_01400050(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01600050:
    // QDSUB<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '1', '1', '0', 'Rn#4', 'Rd#4', '(0)', '(0)', '(0)', '(0)', '0', '1', '0', '1', 'Rm#4']
    return Instruction_QDSUB_A1_0ff00ff0_01600050(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01800f90:
    // STREX<c> <Rd>, <Rt>, [<Rn>] - [] - ['cond#4', '0', '0', '0', '1', '1', '0', '0', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', 'Rt#4']
    return Instruction_STREX_A1_0ff00ff0_01800f90(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01a00f90:
    // STREXD<c> <Rd>, <Rt>, <Rt2>, [<Rn>] - [] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', 'Rt#4']
    return Instruction_STREXD_A1_0ff00ff0_01a00f90(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01c00f90:
    // STREXB<c> <Rd>, <Rt>, [<Rn>] - [] - ['cond#4', '0', '0', '0', '1', '1', '1', '0', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', 'Rt#4']
    return Instruction_STREXB_A1_0ff00ff0_01c00f90(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01e00f90:
    // STREXH<c> <Rd>, <Rt>, [<Rn>] - [] - ['cond#4', '0', '0', '0', '1', '1', '1', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', 'Rt#4']
    return Instruction_STREXH_A1_0ff00ff0_01e00f90(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06100f10:
    // SADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '0', '1', 'Rm#4']
    return Instruction_SADD16_A1_0ff00ff0_06100f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06100f30:
    // SASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rm#4']
    return Instruction_SASX_A1_0ff00ff0_06100f30(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06100f50:
    // SSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '1', 'Rm#4']
    return Instruction_SSAX_A1_0ff00ff0_06100f50(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06100f70:
    // SSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '1', '1', 'Rm#4']
    return Instruction_SSUB16_A1_0ff00ff0_06100f70(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06100f90:
    // SADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', 'Rm#4']
    return Instruction_SADD8_A1_0ff00ff0_06100f90(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06100ff0:
    // SSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '1', '1', '1', 'Rm#4']
    return Instruction_SSUB8_A1_0ff00ff0_06100ff0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06200f10:
    // QADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '0', '1', 'Rm#4']
    return Instruction_QADD16_A1_0ff00ff0_06200f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06200f30:
    // QASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rm#4']
    return Instruction_QASX_A1_0ff00ff0_06200f30(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06200f50:
    // QSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '1', 'Rm#4']
    return Instruction_QSAX_A1_0ff00ff0_06200f50(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06200f70:
    // QSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '1', '1', 'Rm#4']
    return Instruction_QSUB16_A1_0ff00ff0_06200f70(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06200f90:
    // QADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', 'Rm#4']
    return Instruction_QADD8_A1_0ff00ff0_06200f90(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06200ff0:
    // QSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '1', '1', '1', 'Rm#4']
    return Instruction_QSUB8_A1_0ff00ff0_06200ff0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06300f10:
    // SHADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '0', '1', 'Rm#4']
    return Instruction_SHADD16_A1_0ff00ff0_06300f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06300f30:
    // SHASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rm#4']
    return Instruction_SHASX_A1_0ff00ff0_06300f30(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06300f50:
    // SHSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '1', 'Rm#4']
    return Instruction_SHSAX_A1_0ff00ff0_06300f50(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06300f70:
    // SHSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '1', '1', 'Rm#4']
    return Instruction_SHSUB16_A1_0ff00ff0_06300f70(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06300f90:
    // SHADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', 'Rm#4']
    return Instruction_SHADD8_A1_0ff00ff0_06300f90(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06300ff0:
    // SHSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '1', '1', '1', 'Rm#4']
    return Instruction_SHSUB8_A1_0ff00ff0_06300ff0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06500f10:
    // UADD16<c> <Rd>, <Rn>, <Rm> - [] - ['cond#4', '0', '1', '1', '0', '0', '1', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '0', '1', 'Rm#4']
    return Instruction_UADD16_A1_0ff00ff0_06500f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06500f30:
    // UASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rm#4']
    return Instruction_UASX_A1_0ff00ff0_06500f30(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06500f50:
    // USAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '1', 'Rm#4']
    return Instruction_USAX_A1_0ff00ff0_06500f50(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06500f70:
    // USUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '1', '1', 'Rm#4']
    return Instruction_USUB16_A1_0ff00ff0_06500f70(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06500f90:
    // UADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', 'Rm#4']
    return Instruction_UADD8_A1_0ff00ff0_06500f90(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06500ff0:
    // USUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '1', '1', '1', 'Rm#4']
    return Instruction_USUB8_A1_0ff00ff0_06500ff0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06600f10:
    // UQADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '0', '1', 'Rm#4']
    return Instruction_UQADD16_A1_0ff00ff0_06600f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06600f30:
    // UQASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rm#4']
    return Instruction_UQASX_A1_0ff00ff0_06600f30(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06600f50:
    // UQSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '1', 'Rm#4']
    return Instruction_UQSAX_A1_0ff00ff0_06600f50(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06600f70:
    // UQSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '1', '1', 'Rm#4']
    return Instruction_UQSUB16_A1_0ff00ff0_06600f70(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06600f90:
    // UQADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', 'Rm#4']
    return Instruction_UQADD8_A1_0ff00ff0_06600f90(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06600ff0:
    // UQSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '1', '1', '1', 'Rm#4']
    return Instruction_UQSUB8_A1_0ff00ff0_06600ff0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06700f10:
    // UHADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '0', '1', 'Rm#4']
    return Instruction_UHADD16_A1_0ff00ff0_06700f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06700f30:
    // UHASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rm#4']
    return Instruction_UHASX_A1_0ff00ff0_06700f30(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06700f50:
    // UHSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '1', 'Rm#4']
    return Instruction_UHSAX_A1_0ff00ff0_06700f50(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06700f70:
    // UHSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '1', '1', 'Rm#4']
    return Instruction_UHSUB16_A1_0ff00ff0_06700f70(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06700f90:
    // UHADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', 'Rm#4']
    return Instruction_UHADD8_A1_0ff00ff0_06700f90(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06700ff0:
    // UHSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '1', '1', '1', 'Rm#4']
    return Instruction_UHSUB8_A1_0ff00ff0_06700ff0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06800fb0:
    // SEL<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '0', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '1', '1', 'Rm#4']
    return Instruction_SEL_A1_0ff00ff0_06800fb0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06a00f30:
    // SSAT16<c> <Rd>, #<imm>, <Rn> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '1', '0', 'sat_imm#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rn#4']
    return Instruction_SSAT16_A1_0ff00ff0_06a00f30(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06e00f30:
    // USAT16<c> <Rd>, #<imm4>, <Rn> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '1', '1', '0', 'sat_imm#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rn#4']
    return Instruction_USAT16_A1_0ff00ff0_06e00f30(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffb00f10)
  {
  case 0xf2000110:
    // VAND<c> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', '0', '0', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VAND_A1_ffb00f10_f2000110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2100110:
    // VBIC<c> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', '0', '1', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VBIC_A1_ffb00f10_f2100110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2200110:
    // VORR<c> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', '1', '0', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VORR_A1_ffb00f10_f2200110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2300110:
    // VORN<c> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', '1', '1', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VORN_A1_ffb00f10_f2300110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3000110:
    // VEOR<c> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', '0', '0', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VEOR_A1_ffb00f10_f3000110(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0ff0f0f0) == 0x0780f010)
    // USAD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '1', '0', '0', '0', 'Rd#4', '1', '1', '1', '1', 'Rm#4', '0', '0', '0', '1', 'Rn#4']
    return Instruction_USAD8_A1_0ff0f0f0_0780f010(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xff800fd0)
  {
  case 0xf2800810:
    // VSHRN<c>.I<size> <Dd>, <Qm>, #<imm> - [] - ['1', '1', '1', '1', '0', '0', '1', '0', '1', 'D#1', 'imm#6', 'Vd#4', '1', '0', '0', '0', '0', '0', 'M#1', '1', 'Vm#4']
    return Instruction_VSHRN_A1_ff800fd0_f2800810(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800850:
    // VRSHRN<c>.I<size> <Dd>, <Qm>, #<imm> - [] - ['1', '1', '1', '1', '0', '0', '1', '0', '1', 'D#1', 'imm#6', 'Vd#4', '1', '0', '0', '0', '0', '1', 'M#1', '1', 'Vm#4']
    return Instruction_VRSHRN_A1_ff800fd0_f2800850(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0fbf0e50) == 0x0eb40a40)
    // VCMP{E}<c>.F32 <Sd>, <Sm> - ['support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '1', '0', '0', 'Vd#4', '1', '0', '1', 'sz#1', 'E#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VCMP_A1_0fbf0e50_0eb40a40(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0x0f900f5f) == 0x0e800b10)
    // VDUP<c>.<size> - ['support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'b_size#1', 'Q#1', '0', 'Vd#4', 'Rt#4', '1', '0', '1', '1', 'D#1', '0', 'e_size#1', '1', '(0)', '(0)', '(0)', '(0)']
    return Instruction_VDUP_A1_0f900f5f_0e800b10(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xff70f010) == 0xf650f000)
    // PLI [<Rn>,+/-<Rm>{,<shift>}] - [] - ['1', '1', '1', '1', '0', '1', '1', '0', 'U#1', '1', '0', '1', 'Rn#4', '(1)', '(1)', '(1)', '(1)', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_PLI_A1_ff70f010_f650f000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0x0fbe0f50) == 0x0eb20a40)
    // VCVT<y><c>.F16.F32 <Sd>, <Sm> - ['support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '0', '1', 'op#1', 'Vd#4', '1', '0', '1', '0', 'T#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VCVT_A1_0fbe0f50_0eb20a40(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xff70f000) == 0xf450f000)
    // PLI [PC,#-0] - [] - ['1', '1', '1', '1', '0', '1', '0', '0', 'U#1', '1', '0', '1', 'Rn#4', '(1)', '(1)', '(1)', '(1)', 'imm#12']
    return Instruction_PLI_A1_ff70f000_f450f000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0f7f00f0)
  {
  case 0x014f00d0:
    // LDRD<c> <Rt>, <Rt2>, [PC,#-0] - ['could_jmp'] - ['cond#4', '0', '0', '0', '(1)', 'U#1', '1', '(0)', '0', '1', '1', '1', '1', 'Rt#4', 'imm_h#4', '1', '1', '0', '1', 'imm_l#4']
    return Instruction_LDRD_A1_0f7f00f0_014f00d0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x015f00b0:
    // LDRH<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['cond#4', '0', '0', '0', '(1)', 'U#1', '1', '(0)', '1', '1', '1', '1', '1', 'Rt#4', 'imm_h#4', '1', '0', '1', '1', 'imm_l#4']
    return Instruction_LDRH_A1_0f7f00f0_015f00b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x015f00d0:
    // LDRSB<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['cond#4', '0', '0', '0', '(1)', 'U#1', '1', '(0)', '1', '1', '1', '1', '1', 'Rt#4', 'imm_h#4', '1', '1', '0', '1', 'imm_l#4']
    return Instruction_LDRSB_A1_0f7f00f0_015f00d0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x015f00f0:
    // LDRSH<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['cond#4', '0', '0', '0', '(1)', 'U#1', '1', '(0)', '1', '1', '1', '1', '1', 'Rt#4', 'imm_h#4', '1', '1', '1', '1', 'imm_l#4']
    return Instruction_LDRSH_A1_0f7f00f0_015f00f0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fbf0f00)
  {
  case 0x0cbd0a00:
    // FLDMX - ['support it block'] - ['cond#4', '1', '1', '0', '0', '1', 'D#1', '1', '1', '1', '1', '0', '1', 'Vd#4', '1', '0', '1', '0', 'imm#8']
    return Instruction_FLDMX_A2_0fbf0f00_0cbd0a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0cbd0b00:
    // VPOP <list> - [] - ['cond#4', '1', '1', '0', '0', '1', 'D#1', '1', '1', '1', '1', '0', '1', 'Vd#4', '1', '0', '1', '1', 'imm#8']
    return Instruction_VPOP_A1_0fbf0f00_0cbd0b00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0d2d0a00:
    // FSTMX - ['support it block'] - ['cond#4', '1', '1', '0', '1', '0', 'D#1', '1', '0', '1', '1', '0', '1', 'Vd#4', '1', '0', '1', '0', 'imm#8']
    return Instruction_FSTMX_A2_0fbf0f00_0d2d0a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0d2d0b00:
    // VPUSH<c> <list> - [] - ['cond#4', '1', '1', '0', '1', '0', 'D#1', '1', '0', '1', '1', '0', '1', 'Vd#4', '1', '0', '1', '1', 'imm#8']
    return Instruction_VPUSH_A1_0fbf0f00_0d2d0b00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfe800fd0) == 0xf2800a10)
    // VSHLL<c>.<type><size> <Qd>, <Dm>, #<imm> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'imm#6', 'Vd#4', '1', '0', '1', '0', '0', '0', 'M#1', '1', 'Vm#4']
    return Instruction_VSHLL_A1_fe800fd0_f2800a10(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xffb00f00) == 0xf4a00c00)
    // VLD1<c>.<size> <list>, [<Rn>{@<align>}], <Rm> - ['support it block'] - ['1', '1', '1', '1', '0', '1', '0', '0', '1', 'D#1', '1', '0', 'Rn#4', 'Vd#4', '1', '1', '0', '0', 'size#2', 'T#1', 'a#1', 'Rm#4']
    return Instruction_VLD1_A1_ffb00f00_f4a00c00(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0fef00f0)
  {
  case 0x01a00010:
    // LSL{S}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'Rm#4', '0', '0', '0', '1', 'Rn#4']
    return Instruction_LSL_A1_0fef00f0_01a00010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01a00030:
    // LSR{S}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'Rm#4', '0', '0', '1', '1', 'Rn#4']
    return Instruction_LSR_A1_0fef00f0_01a00030(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01a00050:
    // ASR{S}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'Rm#4', '0', '1', '0', '1', 'Rn#4']
    return Instruction_ASR_A1_0fef00f0_01a00050(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01a00070:
    // ROR{S}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'Rm#4', '0', '1', '1', '1', 'Rn#4']
    return Instruction_ROR_A1_0fef00f0_01a00070(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0fb00ff0) == 0x01000090)
    // SWP{B}<c> <Rt>, <Rt2>, [<Rn>] - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', 'B#1', '0', '0', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '0', '0', '1', 'Rt2#4']
    return Instruction_SWP_A1_0fb00ff0_01000090(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffa00f10)
  {
  case 0xf2000d00:
    // VADD<c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VADD_A1_ffa00f10_f2000d00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000e00:
    // VCEQ<c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCEQ_A2_ffa00f10_f2000e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000f10:
    // VRECPS<c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VRECPS_A1_ffa00f10_f2000f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2200d00:
    // VSUB<c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', '1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VSUB_A1_ffa00f10_f2200d00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2200f10:
    // VRSQRTS<c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', '1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VRSQRTS_A1_ffa00f10_f2200f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3000d00:
    // VPADD<c>.F32 - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VPADD_A1_ffa00f10_f3000d00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3000d10:
    // VMUL<c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VMUL_A1_ffa00f10_f3000d10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3000e00:
    // VCGE<c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCGE_A2_ffa00f10_f3000e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3200d00:
    // VABD<c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', '1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VABD_A1_ffa00f10_f3200d00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3200e00:
    // VCGT<c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', '1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCGT_A2_ffa00f10_f3200e00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0f900f1f) == 0x0e000b10)
    // VMOV<c>.<size> <Dd[x]>, <Rt> - [] - ['cond#4', '1', '1', '1', '0', '0', 'opc1#2', '0', 'Vd#4', 'Rt#4', '1', '0', '1', '1', 'D#1', 'opc2#2', '1', '(0)', '(0)', '(0)', '(0)']
    return Instruction_VMOV_A1_0f900f1f_0e000b10(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0f700ff0)
  {
  case 0x002000b0:
    // STRHT<c> <Rt>, [<Rn>], +/-<Rm> - [] - ['cond#4', '0', '0', '0', '0', 'U#1', '0', '1', '0', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '0', '1', '1', 'Rm#4']
    return Instruction_STRHT_A2_0f700ff0_002000b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x003000b0:
    // LDRHT<c> <Rt>, [<Rn>], +/-<Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', 'U#1', '0', '1', '1', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '0', '1', '1', 'Rm#4']
    return Instruction_LDRHT_A2_0f700ff0_003000b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x003000d0:
    // LDRSBT<c> <Rt>, [<Rn>], +/-<Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', 'U#1', '0', '1', '1', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '1', '0', '1', 'Rm#4']
    return Instruction_LDRSBT_A2_0f700ff0_003000d0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x003000f0:
    // LDRSHT<c> <Rt>, [<Rn>], +/-<Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', 'U#1', '0', '1', '1', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '1', '1', '1', 'Rm#4']
    return Instruction_LDRSHT_A2_0f700ff0_003000f0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0fe0f0f0) == 0x00000090)
    // MUL{S}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '0', '0', 'S#1', 'Rd#4', '(0)', '(0)', '(0)', '(0)', 'Rm#4', '1', '0', '0', '1', 'Rn#4']
    return Instruction_MUL_A1_0fe0f0f0_00000090(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xff800f50)
  {
  case 0xf2800400:
    // VADDHN<c>.<dt> <Dd>, <Qn>, <Qm> - [] - ['1', '1', '1', '1', '0', '0', '1', '0', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VADDHN_A1_ff800f50_f2800400(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800600:
    // VSUBHN<c>.<dt> <Dd>, <Qn>, <Qm> - [] - ['1', '1', '1', '1', '0', '0', '1', '0', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VSUBHN_A1_ff800f50_f2800600(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800b40:
    // VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]> - [] - ['1', '1', '1', '1', '0', '0', '1', '0', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '1', 'N#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VQDMULL_A2_ff800f50_f2800b40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800d00:
    // VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm> - [] - ['1', '1', '1', '1', '0', '0', '1', '0', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VQDMULL_A1_ff800f50_f2800d00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3800400:
    // VRADDHN<c>.<dt> <Dd>, <Qn>, <Qm> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VRADDHN_A1_ff800f50_f3800400(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3800600:
    // VRSUBHN<c>.<dt> <Dd>, <Qn>, <Qm> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VRSUBHN_A1_ff800f50_f3800600(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0ff0f0d0)
  {
  case 0x0700f010:
    // SMUAD{X}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '0', '0', '0', '0', 'Rd#4', '1', '1', '1', '1', 'Rm#4', '0', '0', 'M#1', '1', 'Rn#4']
    return Instruction_SMUAD_A1_0ff0f0d0_0700f010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0700f050:
    // SMUSD{X}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '0', '0', '0', '0', 'Rd#4', '1', '1', '1', '1', 'Rm#4', '0', '1', 'M#1', '1', 'Rn#4']
    return Instruction_SMUSD_A1_0ff0f0d0_0700f050(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0750f010:
    // SMMUL{R}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '0', '1', '0', '1', 'Rd#4', '1', '1', '1', '1', 'Rm#4', '0', '0', 'R#1', '1', 'Rn#4']
    return Instruction_SMMUL_A1_0ff0f0d0_0750f010(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fe00fd0)
  {
  case 0x0c400a10:
    // VMOV<c> <Rt>, <Rt2>, <Sm>, <Sm1> - ['support it block'] - ['cond#4', '1', '1', '0', '0', '0', '1', '0', 'op#1', 'Rt2#4', 'Rt#4', '1', '0', '1', '0', '0', '0', 'M#1', '1', 'Vm#4']
    return Instruction_VMOV_A1_0fe00fd0_0c400a10(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0c400b10:
    // VMOV<c> <Rt>, <Rt2>, <Dm> - ['support it block'] - ['cond#4', '1', '1', '0', '0', '0', '1', '0', 'op#1', 'Rt2#4', 'Rt#4', '1', '0', '1', '1', '0', '0', 'M#1', '1', 'Vm#4']
    return Instruction_VMOV_A1_0fe00fd0_0c400b10(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfeb800b0)
  {
  case 0xf2800010:
    // VORR<c>.<dt> <Dd>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'imm#1', '1', 'D#1', '0', '0', '0', 'imm#3', 'Vd#4', 'cmode#4', '0', 'Q#1', '0', '1', 'imm#4']
    return Instruction_VORR_A1_feb800b0_f2800010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800030:
    // VBIC<c>.<dt> <Dd>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'imm#1', '1', 'D#1', '0', '0', '0', 'imm#3', 'Vd#4', 'cmode#4', '0', 'Q#1', '1', '1', 'imm#4']
    return Instruction_VBIC_A1_feb800b0_f2800030(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0ff003f0)
  {
  case 0x06800070:
    // SXTAB16<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '0', '0', 'Rn#4', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
    return Instruction_SXTAB16_A1_0ff003f0_06800070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06a00070:
    // SXTAB<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '1', '0', 'Rn#4', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
    return Instruction_SXTAB_A1_0ff003f0_06a00070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06b00070:
    // SXTAH<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '1', '1', 'Rn#4', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
    return Instruction_SXTAH_A1_0ff003f0_06b00070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06c00070:
    // UXTAB16<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '1', '0', '0', 'Rn#4', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
    return Instruction_UXTAB16_A1_0ff003f0_06c00070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06e00070:
    // UXTAB<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '1', '1', '0', 'Rn#4', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
    return Instruction_UXTAB_A1_0ff003f0_06e00070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06f00070:
    // UXTAH<c> <Rd>, <Rn>, <Rm>{,<rotation>} - [] - ['cond#4', '0', '1', '1', '0', '1', '1', '1', '1', 'Rn#4', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
    return Instruction_UXTAH_A1_0ff003f0_06f00070(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffb00c10) == 0xf3b00800)
    // V<op><c>.8 <Dd>, <list>, <Dm> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'Vn#4', 'Vd#4', '1', '0', 'len#2', 'N#1', 'op#1', 'M#1', '0', 'Vm#4']
    return Instruction_V_A1_ffb00c10_f3b00800(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0ff0f090)
  {
  case 0x01100010:
    // TST<c> <Rn>, <Rm>, <type> <Rs> - [] - ['cond#4', '0', '0', '0', '1', '0', '0', '0', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
    return Instruction_TST_A1_0ff0f090_01100010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01300010:
    // TEQ<c> <Rn>, <Rm>, <type> <Rs> - [] - ['cond#4', '0', '0', '0', '1', '0', '0', '1', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
    return Instruction_TEQ_A1_0ff0f090_01300010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01500010:
    // CMP<c> <Rn>, <Rm>, <type> <Rs> - ['cond'] - ['cond#4', '0', '0', '0', '1', '0', '1', '0', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
    return Instruction_CMP_A1_0ff0f090_01500010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01700010:
    // CMN<c> <Rn>, <Rm>, <type> <Rs> - ['cond'] - ['cond#4', '0', '0', '0', '1', '0', '1', '1', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
    return Instruction_CMN_A1_0ff0f090_01700010(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fef0070)
  {
  case 0x01a00000:
    // LSL{S}<c> <Rd>, <Rm>, #<imm5> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'imm#5', '0', '0', '0', 'Rm#4']
    return Instruction_LSL_A1_0fef0070_01a00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01a00020:
    // LSR{S}<c> <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'imm#5', '0', '1', '0', 'Rm#4']
    return Instruction_LSR_A1_0fef0070_01a00020(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01a00040:
    // ASR{S}<c> <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'imm#5', '1', '0', '0', 'Rm#4']
    return Instruction_ASR_A1_0fef0070_01a00040(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01a00060:
    // ROR{S}<c> <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'imm#5', '1', '1', '0', 'Rm#4']
    return Instruction_ROR_A1_0fef0070_01a00060(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0fe0007f) == 0x07c0001f)
    // BFC<c> <Rd>, #<lsb>, #<width> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '1', '1', '0', 'msb#5', 'Rd#4', 'lsb#5', '0', '0', '1', '1', '1', '1', '1']
    return Instruction_BFC_A1_0fe0007f_07c0001f(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0x0ff3f000) == 0x0320f000)
    // MSR<c> <spec_reg>, #<arm_expand_imm> - [] - ['cond#4', '0', '0', '1', '1', '0', '0', '1', '0', 'mask#2', '0', '0', '(1)', '(1)', '(1)', '(1)', 'imm#12']
    return Instruction_MSR_A1_0ff3f000_0320f000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0x0fb00ef0) == 0x0eb00a00)
    // VMOV<c>.F32 <Sd>, #<imm> - ['support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', 'imm_h#4', 'Vd#4', '1', '0', '1', 'sz#1', '(0)', '0', '(0)', '0', 'imm_l#4']
    return Instruction_VMOV_A2_0fb00ef0_0eb00a00(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0x0f100f1f) == 0x0e100b10)
    // VMOV<c>.<dt> <Rt>, <Dn[x]> - [] - ['cond#4', '1', '1', '1', '0', 'U#1', 'opc1#2', '1', 'Vn#4', 'Rt#4', '1', '0', '1', '1', 'N#1', 'opc2#2', '1', '(0)', '(0)', '(0)', '(0)']
    return Instruction_VMOV_A1_0f100f1f_0e100b10(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfe800ed0)
  {
  case 0xf2800810:
    // VQSHR{op}N<c>.<type><size> <Dd>, <Qm>, #<imm> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'imm#6', 'Vd#4', '1', '0', '0', 'op#1', '0', '0', 'M#1', '1', 'Vm#4']
    return Instruction_VQSHR_A1_fe800ed0_f2800810(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800850:
    // VQRSHR{op}N<c>.<type><size> <Dd>, <Qm>, #<imm> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'imm#6', 'Vd#4', '1', '0', '0', 'op#1', '0', '1', 'M#1', '1', 'Vm#4']
    return Instruction_VQRSHR_A1_fe800ed0_f2800850(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xff800d50) == 0xf2800900)
    // VQD<op><c>.<dt> <Qd>, <Dn>, <Dm> - [] - ['1', '1', '1', '1', '0', '0', '1', '0', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', 'op#1', '1', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VQD_A1_ff800d50_f2800900(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfe800f50)
  {
  case 0xf2800c40:
    // VQDMULH<c>.<dt> <Dd>, <Dn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'Q#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '1', '0', '0', 'N#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VQDMULH_A2_fe800f50_f2800c40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800d40:
    // VQRDMULH<c>.<dt> <Dd>, <Dn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'Q#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VQRDMULH_A2_fe800f50_f2800d40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800500:
    // VABAL<c>.<dt> <Qd>, <Dn>, <Dm> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '1', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VABAL_A2_fe800f50_f2800500(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800700:
    // VABDL<c>.<dt> <Qd>, <Dn>, <Dm> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '1', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VABDL_A2_fe800f50_f2800700(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800a40:
    // VMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '0', 'N#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VMULL_A2_fe800f50_f2800a40(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0fba0e50) == 0x0eba0a40)
    // VCVT<c>.F32.<Td> <Sd>, <Sd>, #<fbits> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', '1', 'op#1', '1', 'U#1', 'Vd#4', '1', '0', '1', 'sf#1', 'sx#1', '1', 'imm#1', '0', 'imm#4']
    return Instruction_VCVT_A1_0fba0e50_0eba0a40(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xff800f10)
  {
  case 0xf2000d10:
    // V<op><c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', 'op#1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_V_A1_ff800f10_f2000d10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000f00:
    // V<op><c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', 'op#1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_V_A1_ff800f10_f2000f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000800:
    // VADD<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VADD_A1_ff800f10_f2000800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000810:
    // VTST<c>.<size> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VTST_A1_ff800f10_f2000810(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000b00:
    // VQDMULH<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VQDMULH_A1_ff800f10_f2000b00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000b10:
    // VPADD<c>.<dt> - [] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VPADD_A1_ff800f10_f2000b10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800510:
    // VSHL<c>.I<size> <Dd>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '1', 'D#1', 'imm#6', 'Vd#4', '0', '1', '0', '1', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VSHL_A1_ff800f10_f2800510(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3000e10:
    // V<op><c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', 'op#1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_V_A1_ff800f10_f3000e10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3000f00:
    // VP<op><c>.F32 <Dd>, <Dn>, <Dm> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', 'op#1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VP_A1_ff800f10_f3000f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3000110:
    // V<op><c> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', 'op#2', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_V_A1_ff800f10_f3000110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3000800:
    // VSUB<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VSUB_A1_ff800f10_f3000800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3000810:
    // VCEQ<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VCEQ_A1_ff800f10_f3000810(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3000b00:
    // VQRDMULH<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VQRDMULH_A1_ff800f10_f3000b00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3800410:
    // VSRI<c>.<size> <Dd>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '1', '0', '0', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VSRI_A1_ff800f10_f3800410(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3800510:
    // VSLI<c>.<size> <Dd>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '1', '0', '1', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VSLI_A1_ff800f10_f3800510(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xff800b50) == 0xf2800340)
    // VQD<op><c>.<dt> <Qd>, <Dn>, <Dm[x]> - [] - ['1', '1', '1', '1', '0', '0', '1', '0', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', 'op#1', '1', '1', 'N#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VQD_A2_ff800b50_f2800340(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0ff0f010)
  {
  case 0x01100000:
    // TST<c> <Rn>, <Rm>{,<shift>} - [] - ['cond#4', '0', '0', '0', '1', '0', '0', '0', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_TST_A1_0ff0f010_01100000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01300000:
    // TEQ<c> <Rn>, <Rm>{,<shift>} - [] - ['cond#4', '0', '0', '0', '1', '0', '0', '1', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_TEQ_A1_0ff0f010_01300000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01500000:
    // CMP<c> <Rn>, <Rm>{,<shift>} - ['cond'] - ['cond#4', '0', '0', '0', '1', '0', '1', '0', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_CMP_A1_0ff0f010_01500000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01700000:
    // CMN<c> <Rn>, <Rm>{,<shift>} - ['cond'] - ['cond#4', '0', '0', '0', '1', '0', '1', '1', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_CMN_A1_0ff0f010_01700000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffb00300)
  {
  case 0xf4800000:
    // VST1<c>.<size> <list>, [<Rn>{@<align>}], <Rm> - ['support it block'] - ['1', '1', '1', '1', '0', '1', '0', '0', '1', 'D#1', '0', '0', 'Rn#4', 'Vd#4', 'size#2', '0', '0', 'index_align#4', 'Rm#4']
    return Instruction_VST1_A1_ffb00300_f4800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf4a00000:
    // VLD1<c>.<size> <list>, [<Rn>{@<align>}], <Rm> - ['support it block'] - ['1', '1', '1', '1', '0', '1', '0', '0', '1', 'D#1', '1', '0', 'Rn#4', 'Vd#4', 'size#2', '0', '0', 'index_align#4', 'Rm#4']
    return Instruction_VLD1_A1_ffb00300_f4a00000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfe800f10)
  {
  case 0xf2000010:
    // VQADD<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '0', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VQADD_A1_fe800f10_f2000010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000100:
    // VRHADD<c> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VRHADD_A1_fe800f10_f2000100(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000210:
    // VQSUB<c>.<type><size> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '1', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VQSUB_A1_fe800f10_f2000210(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000300:
    // VCGT<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCGT_A1_fe800f10_f2000300(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000310:
    // VCGE<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '1', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VCGE_A1_fe800f10_f2000310(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000400:
    // VSHL<c>.I<size> <Dd>, <Dm>, <Dn> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VSHL_A1_fe800f10_f2000400(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000410:
    // VQSHL<c>.<type><size> <Dd>, <Dm>, <Dn> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VQSHL_A1_fe800f10_f2000410(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000500:
    // VRSHL<c>.<type><size> <Dd>, <Dm>, <Dn> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VRSHL_A1_fe800f10_f2000500(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000510:
    // VQRSHL<c>.<type><size> <Dd>, <Dm>, <Dn> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VQRSHL_A1_fe800f10_f2000510(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000700:
    // VABD<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VABD_A1_fe800f10_f2000700(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000710:
    // VABA<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VABA_A1_fe800f10_f2000710(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800010:
    // VSHR<c>.<type><size> <Dd>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '0', '0', '0', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VSHR_A1_fe800f10_f2800010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800110:
    // VSRA<c>.<type><size> <Dd>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '0', '0', '1', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VSRA_A1_fe800f10_f2800110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800210:
    // VRSHR<c>.<type><size> <Dd>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '0', '1', '0', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VRSHR_A1_fe800f10_f2800210(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800310:
    // VRSRA<c>.<type><size> <Dd>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '0', '1', '1', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VRSRA_A1_fe800f10_f2800310(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000900:
    // V<op><c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'op#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_V_A1_fe800f10_f2000900(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000910:
    // VMUL<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'op#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VMUL_A1_fe800f10_f2000910(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0fef0090) == 0x01e00010)
    // MVN{S}<c> <Rd>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '1', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
    return Instruction_MVN_A1_0fef0090_01e00010(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xfeb80090) == 0xf2800010)
    // VMOV<c>.<dt> <Dd>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'imm#1', '1', 'D#1', '0', '0', '0', 'imm#3', 'Vd#4', 'cmode#4', '0', 'Q#1', 'op#1', '1', 'imm#4']
    return Instruction_VMOV_A1_feb80090_f2800010(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0e500ff0)
  {
  case 0x000000b0:
    // STRH<c> <Rt>, [<Rn>],+/-<Rm> - [] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '0', 'W#1', '0', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '0', '1', '1', 'Rm#4']
    return Instruction_STRH_A1_0e500ff0_000000b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x000000d0:
    // LDRD<c> <Rt>, <Rt2>, [<Rn>],+/-<Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '0', 'W#1', '0', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '1', '0', '1', 'Rm#4']
    return Instruction_LDRD_A1_0e500ff0_000000d0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x000000f0:
    // STRD<c> <Rt>, <Rt2>, [<Rn>],+/-<Rm> - [] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '0', 'W#1', '0', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '1', '1', '1', 'Rm#4']
    return Instruction_STRD_A1_0e500ff0_000000f0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x001000b0:
    // LDRH<c> <Rt>, [<Rn>],+/-<Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '0', 'W#1', '1', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '0', '1', '1', 'Rm#4']
    return Instruction_LDRH_A1_0e500ff0_001000b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x001000d0:
    // LDRSB<c> <Rt>, [<Rn>],+/-<Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '0', 'W#1', '1', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '1', '0', '1', 'Rm#4']
    return Instruction_LDRSB_A1_0e500ff0_001000d0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x001000f0:
    // LDRSH<c> <Rt>, [<Rn>],+/-<Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '0', 'W#1', '1', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '1', '1', '1', 'Rm#4']
    return Instruction_LDRSH_A1_0e500ff0_001000f0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfe800d50)
  {
  case 0xf2800800:
    // V<op>L<c>.<dt> <Qd>, <Dn>, <Dm> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', 'op#1', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_V_A2_fe800d50_f2800800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800c00:
    // VMULL<c>.<dt> <Qd>, <Dn>, <Dm> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '1', 'op#1', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VMULL_A2_fe800d50_f2800c00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfe800e90) == 0xf2800e10)
    // VCVT<c>.<Td>.<Tm> <Dd>, <Dm>, #<fbits> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'imm#6', 'Vd#4', '1', '1', '1', 'op#1', '0', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VCVT_A1_fe800e90_f2800e10(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0x0fb80e50) == 0x0eb80a40)
    // VCVT<c>.F32.<Tm> <Sd>, <Sm> - ['support it block', 'support it block', 'support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', '1', 'opc2#3', 'Vd#4', '1', '0', '1', 'sz#1', 'op#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VCVT_A1_0fb80e50_0eb80a40(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xfe800b50) == 0xf2800240)
    // V<op>L<c>.<dt> <Qd>, <Dn>, <Dm[x]> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', 'op#1', '1', '0', 'N#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_V_A2_fe800b50_f2800240(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfe800e50)
  {
  case 0xf2800840:
    // VMUL<c>.<dt> <Dd>, <Dn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'Q#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', 'F#1', 'N#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VMUL_A1_fe800e50_f2800840(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800000:
    // VADDW<c>.<dt> <Qd>, <Qn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '0', 'op#1', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VADDW_A1_fe800e50_f2800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800200:
    // VSUBW<c>.<dt> {<Qd>,} <Qn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '1', 'op#1', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VSUBW_A1_fe800e50_f2800200(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fff0000)
  {
  case 0x024f0000:
    // SUB <Rd>, PC, #0 - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '0', '1', '0', '0', '1', '1', '1', '1', 'Rd#4', 'imm#12']
    return Instruction_SUB_A2_0fff0000_024f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x028f0000:
    // ADR<c> <Rd>, <arm_expand_label> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '1', '0', '0', '0', '1', '1', '1', '1', 'Rd#4', 'imm#12']
    return Instruction_ADR_A1_0fff0000_028f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x08bd0000:
    // POP<c> <registers> - ['could_ret'] - ['cond#4', '1', '0', '0', '0', '1', '0', '1', '1', '1', '1', '0', '1', 'register_list#16']
    return Instruction_POP_A1_0fff0000_08bd0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x092d0000:
    // PUSH<c> <registers> - [] - ['cond#4', '1', '0', '0', '1', '0', '0', '1', '0', '1', '1', '0', '1', 'register_list#16']
    return Instruction_PUSH_A1_0fff0000_092d0000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffb00010) == 0xf2b00000)
    // VEXT<c>.8 <Dd>, <Dn>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '1', 'D#1', '1', '1', 'Vn#4', 'Vd#4', 'imm#4', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VEXT_A1_ffb00010_f2b00000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0ff000f0)
  {
  case 0x00400090:
    // UMAAL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '1', '0', '0', 'RdHi#4', 'RdLo#4', 'Rm#4', '1', '0', '0', '1', 'Rn#4']
    return Instruction_UMAAL_A1_0ff000f0_00400090(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00600090:
    // MLS<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '1', '1', '0', 'Rd#4', 'Ra#4', 'Rm#4', '1', '0', '0', '1', 'Rn#4']
    return Instruction_MLS_A1_0ff000f0_00600090(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01200070:
    // BKPT #<imm> - [] - ['cond#4', '0', '0', '0', '1', '0', '0', '1', '0', 'imm#12', '0', '1', '1', '1', 'imm#4']
    return Instruction_BKPT_A1_0ff000f0_01200070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x07800010:
    // USADA8<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '1', '0', '0', '0', 'Rd#4', 'Ra#4', 'Rm#4', '0', '0', '0', '1', 'Rn#4']
    return Instruction_USADA8_A1_0ff000f0_07800010(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfe800d10) == 0xf2000000)
    // VH<op><c> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', 'op#1', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VH_A1_fe800d10_f2000000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xfe800a50) == 0xf2800040)
    // V<op><c>.<dt> <Dd>, <Dn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'Q#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', 'op#1', '0', 'F#1', 'N#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_V_A1_fe800a50_f2800040(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xfe800e10) == 0xf2800610)
    // VQSHL{op}<c>.<type><size> <Dd>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '1', '1', 'op#1', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VQSHL_A1_fe800e10_f2800610(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfff00000)
  {
  case 0xfc400000:
    // MCRR2<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '1', '0', '0', '0', '1', '0', '0', 'Rt2#4', 'Rt#4', 'coproc#4', 'opc1#4', 'CRm#4']
    return Instruction_MCRR2_A2_fff00000_fc400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfc500000:
    // MRRC2<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '1', '0', '0', '0', '1', '0', '1', 'Rt2#4', 'Rt#4', 'coproc#4', 'opc1#4', 'CRm#4']
    return Instruction_MRRC2_A2_fff00000_fc500000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfe800f00)
  {
  case 0xf2000600:
    // V<op><c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '0', 'N#1', 'Q#1', 'M#1', 'op#1', 'Vm#4']
    return Instruction_V_A1_fe800f00_f2000600(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000a00:
    // VP<op><c>.<dt> <Dd>, <Dn>, <Dm> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '0', 'N#1', 'Q#1', 'M#1', 'op#1', 'Vm#4']
    return Instruction_VP_A1_fe800f00_f2000a00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fef0010)
  {
  case 0x004d0000:
    // SUB{S}<c> <Rd>, SP, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '1', '0', 'S#1', '1', '1', '0', '1', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_SUB_A1_0fef0010_004d0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x008d0000:
    // ADD{S}<c> <Rd>, SP, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '0', '0', 'S#1', '1', '1', '0', '1', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_ADD_A1_0fef0010_008d0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01e00000:
    // MVN{S}<c> <Rd>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '1', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_MVN_A1_0fef0010_01e00000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fb00e50)
  {
  case 0x0e200a00:
    // VMUL<c>.F32 <Sd>, <Sn>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '0', 'D#1', '1', '0', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VMUL_A2_0fb00e50_0e200a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0e200a40:
    // VNMUL<c>.F32 <Sd>, <Sn>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '0', 'D#1', '1', '0', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VNMUL_A2_0fb00e50_0e200a40(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0e300a00:
    // VADD<c>.F32 <Sd>, <Sn>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '0', 'D#1', '1', '1', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VADD_A2_0fb00e50_0e300a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0e300a40:
    // VSUB<c>.F32 <Sd>, <Sn>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '0', 'D#1', '1', '1', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VSUB_A2_0fb00e50_0e300a40(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0e800a00:
    // VDIV<c>.F32 <Sd>, <Sn>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '0', '0', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VDIV_A1_0fb00e50_0e800a00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfe1f0000) == 0xfc1f0000)
    // LDC2{L}<c> <coproc>, <CRd>, [PC],<option> - ['support it block', 'support it block'] - ['1', '1', '1', '1', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', '1', '1', '1', '1', 'CRd#4', 'coproc#4', 'imm#8']
    return Instruction_LDC2_A2_fe1f0000_fc1f0000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0ff0f000)
  {
  case 0x03100000:
    // TST<c> <Rn>, #<arm_expand_imm_c> - [] - ['cond#4', '0', '0', '1', '1', '0', '0', '0', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'imm#12']
    return Instruction_TST_A1_0ff0f000_03100000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x03300000:
    // TEQ<c> <Rn>, #<arm_expand_imm_c> - [] - ['cond#4', '0', '0', '1', '1', '0', '0', '1', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'imm#12']
    return Instruction_TEQ_A1_0ff0f000_03300000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x03500000:
    // CMP<c> <Rn>, #<arm_expand_imm> - ['cond'] - ['cond#4', '0', '0', '1', '1', '0', '1', '0', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'imm#12']
    return Instruction_CMP_A1_0ff0f000_03500000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x03700000:
    // CMN<c> <Rn>, #<arm_expand_imm> - ['cond'] - ['cond#4', '0', '0', '1', '1', '0', '1', '1', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'imm#12']
    return Instruction_CMN_A1_0ff0f000_03700000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffb00000)
  {
  case 0xf4000000:
    // VST1<c>.<size> <list>, [<Rn>{@<align>}], <Rm> - ['support it block', 'support it block'] - ['1', '1', '1', '1', '0', '1', '0', '0', '0', 'D#1', '0', '0', 'Rn#4', 'Vd#4', 'type#4', 'size#2', 'align#2', 'Rm#4']
    return Instruction_VST1_A1_ffb00000_f4000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf4200000:
    // VLD1<c>.<size> <list>, [<Rn>{@<align>}], <Rm> - ['support it block', 'support it block'] - ['1', '1', '1', '1', '0', '1', '0', '0', '0', 'D#1', '1', '0', 'Rn#4', 'Vd#4', 'type#4', 'size#2', 'align#2', 'Rm#4']
    return Instruction_VLD1_A1_ffb00000_f4200000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0ff000d0)
  {
  case 0x07000010:
    // SMLAD{X}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '0', '0', '0', '0', 'Rd#4', 'Ra#4', 'Rm#4', '0', '0', 'M#1', '1', 'Rn#4']
    return Instruction_SMLAD_A1_0ff000d0_07000010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x07000050:
    // SMLSD{X}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '0', '0', '0', '0', 'Rd#4', 'Ra#4', 'Rm#4', '0', '1', 'M#1', '1', 'Rn#4']
    return Instruction_SMLSD_A1_0ff000d0_07000050(rBinStrm, Offset, Opcode32, rInsn);
  case 0x07400010:
    // SMLALD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '0', '1', '0', '0', 'RdHi#4', 'RdLo#4', 'Rm#4', '0', '0', 'M#1', '1', 'Rn#4']
    return Instruction_SMLALD_A1_0ff000d0_07400010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x07400050:
    // SMLSLD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '0', '1', '0', '0', 'RdHi#4', 'RdLo#4', 'Rm#4', '0', '1', 'M#1', '1', 'Rn#4']
    return Instruction_SMLSLD_A1_0ff000d0_07400050(rBinStrm, Offset, Opcode32, rInsn);
  case 0x07500010:
    // SMMLA{R}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '0', '1', '0', '1', 'Rd#4', 'Ra#4', 'Rm#4', '0', '0', 'R#1', '1', 'Rn#4']
    return Instruction_SMMLA_A1_0ff000d0_07500010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x075000d0:
    // SMMLS{R}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '0', '1', '0', '1', 'Rd#4', 'Ra#4', 'Rm#4', '1', '1', 'R#1', '1', 'Rn#4']
    return Instruction_SMMLS_A1_0ff000d0_075000d0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0ff000b0)
  {
  case 0x01200080:
    // SMLAW<y><c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '0', '1', '0', 'Rd#4', 'Ra#4', 'Rm#4', '1', 'M#1', '0', '0', 'Rn#4']
    return Instruction_SMLAW_A1_0ff000b0_01200080(rBinStrm, Offset, Opcode32, rInsn);
  case 0x012000a0:
    // SMULW<y><c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '0', '1', '0', 'Rd#4', 'SBZ#4', 'Rm#4', '1', 'M#1', '1', '0', 'Rn#4']
    return Instruction_SMULW_A1_0ff000b0_012000a0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fe000f0)
  {
  case 0x00200090:
    // MLA{S}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '0', '1', 'S#1', 'Rd#4', 'Ra#4', 'Rm#4', '1', '0', '0', '1', 'Rn#4']
    return Instruction_MLA_A1_0fe000f0_00200090(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00800090:
    // UMULL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '0', '0', 'S#1', 'RdHi#4', 'RdLo#4', 'Rm#4', '1', '0', '0', '1', 'Rn#4']
    return Instruction_UMULL_A1_0fe000f0_00800090(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00a00090:
    // UMLAL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '0', '1', 'S#1', 'RdHi#4', 'RdLo#4', 'Rm#4', '1', '0', '0', '1', 'Rn#4']
    return Instruction_UMLAL_A1_0fe000f0_00a00090(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00c00090:
    // SMULL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '1', '0', 'S#1', 'RdHi#4', 'RdLo#4', 'Rm#4', '1', '0', '0', '1', 'Rn#4']
    return Instruction_SMULL_A1_0fe000f0_00c00090(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00e00090:
    // SMLAL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '1', '1', 'S#1', 'RdHi#4', 'RdLo#4', 'Rm#4', '1', '0', '0', '1', 'Rn#4']
    return Instruction_SMLAL_A1_0fe000f0_00e00090(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fef0000)
  {
  case 0x024d0000:
    // SUB{S}<c> <Rd>, SP, #<arm_expand_imm> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '0', '1', '0', 'S#1', '1', '1', '0', '1', 'Rd#4', 'imm#12']
    return Instruction_SUB_A1_0fef0000_024d0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x028d0000:
    // ADD{S}<c> <Rd>, SP, #<arm_expand_imm> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '1', '0', '0', 'S#1', '1', '1', '0', '1', 'Rd#4', 'imm#12']
    return Instruction_ADD_A1_0fef0000_028d0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x03a00000:
    // MOV{S}<c> <Rd>, #<arm_expand_imm_c> - ['could_jmp'] - ['cond#4', '0', '0', '1', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'imm#12']
    return Instruction_MOV_A1_0fef0000_03a00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x03e00000:
    // MVN{S}<c> <Rd>, #<arm_expand_imm_c> - ['could_jmp'] - ['cond#4', '0', '0', '1', '1', '1', '1', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'imm#12']
    return Instruction_MVN_A1_0fef0000_03e00000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0f7000f0)
  {
  case 0x006000b0:
    // STRHT<c> <Rt>, [<Rn>] {,#<disp>} - [] - ['cond#4', '0', '0', '0', '0', 'U#1', '1', '1', '0', 'Rn#4', 'Rt#4', 'imm_h#4', '1', '0', '1', '1', 'imm_l#4']
    return Instruction_STRHT_A1_0f7000f0_006000b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x007000b0:
    // LDRHT<c> <Rt>, [<Rn>] {,#<disp>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', 'U#1', '1', '1', '1', 'Rn#4', 'Rt#4', 'imm_h#4', '1', '0', '1', '1', 'imm_l#4']
    return Instruction_LDRHT_A1_0f7000f0_007000b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x007000d0:
    // LDRSBT<c> <Rt>, [<Rn>] {,#<disp>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', 'U#1', '1', '1', '1', 'Rn#4', 'Rt#4', 'imm_h#4', '1', '1', '0', '1', 'imm_l#4']
    return Instruction_LDRSBT_A1_0f7000f0_007000d0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x007000f0:
    // LDRSHT<c> <Rt>, [<Rn>] {,#<disp>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', 'U#1', '1', '1', '1', 'Rn#4', 'Rt#4', 'imm_h#4', '1', '1', '1', '1', 'imm_l#4']
    return Instruction_LDRSHT_A1_0f7000f0_007000f0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fb00e10)
  {
  case 0x0e000a00:
    // V<op><c>.F32 <Sd>, <Sn>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '0', 'D#1', '0', '0', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', 'op#1', 'M#1', '0', 'Vm#4']
    return Instruction_V_A2_0fb00e10_0e000a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0e100a00:
    // VNMLS<c>.F32 <Sd>, <Sn>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '0', 'D#1', '0', '1', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', 'op#1', 'M#1', '0', 'Vm#4']
    return Instruction_VNMLS_A1_0fb00e10_0e100a00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0f7f0000)
  {
  case 0x051f0000:
    // LDR<c> <Rt>, <u_label> - ['could_jmp'] - ['cond#4', '0', '1', '0', '(1)', 'U#1', '0', '(0)', '1', '1', '1', '1', '1', 'Rt#4', 'imm#12']
    return Instruction_LDR_A1_0f7f0000_051f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x055f0000:
    // LDRB<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['cond#4', '0', '1', '0', '(1)', 'U#1', '1', '(0)', '1', '1', '1', '1', '1', 'Rt#4', 'imm#12']
    return Instruction_LDRB_A1_0f7f0000_055f0000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0ff00030) == 0x06800010)
    // PKHTB<c> <Rd>, <Rn>, <Rm>{,ASR #<imm>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '0', '0', 'Rn#4', 'Rd#4', 'imm#5', 'tb#1', '0', '1', 'Rm#4']
    return Instruction_PKHTB_A1_0ff00030_06800010(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0f300f00)
  {
  case 0x0d000a00:
    // VSTR<c> <Sd>, [<Rn>{,#+/-<imm>}] - [] - ['cond#4', '1', '1', '0', '1', 'U#1', 'D#1', '0', '0', 'Rn#4', 'Vd#4', '1', '0', '1', '0', 'imm#8']
    return Instruction_VSTR_A2_0f300f00_0d000a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0d000b00:
    // VSTR<c> <Dd>, [<Rn>{,#+/-<imm>}] - [] - ['cond#4', '1', '1', '0', '1', 'U#1', 'D#1', '0', '0', 'Rn#4', 'Vd#4', '1', '0', '1', '1', 'imm#8']
    return Instruction_VSTR_A1_0f300f00_0d000b00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0d100a00:
    // VLDR<c> <Sd>, [PC,#-0] - ['support it block', 'support it block'] - ['cond#4', '1', '1', '0', '1', 'U#1', 'D#1', '0', '1', 'Rn#4', 'Vd#4', '1', '0', '1', '0', 'imm#8']
    return Instruction_VLDR_A2_0f300f00_0d100a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0d100b00:
    // VLDR<c> <Dd>, [PC,#-0] - ['support it block', 'support it block'] - ['cond#4', '1', '1', '0', '1', 'U#1', 'D#1', '0', '1', 'Rn#4', 'Vd#4', '1', '0', '1', '1', 'imm#8']
    return Instruction_VLDR_A1_0f300f00_0d100b00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fe00070)
  {
  case 0x07a00050:
    // SBFX<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '1', '0', '1', 'widthm1#5', 'Rd#4', 'lsb#5', '1', '0', '1', 'Rn#4']
    return Instruction_SBFX_A1_0fe00070_07a00050(rBinStrm, Offset, Opcode32, rInsn);
  case 0x07c00010:
    // BFI<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '1', '1', '0', 'msb#5', 'Rd#4', 'lsb#5', '0', '0', '1', 'Rn#4']
    return Instruction_BFI_A1_0fe00070_07c00010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x07e00050:
    // UBFX<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '1', '1', '1', 'widthm1#5', 'Rd#4', 'lsb#5', '1', '0', '1', 'Rn#4']
    return Instruction_UBFX_A1_0fe00070_07e00050(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0ff00090)
  {
  case 0x01000080:
    // SMLA<x><y><c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '0', '0', '0', 'Rd#4', 'Ra#4', 'Rm#4', '1', 'M#1', 'N#1', '0', 'Rn#4']
    return Instruction_SMLA_A1_0ff00090_01000080(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01400080:
    // SMLAL<x><y><c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '1', '0', '0', 'RdHi#4', 'RdLo#4', 'Rm#4', '1', 'M#1', 'N#1', '0', 'Rn#4']
    return Instruction_SMLAL_A1_0ff00090_01400080(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01600080:
    // SMUL<x><y><c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '1', '1', '0', 'Rd#4', 'SBZ#4', 'Rm#4', '1', 'M#1', 'N#1', '0', 'Rn#4']
    return Instruction_SMUL_A1_0ff00090_01600080(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xff100010)
  {
  case 0xfe000010:
    // MCR2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '1', '1', '0', 'opc1#3', '0', 'CRn#4', 'Rt#4', 'coproc#4', 'opc2#3', '1', 'CRm#4']
    return Instruction_MCR2_A2_ff100010_fe000010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfe100010:
    // MRC2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '1', '1', '0', 'opc1#3', '1', 'CRn#4', 'Rt#4', 'coproc#4', 'opc2#3', '1', 'CRm#4']
    return Instruction_MRC2_A2_ff100010_fe100010(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fe00090)
  {
  case 0x00000010:
    // AND{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '0', '0', 'S#1', 'Rn#4', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
    return Instruction_AND_A1_0fe00090_00000010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00200010:
    // EOR{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '0', '1', 'S#1', 'Rn#4', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
    return Instruction_EOR_A1_0fe00090_00200010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00400010:
    // SUB{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '1', '0', 'S#1', 'Rn#4', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
    return Instruction_SUB_A1_0fe00090_00400010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00600010:
    // RSB{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '1', '1', 'S#1', 'Rn#4', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
    return Instruction_RSB_A1_0fe00090_00600010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00800010:
    // ADD{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '0', '0', 'S#1', 'Rn#4', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
    return Instruction_ADD_A1_0fe00090_00800010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00a00010:
    // ADC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '0', '1', 'S#1', 'Rn#4', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
    return Instruction_ADC_A1_0fe00090_00a00010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00c00010:
    // SBC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '1', '0', 'S#1', 'Rn#4', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
    return Instruction_SBC_A1_0fe00090_00c00010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00e00010:
    // RSC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '1', '1', 'S#1', 'Rn#4', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
    return Instruction_RSC_A1_0fe00090_00e00010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01800010:
    // ORR{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '0', 'S#1', 'Rn#4', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
    return Instruction_ORR_A1_0fe00090_01800010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01c00010:
    // BIC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '1', '0', 'S#1', 'Rn#4', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
    return Instruction_BIC_A1_0fe00090_01c00010(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0e5000f0)
  {
  case 0x004000b0:
    // STRH<c> <Rt>, [<Rn>, #<disp>]! - [] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '1', 'W#1', '0', 'Rn#4', 'Rt#4', 'imm_h#4', '1', '0', '1', '1', 'imm_l#4']
    return Instruction_STRH_A1_0e5000f0_004000b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x004000d0:
    // LDRD<c> <Rt>, <Rt2>, [<Rn>, #<disp>]! - ['could_jmp'] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '1', 'W#1', '0', 'Rn#4', 'Rt#4', 'imm_h#4', '1', '1', '0', '1', 'imm_l#4']
    return Instruction_LDRD_A1_0e5000f0_004000d0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x004000f0:
    // STRD<c> <Rt>, <Rt2>, [<Rn>, #<disp>]! - [] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '1', 'W#1', '0', 'Rn#4', 'Rt#4', 'imm_h#4', '1', '1', '1', '1', 'imm_l#4']
    return Instruction_STRD_A1_0e5000f0_004000f0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x005000b0:
    // LDRH<c> <Rt>, [<Rn>, #<disp>]! - ['could_jmp'] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '1', 'W#1', '1', 'Rn#4', 'Rt#4', 'imm_h#4', '1', '0', '1', '1', 'imm_l#4']
    return Instruction_LDRH_A1_0e5000f0_005000b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x005000d0:
    // LDRSB<c> <Rt>, [<Rn>, #<disp>]! - ['could_jmp'] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '1', 'W#1', '1', 'Rn#4', 'Rt#4', 'imm_h#4', '1', '1', '0', '1', 'imm_l#4']
    return Instruction_LDRSB_A1_0e5000f0_005000d0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x005000f0:
    // LDRSH<c> <Rt>, [<Rn>, #<disp>]! - ['could_jmp'] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '1', 'W#1', '1', 'Rn#4', 'Rt#4', 'imm_h#4', '1', '1', '1', '1', 'imm_l#4']
    return Instruction_LDRSH_A1_0e5000f0_005000f0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fe00030)
  {
  case 0x06a00010:
    // SSAT<c> <Rd>, #<imm>, <Rn>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '1', 'sat_imm#5', 'Rd#4', 'imm#5', 'sh#1', '0', '1', 'Rn#4']
    return Instruction_SSAT_A1_0fe00030_06a00010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06e00010:
    // USAT<c> <Rd>, #<imm5>, <Rn>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '1', '1', 'sat_imm#5', 'Rd#4', 'imm#5', 'sh#1', '0', '1', 'Rn#4']
    return Instruction_USAT_A1_0fe00030_06e00010(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xff000010) == 0xfe000000)
    // CDP2<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '0', 'opc1#4', 'CRn#4', 'CRd#4', 'coproc#4', 'opc2#3', '0', 'CRm#4']
    return Instruction_CDP2_A2_ff000010_fe000000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0x0e1f0000) == 0x0c1f0000)
    // LDC{L}<c> <coproc>, <CRd>, [PC],<option> - ['support it block', 'support it block'] - ['cond#4', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', '1', '1', '1', '1', 'CRd#4', 'coproc#4', 'imm#8']
    return Instruction_LDC_A1_0e1f0000_0c1f0000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0ff00000)
  {
  case 0x03000000:
    // MOVW<c> <Rd>, #<imm> - ['could_jmp'] - ['cond#4', '0', '0', '1', '1', '0', '0', '0', '0', 'imm#4', 'Rd#4', 'imm#12']
    return Instruction_MOVW_A2_0ff00000_03000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x03400000:
    // MOVT<c> <Rd>, #<imm> - ['could_jmp'] - ['cond#4', '0', '0', '1', '1', '0', '1', '0', '0', 'imm#4', 'Rd#4', 'imm#12']
    return Instruction_MOVT_A1_0ff00000_03400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0c400000:
    // MCRR<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm> - ['could_jmp'] - ['cond#4', '1', '1', '0', '0', '0', '1', '0', '0', 'Rt2#4', 'Rt#4', 'coproc#4', 'opc1#4', 'CRm#4']
    return Instruction_MCRR_A1_0ff00000_0c400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0c500000:
    // MRRC<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm> - ['could_jmp'] - ['cond#4', '1', '1', '0', '0', '0', '1', '0', '1', 'Rt2#4', 'Rt#4', 'coproc#4', 'opc1#4', 'CRm#4']
    return Instruction_MRRC_A1_0ff00000_0c500000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0e100f00)
  {
  case 0x0c000a00:
    // FSTMX - ['support it block'] - ['cond#4', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '0', 'Rn#4', 'Vd#4', '1', '0', '1', '0', 'imm#8']
    return Instruction_FSTMX_A2_0e100f00_0c000a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0c000b00:
    // VSTM{mode}<c> <Rn>{!},  <list> - [] - ['cond#4', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '0', 'Rn#4', 'Vd#4', '1', '0', '1', '1', 'imm#8']
    return Instruction_VSTM_A1_0e100f00_0c000b00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0c100a00:
    // FLDMX - ['support it block'] - ['cond#4', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', 'Rn#4', 'Vd#4', '1', '0', '1', '0', 'imm#8']
    return Instruction_FLDMX_A2_0e100f00_0c100a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0c100b00:
    // VLDM{mode}<c> <Rn>{!},  <list> - [] - ['cond#4', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', 'Rn#4', 'Vd#4', '1', '0', '1', '1', 'imm#8']
    return Instruction_VLDM_A1_0e100f00_0c100b00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfe100000)
  {
  case 0xfc000000:
    // STC2{L}<c> <coproc>, <CRd>, [<Rn>],<option> - ['support it block', 'support it block'] - ['1', '1', '1', '1', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '0', 'Rn#4', 'CRd#4', 'coproc#4', 'imm#8']
    return Instruction_STC2_A2_fe100000_fc000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfc100000:
    // LDC2{L}<c> <coproc>, <CRd>, [<Rn>],<option> - ['support it block', 'support it block'] - ['1', '1', '1', '1', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', 'Rn#4', 'CRd#4', 'coproc#4', 'imm#8']
    return Instruction_LDC2_A2_fe100000_fc100000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0f700010)
  {
  case 0x06200000:
    // STRT<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!} - [] - ['cond#4', '0', '1', '1', '0', 'W#1', '0', '1', '0', 'Rn#4', 'Rt#4', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_STRT_A2_0f700010_06200000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06300000:
    // LDRT<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', 'W#1', '0', '1', '1', 'Rn#4', 'Rt#4', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_LDRT_A2_0f700010_06300000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06600000:
    // STRBT<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!} - [] - ['cond#4', '0', '1', '1', '0', 'W#1', '1', '1', '0', 'Rn#4', 'Rt#4', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_STRBT_A2_0f700010_06600000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06700000:
    // LDRBT<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', 'W#1', '1', '1', '1', 'Rn#4', 'Rt#4', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_LDRBT_A2_0f700010_06700000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fe00010)
  {
  case 0x00000000:
    // AND{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '0', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_AND_A1_0fe00010_00000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00200000:
    // EOR{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '0', '1', 'S#1', 'Rn#4', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_EOR_A1_0fe00010_00200000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00400000:
    // SUB{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '1', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_SUB_A1_0fe00010_00400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00600000:
    // RSB{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '1', '1', 'S#1', 'Rn#4', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_RSB_A1_0fe00010_00600000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00800000:
    // ADD{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '0', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_ADD_A1_0fe00010_00800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00a00000:
    // ADC{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '0', '1', 'S#1', 'Rn#4', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_ADC_A1_0fe00010_00a00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00c00000:
    // SBC{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '1', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_SBC_A1_0fe00010_00c00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00e00000:
    // RSC{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '1', '1', 'S#1', 'Rn#4', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_RSC_A1_0fe00010_00e00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01800000:
    // ORR{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_ORR_A1_0fe00010_01800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01c00000:
    // BIC{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '1', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_BIC_A1_0fe00010_01c00000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0f700000)
  {
  case 0x04300000:
    // LDRT<c> <Rt>, [<Rn>] {,#<disp>} - ['could_jmp'] - ['cond#4', '0', '1', '0', '0', 'U#1', '0', '1', '1', 'Rn#4', 'Rt#4', 'imm#12']
    return Instruction_LDRT_A1_0f700000_04300000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x04600000:
    // STRBT<c> <Rt>, [<Rn>], #<imm> - [] - ['cond#4', '0', '1', '0', '0', 'U#1', '1', '1', '0', 'Rn#4', 'Rt#4', 'imm#12']
    return Instruction_STRBT_A1_0f700000_04600000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x04700000:
    // LDRBT<c> <Rt>, [<Rn>], #<imm> - ['could_jmp'] - ['cond#4', '0', '1', '0', '0', 'U#1', '1', '1', '1', 'Rn#4', 'Rt#4', 'imm#12']
    return Instruction_LDRBT_A1_0f700000_04700000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x04200000:
    // STRT<c> <Rt>, [<Rn>] {, #<imm>} - [] - ['cond#4', '0', '1', '0', '0', 'W#1', '0', '1', '0', 'Rn#4', 'Rt#4', 'imm#12']
    return Instruction_STRT_A1_0f700000_04200000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fd00000)
  {
  case 0x08000000:
    // STMDA<c> <Rn>{!}, <registers> - [] - ['cond#4', '1', '0', '0', '0', '0', '0', 'W#1', '0', 'Rn#4', 'register_list#16']
    return Instruction_STMDA_A1_0fd00000_08000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x08100000:
    // LDMDA<c> <Rn>{!}, <registers> - ['could_jmp'] - ['cond#4', '1', '0', '0', '0', '0', '0', 'W#1', '1', 'Rn#4', 'register_list#16']
    return Instruction_LDMDA_A1_0fd00000_08100000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x08800000:
    // STM<c> <Rn>{!}, <registers> - [] - ['cond#4', '1', '0', '0', '0', '1', '0', 'W#1', '0', 'Rn#4', 'register_list#16']
    return Instruction_STM_A1_0fd00000_08800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x08900000:
    // LDM<c> <Rn>{!}, <registers> - ['could_jmp'] - ['cond#4', '1', '0', '0', '0', '1', '0', 'W#1', '1', 'Rn#4', 'register_list#16']
    return Instruction_LDM_A1_0fd00000_08900000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x09000000:
    // STMDB<c> <Rn>{!}, <registers> - [] - ['cond#4', '1', '0', '0', '1', '0', '0', 'W#1', '0', 'Rn#4', 'register_list#16']
    return Instruction_STMDB_A1_0fd00000_09000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x09100000:
    // LDMDB<c> <Rn>{!}, <registers> - ['could_jmp'] - ['cond#4', '1', '0', '0', '1', '0', '0', 'W#1', '1', 'Rn#4', 'register_list#16']
    return Instruction_LDMDB_A1_0fd00000_09100000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x09800000:
    // STMIB<c> <Rn>{!}, <registers> - [] - ['cond#4', '1', '0', '0', '1', '1', '0', 'W#1', '0', 'Rn#4', 'register_list#16']
    return Instruction_STMIB_A1_0fd00000_09800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x09900000:
    // LDMIB<c> <Rn>{!}, <registers> - ['could_jmp'] - ['cond#4', '1', '0', '0', '1', '1', '0', 'W#1', '1', 'Rn#4', 'register_list#16']
    return Instruction_LDMIB_A1_0fd00000_09900000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fe00000)
  {
  case 0x02000000:
    // AND{S}<c> <Rd>, <Rn>, #<arm_expand_imm_c> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '0', '0', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#12']
    return Instruction_AND_A1_0fe00000_02000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x02200000:
    // EOR{S}<c> <Rd>, <Rn>, #<arm_expand_imm_c> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '0', '0', '1', 'S#1', 'Rn#4', 'Rd#4', 'imm#12']
    return Instruction_EOR_A1_0fe00000_02200000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x02400000:
    // SUB{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '0', '1', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#12']
    return Instruction_SUB_A1_0fe00000_02400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x02600000:
    // RSB{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '0', '1', '1', 'S#1', 'Rn#4', 'Rd#4', 'imm#12']
    return Instruction_RSB_A1_0fe00000_02600000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x02800000:
    // ADD{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '1', '0', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#12']
    return Instruction_ADD_A1_0fe00000_02800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x02a00000:
    // ADC{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '1', '0', '1', 'S#1', 'Rn#4', 'Rd#4', 'imm#12']
    return Instruction_ADC_A1_0fe00000_02a00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x02c00000:
    // SBC{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '1', '1', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#12']
    return Instruction_SBC_A1_0fe00000_02c00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x02e00000:
    // RSC{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '1', '1', '1', 'S#1', 'Rn#4', 'Rd#4', 'imm#12']
    return Instruction_RSC_A1_0fe00000_02e00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x03800000:
    // ORR{S}<c> <Rd>, <Rn>, #<arm_expand_imm_c> - ['could_jmp'] - ['cond#4', '0', '0', '1', '1', '1', '0', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#12']
    return Instruction_ORR_A1_0fe00000_03800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x03c00000:
    // BIC{S}<c> <Rd>, <Rn>, #<arm_expand_imm_c> - ['could_jmp'] - ['cond#4', '0', '0', '1', '1', '1', '1', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#12']
    return Instruction_BIC_A1_0fe00000_03c00000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfe000000) == 0xfa000000)
    // BLX <arm_branch_label> - ['call'] - ['1', '1', '1', '1', '1', '0', '1', 'H#1', 'imm#24']
    return Instruction_BLX_A2_fe000000_fa000000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0e500010)
  {
  case 0x06000000:
    // STR<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!} - [] - ['cond#4', '0', '1', '1', 'P#1', 'U#1', '0', 'W#1', '0', 'Rn#4', 'Rt#4', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_STR_A1_0e500010_06000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06100000:
    // LDR<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!} - ['could_jmp'] - ['cond#4', '0', '1', '1', 'P#1', 'U#1', '0', 'W#1', '1', 'Rn#4', 'Rt#4', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_LDR_A1_0e500010_06100000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06400000:
    // STRB<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!} - [] - ['cond#4', '0', '1', '1', 'P#1', 'U#1', '1', 'W#1', '0', 'Rn#4', 'Rt#4', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_STRB_A1_0e500010_06400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06500000:
    // LDRB<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!} - ['could_jmp'] - ['cond#4', '0', '1', '1', 'P#1', 'U#1', '1', 'W#1', '1', 'Rn#4', 'Rt#4', 'imm#5', 'type#2', '0', 'Rm#4']
    return Instruction_LDRB_A1_0e500010_06500000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0f100010)
  {
  case 0x0e000010:
    // MCR<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - [] - ['cond#4', '1', '1', '1', '0', 'opc1#3', '0', 'CRn#4', 'Rt#4', 'coproc#4', 'opc2#3', '1', 'CRm#4']
    return Instruction_MCR_A1_0f100010_0e000010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0e100010:
    // MRC<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['could_jmp'] - ['cond#4', '1', '1', '1', '0', 'opc1#3', '1', 'CRn#4', 'Rt#4', 'coproc#4', 'opc2#3', '1', 'CRm#4']
    return Instruction_MRC_A1_0f100010_0e100010(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0f000010) == 0x0e000000)
    // CDP<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2> - [] - ['cond#4', '1', '1', '1', '0', 'opc1#4', 'CRn#4', 'CRd#4', 'coproc#4', 'opc2#3', '0', 'CRm#4']
    return Instruction_CDP_A1_0f000010_0e000000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0e500000)
  {
  case 0x04000000:
    // STR<c> <Rt>, [<Rn>, #<disp>]! - [] - ['cond#4', '0', '1', '0', 'P#1', 'U#1', '0', 'W#1', '0', 'Rn#4', 'Rt#4', 'imm#12']
    return Instruction_STR_A1_0e500000_04000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x04100000:
    // LDR<c> <Rt>, [<Rn>, #<disp>]! - ['could_jmp'] - ['cond#4', '0', '1', '0', 'P#1', 'U#1', '0', 'W#1', '1', 'Rn#4', 'Rt#4', 'imm#12']
    return Instruction_LDR_A1_0e500000_04100000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x04400000:
    // STRB<c> <Rt>, [<Rn>, #<disp>]! - [] - ['cond#4', '0', '1', '0', 'P#1', 'U#1', '1', 'W#1', '0', 'Rn#4', 'Rt#4', 'imm#12']
    return Instruction_STRB_A1_0e500000_04400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x04500000:
    // LDRB<c> <Rt>, [<Rn>, #<disp>]! - ['could_jmp'] - ['cond#4', '0', '1', '0', 'P#1', 'U#1', '1', 'W#1', '1', 'Rn#4', 'Rt#4', 'imm#12']
    return Instruction_LDRB_A1_0e500000_04500000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0e100000)
  {
  case 0x0c000000:
    // STC{L}<c> <coproc>, <CRd>, [<Rn>],<option> - ['support it block', 'support it block'] - ['cond#4', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '0', 'Rn#4', 'CRd#4', 'coproc#4', 'imm#8']
    return Instruction_STC_A1_0e100000_0c000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0c100000:
    // LDC{L}<c> <coproc>, <CRd>, [<Rn>],<option> - ['support it block', 'support it block'] - ['cond#4', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', 'Rn#4', 'CRd#4', 'coproc#4', 'imm#8']
    return Instruction_LDC_A1_0e100000_0c100000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0f000000)
  {
  case 0x0a000000:
    // B<c> <arm_branch_label> - ['jmp'] - ['cond#4', '1', '0', '1', '0', 'imm#24']
    return Instruction_B_A1_0f000000_0a000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0b000000:
    // BL<c> <arm_branch_label> - ['call'] - ['cond#4', '1', '0', '1', '1', 'imm#24']
    return Instruction_BL_A1_0f000000_0b000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0f000000:
    // SVC<c> #<imm> - ['syscall'] - ['cond#4', '1', '1', '1', '1', 'imm#24']
    return Instruction_SVC_A1_0f000000_0f000000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  return false;
}
bool ArmArchitecture::DisassembleThumb(BinaryStream const& rBinStrm, OffsetType Offset, Instruction& rInsn)
{
  u16 Opcode16Low;
  if (!rBinStrm.Read(Offset & ~1, Opcode16Low))
    return false;

  u16 Opcode16High;
  if (!rBinStrm.Read((Offset + 2) & ~1, Opcode16High))
    return false;

  u16 Opcode16 = Opcode16Low;
  u32 Opcode32 = ((Opcode16Low << 16) | Opcode16High);
  switch (Opcode32 & 0xffffffff)
  {
  case 0xf3af8000:
    // NOP<c>.W - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '1', '0', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', '(0)', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
    return Instruction_NOP_T2_ffffffff_f3af8000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3af8001:
    // YIELD<c>.W - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '1', '0', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', '(0)', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1']
    return Instruction_YIELD_T2_ffffffff_f3af8001(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3af8002:
    // WFE<c>.W - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '1', '0', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', '(0)', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '0']
    return Instruction_WFE_T2_ffffffff_f3af8002(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3af8003:
    // WFI<c>.W - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '1', '0', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', '(0)', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '1']
    return Instruction_WFI_T2_ffffffff_f3af8003(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3af8004:
    // SEV<c>.W - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '1', '0', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', '(0)', '0', '0', '0', '0', '0', '0', '0', '0', '1', '0', '0']
    return Instruction_SEV_T2_ffffffff_f3af8004(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3bf8f2f:
    // CLREX<c> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '1', '1', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '0', '(1)', '(1)', '(1)', '(1)']
    return Instruction_CLREX_T1_ffffffff_f3bf8f2f(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfffffff0)
  {
  case 0xf3af80f0:
    // DBG<c> #<option> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '1', '0', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', '(0)', '0', '0', '0', '1', '1', '1', '1', 'option#4']
    return Instruction_DBG_T1_fffffff0_f3af80f0(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3bf8f40:
    // DSB<c> #<option> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '1', '1', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '0', 'option#4']
    return Instruction_DSB_T1_fffffff0_f3bf8f40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3bf8f50:
    // DMB<c> #<option> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '1', '1', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '1', 'option#4']
    return Instruction_DMB_T1_fffffff0_f3bf8f50(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3bf8f60:
    // ISB<c> #<option> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '1', '1', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', '(1)', '(1)', '(1)', '(1)', '0', '1', '1', '0', 'option#4']
    return Instruction_ISB_T1_fffffff0_f3bf8f60(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffff0fff)
  {
  case 0xeee10a10:
    // VMSR<c> FPSCR, <Rt> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '0', '0', '0', '0', '1', 'Rt#4', '1', '0', '1', '0', '0', '(0)', '(0)', '1', '(0)', '(0)', '(0)', '(0)']
    return Instruction_VMSR_T1_ffff0fff_eee10a10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeef10a10:
    // VMRS<c> <Rt>, FPSCR - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '1', '0', '0', '0', '1', 'Rt#4', '1', '0', '1', '0', '0', '(0)', '(0)', '1', '(0)', '(0)', '(0)', '(0)']
    return Instruction_VMRS_T1_ffff0fff_eef10a10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf84d0d04:
    // PUSH<c>.W <Rt> - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '1', '0', '0', '1', '1', '0', '1', 'Rt#4', '1', '1', '0', '1', '0', '0', '0', '0', '0', '1', '0', '0']
    return Instruction_PUSH_T3_ffff0fff_f84d0d04(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf85d0b04:
    // POP<c>.W <Rt> - ['could_ret'] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '1', '0', '1', '1', '1', '0', '1', 'Rt#4', '1', '0', '1', '1', '0', '0', '0', '0', '0', '1', '0', '0']
    return Instruction_POP_T3_ffff0fff_f85d0b04(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfffff0ff) == 0xf3ef8000)
    // MRS<c> <Rd>, <spec_reg> - ['could_jmp'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '1', '1', '0', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', 'Rd#4', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)']
    return Instruction_MRS_T1_fffff0ff_f3ef8000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xfff0ffff) == 0xf3c08f00)
    // BXJ<c> <Rm> - ['call', 'change_to_jazelle'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '1', '0', '0', 'Rm#4', '1', '0', '(0)', '0', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)']
    return Instruction_BXJ_T1_fff0ffff_f3c08f00(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xfff0f3ff) == 0xf3808000)
    // MSR<c> <spec_reg>, <Rn> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '0', '0', 'Rn#4', '1', '0', '(0)', '0', 'mask#2', '0', '0', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)']
    return Instruction_MSR_T1_fff0f3ff_f3808000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xffbf0e7f) == 0xeeb50a40)
    // VCMP{E}<c>.F64 <Dd>, #0.0 - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '1', '0', '1', 'Vd#4', '1', '0', '1', 'sz#1', 'E#1', '1', '(0)', '0', '(0)', '(0)', '(0)', '(0)']
    return Instruction_VCMP_T2_ffbf0e7f_eeb50a40(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfff00fff)
  {
  case 0xe8d00f4f:
    // LDREXB<c> <Rt>, [<Rn>] - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '1', '0', '1', 'Rn#4', 'Rt#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '0', '(1)', '(1)', '(1)', '(1)']
    return Instruction_LDREXB_T1_fff00fff_e8d00f4f(rBinStrm, Offset, Opcode32, rInsn);
  case 0xe8d00f5f:
    // LDREXH<c> <Rt>, [<Rn>] - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '1', '0', '1', 'Rn#4', 'Rt#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '1', '(1)', '(1)', '(1)', '(1)']
    return Instruction_LDREXH_T1_fff00fff_e8d00f5f(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfff0ffe0) == 0xe8d0f000)
    // TBH<c> [<Rn>, <Rm>,LSL #1] - ['jmp'] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '1', '0', '1', 'Rn#4', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '0', '0', 'H#1', 'Rm#4']
    return Instruction_TBH_T1_fff0ffe0_e8d0f000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffeff0f0)
  {
  case 0xea4f0000:
    // MOV{S}<c>.W <Rd>, <Rm> - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '1', '0', 'S#1', '1', '1', '1', '1', '(0)', '0', '0', '0', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
    return Instruction_MOV_T3_ffeff0f0_ea4f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xea4f0030:
    // RRX{S}<c> <Rd>, <Rm> - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '1', '0', 'S#1', '1', '1', '1', '1', '(0)', '0', '0', '0', 'Rd#4', '0', '0', '1', '1', 'Rm#4']
    return Instruction_RRX_T1_ffeff0f0_ea4f0030(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfff0ffc0) == 0xf910f000)
    // PLI<c> [<Rn>, <Rm>{,LSL #<imm>}] - [] - ['1', '1', '1', '1', '1', '0', '0', '1', '0', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', '0', '0', '0', '0', '0', '0', 'imm#2', 'Rm#4']
    return Instruction_PLI_T1_fff0ffc0_f910f000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfffff0c0)
  {
  case 0xfa0ff080:
    // SXTH<c>.W <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
    return Instruction_SXTH_T2_fffff0c0_fa0ff080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa1ff080:
    // UXTH<c>.W <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
    return Instruction_UXTH_T2_fffff0c0_fa1ff080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa2ff080:
    // SXTB16<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
    return Instruction_SXTB16_T1_fffff0c0_fa2ff080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa3ff080:
    // UXTB16<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
    return Instruction_UXTB16_T1_fffff0c0_fa3ff080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa4ff080:
    // SXTB<c>.W <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '1', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
    return Instruction_SXTB_T2_fffff0c0_fa4ff080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa5ff080:
    // UXTB<c>.W <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
    return Instruction_UXTB_T2_fffff0c0_fa5ff080(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffe00f7f) == 0xee000a10)
    // VMOV<c> <Sn>, <Rt> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '0', '0', '0', 'op#1', 'Vn#4', 'Rt#4', '1', '0', '1', '0', 'N#1', '(0)', '(0)', '1', '(0)', '(0)', '(0)', '(0)']
    return Instruction_VMOV_T1_ffe00f7f_ee000a10(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffbf0ed0)
  {
  case 0xeeb00a40:
    // VMOV<c>.F64 <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '0', '0', '0', 'Vd#4', '1', '0', '1', 'sz#1', '0', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VMOV_T2_ffbf0ed0_eeb00a40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeeb00ac0:
    // VABS<c>.F64 <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '0', '0', '0', 'Vd#4', '1', '0', '1', 'sz#1', '1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VABS_T2_ffbf0ed0_eeb00ac0(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeeb10a40:
    // VNEG<c>.F64 <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '0', '0', '1', 'Vd#4', '1', '0', '1', 'sz#1', '0', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VNEG_T2_ffbf0ed0_eeb10a40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeeb10ac0:
    // VSQRT<c>.F64 <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '0', '0', '1', 'Vd#4', '1', '0', '1', 'sz#1', '1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VSQRT_T1_ffbf0ed0_eeb10ac0(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeeb70ac0:
    // VCVT<c>.F64.F32 <Dd>, <Sm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '1', '1', '1', 'Vd#4', '1', '0', '1', 'sz#1', '1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VCVT_T1_ffbf0ed0_eeb70ac0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfff0ff00) == 0xf910fc00)
    // PLI<c> [<Rn>,#-<imm>] - [] - ['1', '1', '1', '1', '1', '0', '0', '1', '0', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', '1', '1', '0', '0', 'imm#8']
    return Instruction_PLI_T2_fff0ff00_f910fc00(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xffbe0f50) == 0xeeb20a40)
    // VCVT<y><c>.F32.F16 <Sd>, <Sm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '0', '1', 'op#1', 'Vd#4', '1', '0', '1', '0', 'T#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VCVT_T1_ffbe0f50_eeb20a40(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xffbf0e50) == 0xeeb40a40)
    // VCMP{E}<c>.F64 <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '1', '0', '0', 'Vd#4', '1', '0', '1', 'sz#1', 'E#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VCMP_T1_ffbf0e50_eeb40a40(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffb30fd0)
  {
  case 0xffb20200:
    // VMOVN<c>.<dt> <Dd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '1', '0', '0', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VMOVN_T1_ffb30fd0_ffb20200(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb20300:
    // VSHLL<c>.<type><size> <Qd>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '1', '1', '0', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VSHLL_T2_ffb30fd0_ffb20300(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xff900f5f) == 0xee800b10)
    // VDUP<c>.<size> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'b_size#1', 'Q#1', '0', 'Vd#4', 'Rt#4', '1', '0', '1', '1', 'D#1', '0', 'e_size#1', '1', '(0)', '(0)', '(0)', '(0)']
    return Instruction_VDUP_T1_ff900f5f_ee800b10(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfff0f0f0)
  {
  case 0xf3200000:
    // SSAT16<c> <Rd>, #<imm>, <Rn> - ['could_jmp'] - ['1', '1', '1', '1', '0', '(0)', '1', '1', '0', '0', '1', '0', 'Rn#4', '0', '0', '0', '0', 'Rd#4', '0', '0', '(0)', '(0)', 'sat_imm#4']
    return Instruction_SSAT16_T1_fff0f0f0_f3200000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3a00000:
    // USAT16<c> <Rd>, #<imm4>, <Rn> - ['could_jmp'] - ['1', '1', '1', '1', '0', '(0)', '1', '1', '1', '0', '1', '0', 'Rn#4', '0', '0', '0', '0', 'Rd#4', '0', '0', '(0)', '(0)', 'sat_imm#4']
    return Instruction_USAT16_T1_fff0f0f0_f3a00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa80f000:
    // SADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
    return Instruction_SADD8_T1_fff0f0f0_fa80f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa80f010:
    // QADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '1', 'Rm#4']
    return Instruction_QADD8_T1_fff0f0f0_fa80f010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa80f020:
    // SHADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '1', '0', 'Rm#4']
    return Instruction_SHADD8_T1_fff0f0f0_fa80f020(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa80f040:
    // UADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '0', 'Rm#4']
    return Instruction_UADD8_T1_fff0f0f0_fa80f040(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa80f050:
    // UQADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '1', 'Rm#4']
    return Instruction_UQADD8_T1_fff0f0f0_fa80f050(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa80f060:
    // UHADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '1', '0', 'Rm#4']
    return Instruction_UHADD8_T1_fff0f0f0_fa80f060(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa80f080:
    // QADD<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '0', '0', '0', 'Rm#4']
    return Instruction_QADD_T1_fff0f0f0_fa80f080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa80f090:
    // QDADD<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '0', '0', '1', 'Rm#4']
    return Instruction_QDADD_T1_fff0f0f0_fa80f090(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa80f0a0:
    // QSUB<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '0', '1', '0', 'Rm#4']
    return Instruction_QSUB_T1_fff0f0f0_fa80f0a0(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa80f0b0:
    // QDSUB<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '0', '1', '1', 'Rm#4']
    return Instruction_QDSUB_T1_fff0f0f0_fa80f0b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa90f080:
    // REV<c>.W <Rd>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '1', 'RmDup#4', '1', '1', '1', '1', 'Rd#4', '1', '0', '0', '0', 'Rm#4']
    return Instruction_REV_T2_fff0f0f0_fa90f080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa90f090:
    // REV16<c>.W <Rd>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '1', 'RmDup#4', '1', '1', '1', '1', 'Rd#4', '1', '0', '0', '1', 'Rm#4']
    return Instruction_REV16_T2_fff0f0f0_fa90f090(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa90f0a0:
    // RBIT<c> <Rd>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '1', 'RmDup#4', '1', '1', '1', '1', 'Rd#4', '1', '0', '1', '0', 'Rm#4']
    return Instruction_RBIT_T1_fff0f0f0_fa90f0a0(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa90f0b0:
    // REVSH<c>.W <Rd>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '1', 'RmDup#4', '1', '1', '1', '1', 'Rd#4', '1', '0', '1', '1', 'Rm#4']
    return Instruction_REVSH_T2_fff0f0f0_fa90f0b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa90f000:
    // SADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
    return Instruction_SADD16_T1_fff0f0f0_fa90f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa90f010:
    // QADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '1', 'Rm#4']
    return Instruction_QADD16_T1_fff0f0f0_fa90f010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa90f020:
    // SHADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '1', '0', 'Rm#4']
    return Instruction_SHADD16_T1_fff0f0f0_fa90f020(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa90f040:
    // UADD16<c> <Rd>, <Rn>, <Rm> - [] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '0', 'Rm#4']
    return Instruction_UADD16_T1_fff0f0f0_fa90f040(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa90f050:
    // UQADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '1', 'Rm#4']
    return Instruction_UQADD16_T1_fff0f0f0_fa90f050(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa90f060:
    // UHADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '1', '0', 'Rm#4']
    return Instruction_UHADD16_T1_fff0f0f0_fa90f060(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfaa0f000:
    // SASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
    return Instruction_SASX_T1_fff0f0f0_faa0f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfaa0f010:
    // QASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '1', 'Rm#4']
    return Instruction_QASX_T1_fff0f0f0_faa0f010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfaa0f020:
    // SHASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '1', '0', 'Rm#4']
    return Instruction_SHASX_T1_fff0f0f0_faa0f020(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfaa0f040:
    // UASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '0', 'Rm#4']
    return Instruction_UASX_T1_fff0f0f0_faa0f040(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfaa0f050:
    // UQASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '1', 'Rm#4']
    return Instruction_UQASX_T1_fff0f0f0_faa0f050(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfaa0f060:
    // UHASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '1', '0', 'Rm#4']
    return Instruction_UHASX_T1_fff0f0f0_faa0f060(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfaa0f080:
    // SEL<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '0', '0', '0', 'Rm#4']
    return Instruction_SEL_T1_fff0f0f0_faa0f080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfab0f080:
    // CLZ<c> <Rd>, <Rm> - [] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '1', 'RmDup#4', '1', '1', '1', '1', 'Rd#4', '1', '0', '0', '0', 'Rm#4']
    return Instruction_CLZ_T1_fff0f0f0_fab0f080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfac0f000:
    // SSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
    return Instruction_SSUB8_T1_fff0f0f0_fac0f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfac0f010:
    // QSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '1', 'Rm#4']
    return Instruction_QSUB8_T1_fff0f0f0_fac0f010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfac0f020:
    // SHSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '1', '0', 'Rm#4']
    return Instruction_SHSUB8_T1_fff0f0f0_fac0f020(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfac0f040:
    // USUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '0', 'Rm#4']
    return Instruction_USUB8_T1_fff0f0f0_fac0f040(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfac0f050:
    // UQSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '1', 'Rm#4']
    return Instruction_UQSUB8_T1_fff0f0f0_fac0f050(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfac0f060:
    // UHSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '1', '0', 'Rm#4']
    return Instruction_UHSUB8_T1_fff0f0f0_fac0f060(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfad0f000:
    // SSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
    return Instruction_SSUB16_T1_fff0f0f0_fad0f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfad0f010:
    // QSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '1', 'Rm#4']
    return Instruction_QSUB16_T1_fff0f0f0_fad0f010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfad0f020:
    // SHSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '1', '0', 'Rm#4']
    return Instruction_SHSUB16_T1_fff0f0f0_fad0f020(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfad0f040:
    // USUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '0', 'Rm#4']
    return Instruction_USUB16_T1_fff0f0f0_fad0f040(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfad0f050:
    // UQSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '1', 'Rm#4']
    return Instruction_UQSUB16_T1_fff0f0f0_fad0f050(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfad0f060:
    // UHSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '1', '0', 'Rm#4']
    return Instruction_UHSUB16_T1_fff0f0f0_fad0f060(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfae0f000:
    // SSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
    return Instruction_SSAX_T1_fff0f0f0_fae0f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfae0f010:
    // QSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '1', 'Rm#4']
    return Instruction_QSAX_T1_fff0f0f0_fae0f010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfae0f020:
    // SHSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '1', '0', 'Rm#4']
    return Instruction_SHSAX_T1_fff0f0f0_fae0f020(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfae0f040:
    // USAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '0', 'Rm#4']
    return Instruction_USAX_T1_fff0f0f0_fae0f040(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfae0f050:
    // UQSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '1', 'Rm#4']
    return Instruction_UQSAX_T1_fff0f0f0_fae0f050(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfae0f060:
    // UHSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '1', '0', 'Rm#4']
    return Instruction_UHSAX_T1_fff0f0f0_fae0f060(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb00f000:
    // MUL<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
    return Instruction_MUL_T2_fff0f0f0_fb00f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb70f000:
    // USAD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '1', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
    return Instruction_USAD8_T1_fff0f0f0_fb70f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb90f0f0:
    // SDIV<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '0', '1', 'Rn#4', '(1)', '(1)', '(1)', '(1)', 'Rd#4', '1', '1', '1', '1', 'Rm#4']
    return Instruction_SDIV_T1_fff0f0f0_fb90f0f0(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfbb0f0f0:
    // UDIV<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', 'Rn#4', '(1)', '(1)', '(1)', '(1)', 'Rd#4', '1', '1', '1', '1', 'Rm#4']
    return Instruction_UDIV_T1_fff0f0f0_fbb0f0f0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfff000ff) == 0xe8d0007f)
    // LDREXD<c> <Rt>, <Rt2>, [<Rn>] - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '1', '0', '1', 'Rn#4', 'Rt#4', 'Rt2#4', '0', '1', '1', '1', '(1)', '(1)', '(1)', '(1)']
    return Instruction_LDREXD_T1_fff000ff_e8d0007f(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfff00ff0)
  {
  case 0xe8c00f40:
    // STREXB<c> <Rd>, <Rt>, [<Rn>] - [] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '1', '0', '0', 'Rn#4', 'Rt#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '0', 'Rd#4']
    return Instruction_STREXB_T1_fff00ff0_e8c00f40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xe8c00f50:
    // STREXH<c> <Rd>, <Rt>, [<Rn>] - [] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '1', '0', '0', 'Rn#4', 'Rt#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '1', 'Rd#4']
    return Instruction_STREXH_T1_fff00ff0_e8c00f50(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffbf0f00)
  {
  case 0xecbd0a00:
    // VPOP <list> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', '0', '1', 'D#1', '1', '1', '1', '1', '0', '1', 'Vd#4', '1', '0', '1', '0', 'imm#8']
    return Instruction_VPOP_T2_ffbf0f00_ecbd0a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xecbd0b00:
    // VPOP <list> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', '0', '1', 'D#1', '1', '1', '1', '1', '0', '1', 'Vd#4', '1', '0', '1', '1', 'imm#8']
    return Instruction_VPOP_T1_ffbf0f00_ecbd0b00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xed2d0a00:
    // VPUSH<c> <list> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', '1', '0', 'D#1', '1', '0', '1', '1', '0', '1', 'Vd#4', '1', '0', '1', '0', 'imm#8']
    return Instruction_VPUSH_T2_ffbf0f00_ed2d0a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xed2d0b00:
    // VPUSH<c> <list> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', '1', '0', 'D#1', '1', '0', '1', '1', '0', '1', 'Vd#4', '1', '0', '1', '1', 'imm#8']
    return Instruction_VPUSH_T1_ffbf0f00_ed2d0b00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffe0f0f0)
  {
  case 0xfa00f000:
    // LSL{S}<c>.W <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '0', 'S#1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
    return Instruction_LSL_T2_ffe0f0f0_fa00f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa20f000:
    // LSR{S}<c>.W <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '1', 'S#1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
    return Instruction_LSR_T2_ffe0f0f0_fa20f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa40f000:
    // ASR{S}<c>.W <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '1', '0', 'S#1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
    return Instruction_ASR_T2_ffe0f0f0_fa40f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa60f000:
    // ROR{S}<c>.W <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '1', '1', 'S#1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
    return Instruction_ROR_T2_ffe0f0f0_fa60f000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffb30ed0) == 0xffb20600)
    // VCVT<c>.F32.F16 <Qd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '1', '1', 'op#1', '0', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VCVT_T1_ffb30ed0_ffb20600(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xff900f1f) == 0xee000b10)
    // VMOV<c>.<size> <Dd[x]>, <Rt> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '0', 'opc1#2', '0', 'Vd#4', 'Rt#4', '1', '0', '1', '1', 'D#1', 'opc2#2', '1', '(0)', '(0)', '(0)', '(0)']
    return Instruction_VMOV_T1_ff900f1f_ee000b10(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfff0f0e0)
  {
  case 0xfb20f000:
    // SMUAD{X}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '0', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', 'M#1', 'Rm#4']
    return Instruction_SMUAD_T1_fff0f0e0_fb20f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb30f000:
    // SMULW<y><c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '0', '1', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', 'M#1', 'Rm#4']
    return Instruction_SMULW_T1_fff0f0e0_fb30f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb40f000:
    // SMUSD{X}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', 'M#1', 'Rm#4']
    return Instruction_SMUSD_T1_fff0f0e0_fb40f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb50f000:
    // SMMUL{R}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', 'R#1', 'Rm#4']
    return Instruction_SMMUL_T1_fff0f0e0_fb50f000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffb30f90)
  {
  case 0xffb00400:
    // VCLS<c>.<dt> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '0', '0', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCLS_T1_ffb30f90_ffb00400(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb00480:
    // VCLZ<c>.<dt> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '0', '0', '1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCLZ_T1_ffb30f90_ffb00480(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb00500:
    // VCNT<c>.8 <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '0', '1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCNT_T1_ffb30f90_ffb00500(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb00580:
    // VMVN<c> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '0', '1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VMVN_T1_ffb30f90_ffb00580(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb00700:
    // VQABS<c>.<dt> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '1', '1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VQABS_T1_ffb30f90_ffb00700(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb00780:
    // VQNEG<c>.<dt> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '1', '1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VQNEG_T1_ffb30f90_ffb00780(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb20000:
    // VSWP<c> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '0', '0', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VSWP_T1_ffb30f90_ffb20000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb20080:
    // VTRN<c>.<size> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '0', '0', '1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VTRN_T1_ffb30f90_ffb20080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb20100:
    // VUZP<c>.<size> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '0', '1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VUZP_T1_ffb30f90_ffb20100(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb20180:
    // VZIP<c>.<size> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '0', '1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VZIP_T1_ffb30f90_ffb20180(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xff7ff000)
  {
  case 0xf81ff000:
    // PLD<c> [PC,#-0] - [] - ['1', '1', '1', '1', '1', '0', '0', '0', 'U#1', '0', '(0)', '1', '1', '1', '1', '1', '1', '1', '1', '1', 'imm#12']
    return Instruction_PLD_T1_ff7ff000_f81ff000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf91ff000:
    // PLI<c> [PC,#-0] - [] - ['1', '1', '1', '1', '1', '0', '0', '1', 'U#1', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', 'imm#12']
    return Instruction_PLI_T3_ff7ff000_f91ff000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfff0f0c0)
  {
  case 0xfa00f080:
    // SXTAH<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
    return Instruction_SXTAH_T1_fff0f0c0_fa00f080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa10f080:
    // UXTAH<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
    return Instruction_UXTAH_T1_fff0f0c0_fa10f080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa20f080:
    // SXTAB16<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
    return Instruction_SXTAB16_T1_fff0f0c0_fa20f080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa30f080:
    // UXTAB16<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '1', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
    return Instruction_UXTAB16_T1_fff0f0c0_fa30f080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa40f080:
    // SXTAB<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '1', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
    return Instruction_SXTAB_T1_fff0f0c0_fa40f080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa50f080:
    // UXTAB<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '1', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
    return Instruction_UXTAB_T1_fff0f0c0_fa50f080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb10f000:
    // SMUL<x><y><c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', 'N#1', 'M#1', 'Rm#4']
    return Instruction_SMUL_T1_fff0f0c0_fb10f000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffef8030)
  {
  case 0xea4f0000:
    // LSL{S}<c>.W <Rd>, <Rm>, #<imm5> - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '1', '0', 'S#1', '1', '1', '1', '1', '(0)', 'imm#3', 'Rd#4', 'imm#2', '0', '0', 'Rm#4']
    return Instruction_LSL_T2_ffef8030_ea4f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xea4f0010:
    // LSR{S}<c>.W <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '1', '0', 'S#1', '1', '1', '1', '1', '(0)', 'imm#3', 'Rd#4', 'imm#2', '0', '1', 'Rm#4']
    return Instruction_LSR_T2_ffef8030_ea4f0010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xea4f0020:
    // ASR{S}<c>.W <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '1', '0', 'S#1', '1', '1', '1', '1', '(0)', 'imm#3', 'Rd#4', 'imm#2', '1', '0', 'Rm#4']
    return Instruction_ASR_T2_ffef8030_ea4f0020(rBinStrm, Offset, Opcode32, rInsn);
  case 0xea4f0030:
    // ROR{S}<c> <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '1', '0', 'S#1', '1', '1', '1', '1', '(0)', 'imm#3', 'Rd#4', 'imm#2', '1', '1', 'Rm#4']
    return Instruction_ROR_T1_ffef8030_ea4f0030(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xef870fd0) == 0xef800a10)
    // VMOVL<c>.<dt> <Qd>, <Dm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'imm#3', '0', '0', '0', 'Vd#4', '1', '0', '1', '0', '0', '0', 'M#1', '1', 'Vm#4']
    return Instruction_VMOVL_T1_ef870fd0_ef800a10(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffb30f10)
  {
  case 0xffb00200:
    // VPADDL<c>.<dt> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '0', '1', '0', 'op#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VPADDL_T1_ffb30f10_ffb00200(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb00600:
    // VPADAL<c>.<dt> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '1', '0', 'op#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VPADAL_T1_ffb30f10_ffb00600(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb20200:
    // VQMOV{op}N<c>.<type><size> <Dd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '1', '0', 'op2#2', 'M#1', '0', 'Vm#4']
    return Instruction_VQMOV_T1_ffb30f10_ffb20200(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffb30e90)
  {
  case 0xffb30400:
    // VRECPE<c>.<dt> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '1', 'Vd#4', '0', '1', '0', 'F#1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VRECPE_T1_ffb30e90_ffb30400(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb30480:
    // VRSQRTE<c>.<dt> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '1', 'Vd#4', '0', '1', '0', 'F#1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VRSQRTE_T1_ffb30e90_ffb30480(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffb00ef0) == 0xeeb00a00)
    // VMOV<c>.F64 <Dd>, #<imm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', 'imm_h#4', 'Vd#4', '1', '0', '1', 'sz#1', '(0)', '0', '(0)', '0', 'imm_l#4']
    return Instruction_VMOV_T2_ffb00ef0_eeb00a00(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xffffa000) == 0xe8ad0000)
    // PUSH<c>.W <registers> - [] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '0', '1', '0', '1', '1', '0', '1', '(0)', 'M#1', '(0)', 'register_list#13']
    return Instruction_PUSH_T2_ffffa000_e8ad0000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xff100f1f) == 0xee100b10)
    // VMOV<c>.<dt> <Rt>, <Dn[x]> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', 'U#1', 'opc1#2', '1', 'Vn#4', 'Rt#4', '1', '0', '1', '1', 'N#1', 'opc2#2', '1', '(0)', '(0)', '(0)', '(0)']
    return Instruction_VMOV_T1_ff100f1f_ee100b10(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffb30b90)
  {
  case 0xffb10000:
    // VCGT<c>.<dt> <Qd>, <Qm>, #0 - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '0', '0', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCGT_T1_ffb30b90_ffb10000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb10080:
    // VCGE<c>.<dt> <Qd>, <Qm>, #0 - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '0', '0', '1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCGE_T1_ffb30b90_ffb10080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb10100:
    // VCEQ<c>.<dt> <Qd>, <Qm>, #0 - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '0', '1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCEQ_T1_ffb30b90_ffb10100(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb10180:
    // VCLE<c>.<dt> <Qd>, <Qm>, #0 - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '0', '1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCLE_T1_ffb30b90_ffb10180(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb10200:
    // VCLT<c>.<dt> <Qd>, <Qm>, #0 - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '1', '0', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCLT_T1_ffb30b90_ffb10200(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb10300:
    // VABS<c>.<dt> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '1', '1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VABS_T1_ffb30b90_ffb10300(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb10380:
    // VNEG<c>.<dt> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '1', '1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VNEG_T1_ffb30b90_ffb10380(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfff00fc0)
  {
  case 0xf8000000:
    // STRB<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', 'Rn#4', 'Rt#4', '0', '0', '0', '0', '0', '0', 'imm#2', 'Rm#4']
    return Instruction_STRB_T2_fff00fc0_f8000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8100000:
    // LDRB<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '1', 'Rn#4', 'Rt#4', '0', '0', '0', '0', '0', '0', 'imm#2', 'Rm#4']
    return Instruction_LDRB_T2_fff00fc0_f8100000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8200000:
    // STRH<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '1', '0', 'Rn#4', 'Rt#4', '0', '0', '0', '0', '0', '0', 'imm#2', 'Rm#4']
    return Instruction_STRH_T2_fff00fc0_f8200000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8300000:
    // LDRH<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '1', '1', 'Rn#4', 'Rt#4', '0', '0', '0', '0', '0', '0', 'imm#2', 'Rm#4']
    return Instruction_LDRH_T2_fff00fc0_f8300000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8400000:
    // STR<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '1', '0', '0', 'Rn#4', 'Rt#4', '0', '0', '0', '0', '0', '0', 'imm#2', 'Rm#4']
    return Instruction_STR_T2_fff00fc0_f8400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8500000:
    // LDR<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '1', '0', '1', 'Rn#4', 'Rt#4', '0', '0', '0', '0', '0', '0', 'imm#2', 'Rm#4']
    return Instruction_LDR_T2_fff00fc0_f8500000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf9100000:
    // LDRSB<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '1', '0', '0', '0', '1', 'Rn#4', 'Rt#4', '0', '0', '0', '0', '0', '0', 'imm#2', 'Rm#4']
    return Instruction_LDRSB_T2_fff00fc0_f9100000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf9300000:
    // LDRSH<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '1', '0', '0', '1', '1', 'Rn#4', 'Rt#4', '0', '0', '0', '0', '0', '0', 'imm#2', 'Rm#4']
    return Instruction_LDRSH_T2_fff00fc0_f9300000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffff8020) == 0xf36f0000)
    // BFC<c> <Rd>, #<lsb>, #<width> - ['could_jmp'] - ['1', '1', '1', '1', '0', '(0)', '1', '1', '0', '1', '1', '0', '1', '1', '1', '1', '0', 'imm#3', 'Rd#4', 'imm#2', '(0)', 'msb#5']
    return Instruction_BFC_T1_ffff8020_f36f0000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffe00fd0)
  {
  case 0xec400a10:
    // VMOV<c> <Sm>, <Sm1>, <Rt>, <Rt2> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', '0', '0', '1', '0', 'op#1', 'Rt2#4', 'Rt#4', '1', '0', '1', '0', '0', '0', 'M#1', '1', 'Vm#4']
    return Instruction_VMOV_T1_ffe00fd0_ec400a10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xec400b10:
    // VMOV<c> <Dm>, <Rt>, <Rt2> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', '0', '0', '1', '0', 'op#1', 'Rt2#4', 'Rt#4', '1', '0', '1', '1', '0', '0', 'M#1', '1', 'Vm#4']
    return Instruction_VMOV_T1_ffe00fd0_ec400b10(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffba0e50) == 0xeeba0a40)
    // VCVT<c>.<Td>.F64 <Dd>, <Dd>, #<fbits> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', '1', 'op#1', '1', 'U#1', 'Vd#4', '1', '0', '1', 'sf#1', 'sx#1', '1', 'imm#1', '0', 'imm#4']
    return Instruction_VCVT_T1_ffba0e50_eeba0a40(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xffb80e50) == 0xeeb80a40)
    // VCVT{R}<c>.S32.F64 <Sd>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', '1', 'opc2#3', 'Vd#4', '1', '0', '1', 'sz#1', 'op#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VCVT_T1_ffb80e50_eeb80a40(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffb30e10)
  {
  case 0xffb00000:
    // VREV<n><c>.<size> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '0', '0', 'op2#2', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VREV_T1_ffb30e10_ffb00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb30600:
    // VCVT<c>.<Td>.<Tm> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '1', 'Vd#4', '0', '1', '1', 'op#2', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCVT_T1_ffb30e10_ffb30600(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfff08f00)
  {
  case 0xea100f00:
    // TST<c>.W <Rn>, <Rm>{,<shift>} - [] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '0', '0', '1', 'Rn#4', '(0)', 'imm#3', '1', '1', '1', '1', 'imm#2', 'type#2', 'Rm#4']
    return Instruction_TST_T2_fff08f00_ea100f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xea900f00:
    // TEQ<c> <Rn>, <Rm>{,<shift>} - [] - ['1', '1', '1', '0', '1', '0', '1', '0', '1', '0', '0', '1', 'Rn#4', '(0)', 'imm#3', '1', '1', '1', '1', 'imm#2', 'type#2', 'Rm#4']
    return Instruction_TEQ_T1_fff08f00_ea900f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeb100f00:
    // CMN<c>.W <Rn>, <Rm>{,<shift>} - ['cond'] - ['1', '1', '1', '0', '1', '0', '1', '1', '0', '0', '0', '1', 'Rn#4', '(0)', 'imm#3', '1', '1', '1', '1', 'imm#2', 'type#2', 'Rm#4']
    return Instruction_CMN_T2_fff08f00_eb100f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xebb00f00:
    // CMP<c>.W <Rn>, <Rm> {,<shift>} - ['cond'] - ['1', '1', '1', '0', '1', '0', '1', '1', '1', '0', '1', '1', 'Rn#4', '(0)', 'imm#3', '1', '1', '1', '1', 'imm#2', 'type#2', 'Rm#4']
    return Instruction_CMP_T3_fff08f00_ebb00f00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffff2000) == 0xe8bd0000)
    // POP<c>.W <registers> - ['could_ret'] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '0', '1', '1', '1', '1', '0', '1', 'P#1', 'M#1', '(0)', 'register_list#13']
    return Instruction_POP_T2_ffff2000_e8bd0000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xffb00f90) == 0xffb00c00)
    // VDUP<c>.<size> <Qd>, <Dm[x]> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'imm#4', 'Vd#4', '1', '1', '0', '0', '0', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VDUP_T1_ffb00f90_ffb00c00(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfff000f0)
  {
  case 0xe8c00070:
    // STREXD<c> <Rd>, <Rt>, <Rt2>, [<Rn>] - [] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '1', '0', '0', 'Rn#4', 'Rt#4', 'Rt2#4', '0', '1', '1', '1', 'Rd#4']
    return Instruction_STREXD_T1_fff000f0_e8c00070(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb000000:
    // MLA<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '0', '0', '0', 'Rn#4', 'Ra#4', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
    return Instruction_MLA_T1_fff000f0_fb000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb000010:
    // MLS<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '0', '0', '0', 'Rn#4', 'Ra#4', 'Rd#4', '0', '0', '0', '1', 'Rm#4']
    return Instruction_MLS_T1_fff000f0_fb000010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb700000:
    // USADA8<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '1', '1', 'Rn#4', 'Ra#4', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
    return Instruction_USADA8_T1_fff000f0_fb700000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb800000:
    // SMULL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '0', '0', 'Rn#4', 'RdLo#4', 'RdHi#4', '0', '0', '0', '0', 'Rm#4']
    return Instruction_SMULL_T1_fff000f0_fb800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfba00000:
    // UMULL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1', '0', 'Rn#4', 'RdLo#4', 'RdHi#4', '0', '0', '0', '0', 'Rm#4']
    return Instruction_UMULL_T1_fff000f0_fba00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfbc00000:
    // SMLAL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '0', 'Rn#4', 'RdLo#4', 'RdHi#4', '0', '0', '0', '0', 'Rm#4']
    return Instruction_SMLAL_T1_fff000f0_fbc00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfbe00000:
    // UMLAL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '0', 'Rn#4', 'RdLo#4', 'RdHi#4', '0', '0', '0', '0', 'Rm#4']
    return Instruction_UMLAL_T1_fff000f0_fbe00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfbe00060:
    // UMAAL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '0', 'Rn#4', 'RdLo#4', 'RdHi#4', '0', '1', '1', '0', 'Rm#4']
    return Instruction_UMAAL_T1_fff000f0_fbe00060(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfff00f00)
  {
  case 0xe8500f00:
    // LDREX<c> <Rt>, [<Rn>{, #<disp>}] - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '0', '0', '0', '1', '0', '1', 'Rn#4', 'Rt#4', '(1)', '(1)', '(1)', '(1)', 'imm#8']
    return Instruction_LDREX_T1_fff00f00_e8500f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8000e00:
    // STRBT<c> <Rt>, [<Rn>, #<disp>] - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', 'Rn#4', 'Rt#4', '1', '1', '1', '0', 'imm#8']
    return Instruction_STRBT_T1_fff00f00_f8000e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8100e00:
    // LDRBT<c> <Rt>, [<Rn>, #<disp>] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '1', 'Rn#4', 'Rt#4', '1', '1', '1', '0', 'imm#8']
    return Instruction_LDRBT_T1_fff00f00_f8100e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8200e00:
    // STRHT<c> <Rt>, [<Rn>, #<disp>] - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '1', '0', 'Rn#4', 'Rt#4', '1', '1', '1', '0', 'imm#8']
    return Instruction_STRHT_T1_fff00f00_f8200e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8300e00:
    // LDRHT<c> <Rt>, [<Rn>, #<disp>] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '1', '1', 'Rn#4', 'Rt#4', '1', '1', '1', '0', 'imm#8']
    return Instruction_LDRHT_T1_fff00f00_f8300e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8400e00:
    // STRT<c> <Rt>, [<Rn>, #<disp>] - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '1', '0', '0', 'Rn#4', 'Rt#4', '1', '1', '1', '0', 'imm#8']
    return Instruction_STRT_T1_fff00f00_f8400e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8500e00:
    // LDRT<c> <Rt>, [<Rn>, #<disp>] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '1', '0', '1', 'Rn#4', 'Rt#4', '1', '1', '1', '0', 'imm#8']
    return Instruction_LDRT_T1_fff00f00_f8500e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf9100e00:
    // LDRSBT<c> <Rt>, [<Rn>, #<disp>] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '1', '0', '0', '0', '1', 'Rn#4', 'Rt#4', '1', '1', '1', '0', 'imm#8']
    return Instruction_LDRSBT_T1_fff00f00_f9100e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf9300e00:
    // LDRSHT<c> <Rt>, [<Rn>, #<disp>] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '1', '0', '0', '1', '1', 'Rn#4', 'Rt#4', '1', '1', '1', '0', 'imm#8']
    return Instruction_LDRSHT_T1_fff00f00_f9300e00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffb00f10)
  {
  case 0xef000110:
    // VAND<c> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', '0', '0', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VAND_T1_ffb00f10_ef000110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef100110:
    // VBIC<c> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', '0', '1', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VBIC_T1_ffb00f10_ef100110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef200110:
    // VORR<c> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', '1', '0', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VORR_T1_ffb00f10_ef200110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef300110:
    // VORN<c> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', '1', '1', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VORN_T1_ffb00f10_ef300110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff000110:
    // VEOR<c> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', '0', '0', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VEOR_T1_ffb00f10_ff000110(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfbf08f00)
  {
  case 0xf0100f00:
    // TST<c> <Rn>, #<imm> - [] - ['1', '1', '1', '1', '0', 'imm#1', '0', '0', '0', '0', '0', '1', 'Rn#4', '0', 'imm#3', '1', '1', '1', '1', 'imm#8']
    return Instruction_TST_T1_fbf08f00_f0100f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf0900f00:
    // TEQ<c> <Rn>, #<imm> - [] - ['1', '1', '1', '1', '0', 'imm#1', '0', '0', '1', '0', '0', '1', 'Rn#4', '0', 'imm#3', '1', '1', '1', '1', 'imm#8']
    return Instruction_TEQ_T1_fbf08f00_f0900f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf1100f00:
    // CMN<c> <Rn>, #<thumb_expand_imm> - ['cond'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '1', '0', '0', '0', '1', 'Rn#4', '0', 'imm#3', '1', '1', '1', '1', 'imm#8']
    return Instruction_CMN_T1_fbf08f00_f1100f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf1b00f00:
    // CMP<c>.W <Rn>, #<imm> - ['cond'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '1', '1', '0', '1', '1', 'Rn#4', '0', 'imm#3', '1', '1', '1', '1', 'imm#8']
    return Instruction_CMP_T2_fbf08f00_f1b00f00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xff800fd0)
  {
  case 0xef800810:
    // VSHRN<c>.I<size> <Dd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '1', '0', '0', '0', '0', '0', 'M#1', '1', 'Vm#4']
    return Instruction_VSHRN_T1_ff800fd0_ef800810(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800850:
    // VRSHRN<c>.I<size> <Dd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '1', '0', '0', '0', '0', '1', 'M#1', '1', 'Vm#4']
    return Instruction_VRSHRN_T1_ff800fd0_ef800850(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfff0f000) == 0xf990f000)
    // PLI<c> [<Rn>, #<disp>] - [] - ['1', '1', '1', '1', '1', '0', '0', '1', '1', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', 'imm#12']
    return Instruction_PLI_T1_fff0f000_f990f000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffef8000)
  {
  case 0xea6f0000:
    // MVN{S}<c>.W <Rd>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '1', '1', 'S#1', '1', '1', '1', '1', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
    return Instruction_MVN_T2_ffef8000_ea6f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeb0d0000:
    // ADD{S}<c>.W <Rd>, SP, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '1', '0', '0', '0', 'S#1', '1', '1', '0', '1', '0', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
    return Instruction_ADD_T3_ffef8000_eb0d0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xebad0000:
    // SUB{S}<c> <Rd>, SP, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '1', '1', '0', '1', 'S#1', '1', '1', '0', '1', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
    return Instruction_SUB_T1_ffef8000_ebad0000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffb00e50)
  {
  case 0xee200a00:
    // VMUL<c>.F64 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '0', 'D#1', '1', '0', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VMUL_T2_ffb00e50_ee200a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xee200a40:
    // VNMUL<c>.F64 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '0', 'D#1', '1', '0', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VNMUL_T2_ffb00e50_ee200a40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xee300a00:
    // VADD<c>.F64 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '0', 'D#1', '1', '1', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VADD_T2_ffb00e50_ee300a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xee300a40:
    // VSUB<c>.F64 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '0', 'D#1', '1', '1', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VSUB_T2_ffb00e50_ee300a40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xee800a00:
    // VDIV<c>.F64 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '0', '0', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VDIV_T1_ffb00e50_ee800a00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfbff8000)
  {
  case 0xf20d0000:
    // ADDW<c> <Rd>, SP, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '1', '0', '0', '0', '0', '0', '1', '1', '0', '1', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_ADDW_T4_fbff8000_f20d0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf20f0000:
    // ADR<c>.W <Rd>, <label> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '1', '0', '0', '0', '0', '0', '1', '1', '1', '1', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_ADR_T3_fbff8000_f20f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2ad0000:
    // SUBW<c> <Rd>, SP, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '1', '0', '1', '0', '1', '0', '1', '1', '0', '1', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_SUBW_T3_fbff8000_f2ad0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2af0000:
    // SUB <Rd>, PC, #0 - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '1', '0', '1', '0', '1', '0', '1', '1', '1', '1', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_SUB_T2_fbff8000_f2af0000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode16 & 0x0000ffff)
  {
  case 0x0000bf00:
    // NOP<c> - [] - ['1', '0', '1', '1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0']
    return Instruction_NOP_T1_0000ffff_0000bf00(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000bf10:
    // YIELD<c> - [] - ['1', '0', '1', '1', '1', '1', '1', '1', '0', '0', '0', '1', '0', '0', '0', '0']
    return Instruction_YIELD_T1_0000ffff_0000bf10(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000bf20:
    // WFE<c> - [] - ['1', '0', '1', '1', '1', '1', '1', '1', '0', '0', '1', '0', '0', '0', '0', '0']
    return Instruction_WFE_T1_0000ffff_0000bf20(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000bf30:
    // WFI<c> - [] - ['1', '0', '1', '1', '1', '1', '1', '1', '0', '0', '1', '1', '0', '0', '0', '0']
    return Instruction_WFI_T1_0000ffff_0000bf30(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000bf40:
    // SEV<c> - [] - ['1', '0', '1', '1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '0', '0', '0']
    return Instruction_SEV_T1_0000ffff_0000bf40(rBinStrm, Offset, Opcode16, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfff000e0)
  {
  case 0xfb200000:
    // SMLAD{X}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '0', '1', '0', 'Rn#4', 'Ra#4', 'Rd#4', '0', '0', '0', 'M#1', 'Rm#4']
    return Instruction_SMLAD_T1_fff000e0_fb200000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb300000:
    // SMLAW<y><c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '0', '1', '1', 'Rn#4', 'Ra#4', 'Rd#4', '0', '0', '0', 'M#1', 'Rm#4']
    return Instruction_SMLAW_T1_fff000e0_fb300000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb400000:
    // SMLSD{X}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '0', '0', 'Rn#4', 'Ra#4', 'Rd#4', '0', '0', '0', 'M#1', 'Rm#4']
    return Instruction_SMLSD_T1_fff000e0_fb400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb500000:
    // SMMLA{R}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '0', '1', 'Rn#4', 'Ra#4', 'Rd#4', '0', '0', '0', 'R#1', 'Rm#4']
    return Instruction_SMMLA_T1_fff000e0_fb500000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb600000:
    // SMMLS{R}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '1', '0', 'Rn#4', 'Ra#4', 'Rd#4', '0', '0', '0', 'R#1', 'Rm#4']
    return Instruction_SMMLS_T1_fff000e0_fb600000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfbc000c0:
    // SMLALD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '0', 'Rn#4', 'RdLo#4', 'RdHi#4', '1', '1', '0', 'M#1', 'Rm#4']
    return Instruction_SMLALD_T1_fff000e0_fbc000c0(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfbd000c0:
    // SMLSLD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '1', 'Rn#4', 'RdLo#4', 'RdHi#4', '1', '1', '0', 'M#1', 'Rm#4']
    return Instruction_SMLSLD_T1_fff000e0_fbd000c0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffb00e10)
  {
  case 0xee000a00:
    // V<op><c>.F64 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '0', 'D#1', '0', '0', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', 'op#1', 'M#1', '0', 'Vm#4']
    return Instruction_V_T2_ffb00e10_ee000a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xee100a00:
    // VNMLA<c>.F64 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '0', 'D#1', '0', '1', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', 'op#1', 'M#1', '0', 'Vm#4']
    return Instruction_VNMLA_T1_ffb00e10_ee100a00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xff7f0000)
  {
  case 0xf81f0000:
    // LDRB<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', 'U#1', '0', '0', '1', '1', '1', '1', '1', 'Rt#4', 'imm#12']
    return Instruction_LDRB_T1_ff7f0000_f81f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf83f0000:
    // LDRH<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', 'U#1', '0', '1', '1', '1', '1', '1', '1', 'Rt#4', 'imm#12']
    return Instruction_LDRH_T1_ff7f0000_f83f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf85f0000:
    // LDR<c>.W <Rt>, [PC,#-0] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', 'U#1', '1', '0', '1', '1', '1', '1', '1', 'Rt#4', 'imm#12']
    return Instruction_LDR_T2_ff7f0000_f85f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf91f0000:
    // LDRSB<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '1', 'U#1', '0', '0', '1', '1', '1', '1', '1', 'Rt#4', 'imm#12']
    return Instruction_LDRSB_T1_ff7f0000_f91f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf93f0000:
    // LDRSH<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '1', 'U#1', '0', '1', '1', '1', '1', '1', '1', 'Rt#4', 'imm#12']
    return Instruction_LDRSH_T1_ff7f0000_f93f0000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffa00f10)
  {
  case 0xef000d00:
    // VADD<c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VADD_T1_ffa00f10_ef000d00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000e00:
    // VCEQ<c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCEQ_T2_ffa00f10_ef000e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000f10:
    // VRECPS<c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VRECPS_T1_ffa00f10_ef000f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef200d00:
    // VSUB<c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', '1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VSUB_T1_ffa00f10_ef200d00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef200f10:
    // VRSQRTS<c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', '1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VRSQRTS_T1_ffa00f10_ef200f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff000d00:
    // VPADD<c>.F32 - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VPADD_T1_ffa00f10_ff000d00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff000d10:
    // VMUL<c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VMUL_T1_ffa00f10_ff000d10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff000e00:
    // VCGE<c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCGE_T2_ffa00f10_ff000e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff200d00:
    // VABD<c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', '1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VABD_T1_ffa00f10_ff200d00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff200e00:
    // VCGT<c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', '1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCGT_T2_ffa00f10_ff200e00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xef800fd0) == 0xef800a10)
    // VSHLL<c>.<type><size> <Qd>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '1', '0', '1', '0', '0', '0', 'M#1', '1', 'Vm#4']
    return Instruction_VSHLL_T1_ef800fd0_ef800a10(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xffb00f00) == 0xf9a00c00)
    // VLD1<c>.<size> <list>, [<Rn>{@<align>}]{!} - ['support it block'] - ['1', '1', '1', '1', '1', '0', '0', '1', '1', 'D#1', '1', '0', 'Rn#4', 'Vd#4', '1', '1', '0', '0', 'size#2', 'T#1', 'a#1', 'Rm#4']
    return Instruction_VLD1_T1_ffb00f00_f9a00c00(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xff800f50)
  {
  case 0xef800400:
    // VADDHN<c>.<dt> <Dd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VADDHN_T1_ff800f50_ef800400(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800600:
    // VSUBHN<c>.<dt> <Dd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VSUBHN_T1_ff800f50_ef800600(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800b40:
    // VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '1', 'N#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VQDMULL_T2_ff800f50_ef800b40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800d00:
    // VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VQDMULL_T1_ff800f50_ef800d00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff800400:
    // VRADDHN<c>.<dt> <Dd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VRADDHN_T1_ff800f50_ff800400(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff800600:
    // VRSUBHN<c>.<dt> <Dd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VRSUBHN_T1_ff800f50_ff800600(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfbef8000)
  {
  case 0xf04f0000:
    // MOV{S}<c>.W <Rd>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '0', '0', '1', '0', 'S#1', '1', '1', '1', '1', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_MOV_T2_fbef8000_f04f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf06f0000:
    // MVN{S}<c> <Rd>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '0', '0', '1', '1', 'S#1', '1', '1', '1', '1', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_MVN_T1_fbef8000_f06f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf10d0000:
    // ADD{S}<c>.W <Rd>, SP, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '1', '0', '0', '0', 'S#1', '1', '1', '0', '1', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_ADD_T3_fbef8000_f10d0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf1ad0000:
    // SUB{S}<c>.W <Rd>, SP, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '1', '1', '0', '1', 'S#1', '1', '1', '0', '1', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_SUB_T2_fbef8000_f1ad0000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode16 & 0x0000fff7) == 0x0000b650)
    // SETEND <endian_specifier> - [] - ['1', '0', '1', '1', '0', '1', '1', '0', '0', '1', '0', '(1)', 'E#1', '(0)', '(0)', '(0)']
    return Instruction_SETEND_T1_0000fff7_0000b650(rBinStrm, Offset, Opcode16, rInsn);
  if ((Opcode32 & 0xfff08010) == 0xeac00000)
    // PKHTB<c> <Rd>, <Rn>, <Rm>{,ASR #<imm>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '1', '1', '0', '0', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'tb#1', '0', 'Rm#4']
    return Instruction_PKHTB_T1_fff08010_eac00000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfff08020)
  {
  case 0xf3400000:
    // SBFX<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - ['1', '1', '1', '1', '0', '(0)', '1', '1', '0', '1', '0', '0', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#2', '(0)', 'widthm1#5']
    return Instruction_SBFX_T1_fff08020_f3400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3600000:
    // BFI<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - ['1', '1', '1', '1', '0', '(0)', '1', '1', '0', '1', '1', '0', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#2', '(0)', 'msb#5']
    return Instruction_BFI_T1_fff08020_f3600000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3c00000:
    // UBFX<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - ['1', '1', '1', '1', '0', '(0)', '1', '1', '1', '1', '0', '0', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#2', '(0)', 'widthm1#5']
    return Instruction_UBFX_T1_fff08020_f3c00000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfff000c0)
  {
  case 0xfb100000:
    // SMLA<x><y><c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '0', '0', '1', 'Rn#4', 'Ra#4', 'Rd#4', '0', '0', 'N#1', 'M#1', 'Rm#4']
    return Instruction_SMLA_T1_fff000c0_fb100000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfbc00080:
    // SMLAL<x><y><c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '0', 'Rn#4', 'RdLo#4', 'RdHi#4', '1', '0', 'N#1', 'M#1', 'Rm#4']
    return Instruction_SMLAL_T1_fff000c0_fbc00080(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xef800ed0)
  {
  case 0xef800810:
    // VQSHR{op}N<c>.<type><size> <Dd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '1', '0', '0', 'op#1', '0', '0', 'M#1', '1', 'Vm#4']
    return Instruction_VQSHR_T1_ef800ed0_ef800810(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800850:
    // VQRSHR{op}N<c>.<type><size> <Dd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '1', '0', '0', 'op#1', '0', '1', 'M#1', '1', 'Vm#4']
    return Instruction_VQRSHR_T1_ef800ed0_ef800850(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xefb800b0)
  {
  case 0xef800010:
    // VORR<c>.<dt> <Qd>, #<imm> - ['support it block'] - ['1', '1', '1', 'imm#1', '1', '1', '1', '1', '1', 'D#1', '0', '0', '0', 'imm#3', 'Vd#4', 'cmode#4', '0', 'Q#1', '0', '1', 'imm#4']
    return Instruction_VORR_T1_efb800b0_ef800010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800030:
    // VBIC<c>.<dt> <Qd>, #<imm> - ['support it block'] - ['1', '1', '1', 'imm#1', '1', '1', '1', '1', '1', 'D#1', '0', '0', '0', 'imm#3', 'Vd#4', 'cmode#4', '0', 'Q#1', '1', '1', 'imm#4']
    return Instruction_VBIC_T1_efb800b0_ef800030(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xff300f00)
  {
  case 0xed000a00:
    // VSTR<c> <Sd>, [<Rn>{,#+/-<imm>}] - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', '1', 'U#1', 'D#1', '0', '0', 'Rn#4', 'Vd#4', '1', '0', '1', '0', 'imm#8']
    return Instruction_VSTR_T2_ff300f00_ed000a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xed000b00:
    // VSTR<c> <Dd>, [<Rn>{,#+/-<imm>}] - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', '1', 'U#1', 'D#1', '0', '0', 'Rn#4', 'Vd#4', '1', '0', '1', '1', 'imm#8']
    return Instruction_VSTR_T1_ff300f00_ed000b00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xed100a00:
    // VLDR<c> <Sd>, [<Rn>{,#+/-<imm>}] - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', '1', 'U#1', 'D#1', '0', '1', 'Rn#4', 'Vd#4', '1', '0', '1', '0', 'imm#8']
    return Instruction_VLDR_T2_ff300f00_ed100a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xed100b00:
    // VLDR<c> <Dd>, [<Rn>{,#+/-<imm>}] - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', '1', 'U#1', 'D#1', '0', '1', 'Rn#4', 'Vd#4', '1', '0', '1', '1', 'imm#8']
    return Instruction_VLDR_T1_ff300f00_ed100b00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xff800f10)
  {
  case 0xef000d10:
    // V<op><c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', 'op#1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_V_T1_ff800f10_ef000d10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000f00:
    // V<op><c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', 'op#1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_V_T1_ff800f10_ef000f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000800:
    // VADD<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VADD_T1_ff800f10_ef000800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000810:
    // VTST<c>.<size> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VTST_T1_ff800f10_ef000810(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000b00:
    // VQDMULH<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VQDMULH_T1_ff800f10_ef000b00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000b10:
    // VPADD<c>.<dt> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VPADD_T1_ff800f10_ef000b10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800510:
    // VSHL<c>.I<size> <Qd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '1', '0', '1', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VSHL_T1_ff800f10_ef800510(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff000e10:
    // V<op><c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', 'op#1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_V_T1_ff800f10_ff000e10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff000f00:
    // VP<op><c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', 'op#1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VP_T1_ff800f10_ff000f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff000110:
    // V<op><c> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', 'op#2', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_V_T1_ff800f10_ff000110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff000800:
    // VSUB<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VSUB_T1_ff800f10_ff000800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff000810:
    // VCEQ<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VCEQ_T1_ff800f10_ff000810(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff000b00:
    // VQRDMULH<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VQRDMULH_T1_ff800f10_ff000b00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff800410:
    // VSRI<c>.<size> <Qd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '1', '0', '0', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VSRI_T1_ff800f10_ff800410(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff800510:
    // VSLI<c>.<size> <Qd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '1', '0', '1', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VSLI_T1_ff800f10_ff800510(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xff800b50) == 0xef800340)
    // VQD<op><c>.<dt> <Qd>, <Dn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', 'op#1', '1', '1', 'N#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VQD_T2_ff800b50_ef800340(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xffb00c10) == 0xffb00800)
    // V<op><c>.8 <Dd>, <list>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'Vn#4', 'Vd#4', '1', '0', 'len#2', 'N#1', 'op#1', 'M#1', '0', 'Vm#4']
    return Instruction_V_T1_ffb00c10_ffb00800(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xfe7f0000) == 0xe85f0000)
    // LDRD<c> <Rt>, <Rt2>, [PC,#-0] - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '0', 'P#1', 'U#1', '1', '(0)', '1', '1', '1', '1', '1', 'Rt#4', 'Rt2#4', 'imm#8']
    return Instruction_LDRD_T1_fe7f0000_e85f0000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xff800d50) == 0xef800900)
    // VQD<op><c>.<dt> <Qd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', 'op#1', '1', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VQD_T1_ff800d50_ef800900(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xef800f50)
  {
  case 0xef800c40:
    // VQDMULH<c>.<dt> <Qd>, <Qn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', 'Q#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '1', '0', '0', 'N#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VQDMULH_T2_ef800f50_ef800c40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800d40:
    // VQRDMULH<c>.<dt> <Qd>, <Qn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', 'Q#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VQRDMULH_T2_ef800f50_ef800d40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800500:
    // VABAL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '1', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VABAL_T2_ef800f50_ef800500(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800700:
    // VABDL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '1', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VABDL_T2_ef800f50_ef800700(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800a40:
    // VMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '0', 'N#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VMULL_T2_ef800f50_ef800a40(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffb00300)
  {
  case 0xf9800000:
    // VST1<c>.<size> <list>, [<Rn>{@<align>}]{!} - ['support it block'] - ['1', '1', '1', '1', '1', '0', '0', '1', '1', 'D#1', '0', '0', 'Rn#4', 'Vd#4', 'size#2', '0', '0', 'index_align#4', 'Rm#4']
    return Instruction_VST1_T1_ffb00300_f9800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf9a00000:
    // VLD1<c>.<size> <list>, [<Rn>{@<align>}]{!} - ['support it block'] - ['1', '1', '1', '1', '1', '0', '0', '1', '1', 'D#1', '1', '0', 'Rn#4', 'Vd#4', 'size#2', '0', '0', 'index_align#4', 'Rm#4']
    return Instruction_VLD1_T1_ffb00300_f9a00000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfff00800)
  {
  case 0xf8000800:
    // STRB<c> <Rt>, [<Rn>, #<disp>]! - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', 'Rn#4', 'Rt#4', '1', 'P#1', 'U#1', 'W#1', 'imm#8']
    return Instruction_STRB_T3_fff00800_f8000800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8100800:
    // LDRB<c> <Rt>, [<Rn>, #<disp>]! - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '1', 'Rn#4', 'Rt#4', '1', 'P#1', 'U#1', 'W#1', 'imm#8']
    return Instruction_LDRB_T3_fff00800_f8100800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8200800:
    // STRH<c> <Rt>, [<Rn>, #<disp>]! - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '1', '0', 'Rn#4', 'Rt#4', '1', 'P#1', 'U#1', 'W#1', 'imm#8']
    return Instruction_STRH_T3_fff00800_f8200800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8300800:
    // LDRH<c> <Rt>, [<Rn>, #<disp>]! - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '1', '1', 'Rn#4', 'Rt#4', '1', 'P#1', 'U#1', 'W#1', 'imm#8']
    return Instruction_LDRH_T3_fff00800_f8300800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8400800:
    // STR<c> <Rt>, [<Rn>, #<disp>]! - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '1', '0', '0', 'Rn#4', 'Rt#4', '1', 'P#1', 'U#1', 'W#1', 'imm#8']
    return Instruction_STR_T4_fff00800_f8400800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8500800:
    // LDR<c> <Rt>, [<Rn>, #<disp>]! - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '1', '0', '1', 'Rn#4', 'Rt#4', '1', 'P#1', 'U#1', 'W#1', 'imm#8']
    return Instruction_LDR_T4_fff00800_f8500800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf9100800:
    // LDRSB<c> <Rt>, [<Rn>, #<disp>]! - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '1', '0', '0', '0', '1', 'Rn#4', 'Rt#4', '1', 'P#1', 'U#1', 'W#1', 'imm#8']
    return Instruction_LDRSB_T2_fff00800_f9100800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf9300800:
    // LDRSH<c> <Rt>, [<Rn>, #<disp>]! - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '1', '0', '0', '1', '1', 'Rn#4', 'Rt#4', '1', 'P#1', 'U#1', 'W#1', 'imm#8']
    return Instruction_LDRSH_T2_fff00800_f9300800(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffd08020)
  {
  case 0xf3000000:
    // SSAT<c> <Rd>, #<imm>, <Rn>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '1', '0', '(0)', '1', '1', '0', '0', 'sh#1', '0', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#2', '(0)', 'sat_imm#5']
    return Instruction_SSAT_T1_ffd08020_f3000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3800000:
    // USAT<c> <Rd>, #<imm5>, <Rn>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '1', '0', '(0)', '1', '1', '1', '0', 'sh#1', '0', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#2', '(0)', 'sat_imm#5']
    return Instruction_USAT_T1_ffd08020_f3800000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xefb80090) == 0xef800010)
    // VMOV<c>.<dt> <Qd>, #<imm> - ['support it block'] - ['1', '1', '1', 'imm#1', '1', '1', '1', '1', '1', 'D#1', '0', '0', '0', 'imm#3', 'Vd#4', 'cmode#4', '0', 'Q#1', 'op#1', '1', 'imm#4']
    return Instruction_VMOV_T1_efb80090_ef800010(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xef800b50) == 0xef800240)
    // V<op>L<c>.<dt> <Qd>, <Dn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', 'op#1', '1', '0', 'N#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_V_T2_ef800b50_ef800240(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xef800d50)
  {
  case 0xef800800:
    // V<op>L<c>.<dt> <Qd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', 'op#1', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_V_T2_ef800d50_ef800800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800c00:
    // VMULL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '1', 'op#1', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VMULL_T2_ef800d50_ef800c00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xef800e50)
  {
  case 0xef800840:
    // VMUL<c>.<dt> <Qd>, <Qn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', 'Q#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', 'F#1', 'N#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_VMUL_T1_ef800e50_ef800840(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800000:
    // VADDL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '0', 'op#1', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VADDL_T1_ef800e50_ef800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800200:
    // VSUBL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '1', 'op#1', 'N#1', '0', 'M#1', '0', 'Vm#4']
    return Instruction_VSUBL_T1_ef800e50_ef800200(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffd0a000)
  {
  case 0xe8800000:
    // STM<c>.W <Rn>{!}, <registers> - [] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '0', 'W#1', '0', 'Rn#4', '(0)', 'M#1', '(0)', 'register_list#13']
    return Instruction_STM_T2_ffd0a000_e8800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xe9000000:
    // STMDB<c> <Rn>{!}, <registers> - [] - ['1', '1', '1', '0', '1', '0', '0', '1', '0', '0', 'W#1', '0', 'Rn#4', '(0)', 'M#1', '(0)', 'register_list#13']
    return Instruction_STMDB_T1_ffd0a000_e9000000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xef800e90) == 0xef800e10)
    // VCVT<c>.<Td>.<Tm> <Qd>, <Qm>, #<fbits> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '1', '1', '1', 'op#1', '0', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VCVT_T1_ef800e90_ef800e10(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xef800f10)
  {
  case 0xef000010:
    // VQADD<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '0', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VQADD_T1_ef800f10_ef000010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000100:
    // VRHADD<c> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VRHADD_T1_ef800f10_ef000100(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000210:
    // VQSUB<c>.<type><size> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '1', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VQSUB_T1_ef800f10_ef000210(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000300:
    // VCGT<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VCGT_T1_ef800f10_ef000300(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000310:
    // VCGE<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '1', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VCGE_T1_ef800f10_ef000310(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000400:
    // VSHL<c>.I<size> <Qd>, <Qm>, <Qn> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VSHL_T1_ef800f10_ef000400(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000410:
    // VQSHL<c>.<type><size> <Qd>, <Qm>, <Qn> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VQSHL_T1_ef800f10_ef000410(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000500:
    // VRSHL<c>.<type><size> <Qd>, <Qm>, <Qn> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VRSHL_T1_ef800f10_ef000500(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000510:
    // VQRSHL<c>.<type><size> <Qd>, <Qm>, <Qn> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VQRSHL_T1_ef800f10_ef000510(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000700:
    // VABD<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VABD_T1_ef800f10_ef000700(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000710:
    // VABA<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VABA_T1_ef800f10_ef000710(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800010:
    // VSHR<c>.<type><size> <Qd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '0', '0', '0', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VSHR_T1_ef800f10_ef800010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800110:
    // VSRA<c>.<type><size> <Qd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '0', '0', '1', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VSRA_T1_ef800f10_ef800110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800210:
    // VRSHR<c>.<type><size> <Qd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '0', '1', '0', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VRSHR_T1_ef800f10_ef800210(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800310:
    // VRSRA<c>.<type><size> <Qd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '0', '1', '1', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VRSRA_T1_ef800f10_ef800310(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000900:
    // V<op><c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'op#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_V_T1_ef800f10_ef000900(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000910:
    // VMUL<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'op#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VMUL_T1_ef800f10_ef000910(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffe08000)
  {
  case 0xea000000:
    // AND{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '0', '0', 'S#1', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
    return Instruction_AND_T2_ffe08000_ea000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xea200000:
    // BIC{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '0', '1', 'S#1', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
    return Instruction_BIC_T2_ffe08000_ea200000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xea400000:
    // ORR{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '1', '0', 'S#1', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
    return Instruction_ORR_T2_ffe08000_ea400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xea600000:
    // ORN{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '1', '1', 'S#1', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
    return Instruction_ORN_T1_ffe08000_ea600000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xea800000:
    // EOR{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '1', '0', '0', 'S#1', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
    return Instruction_EOR_T2_ffe08000_ea800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeb000000:
    // ADD{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '1', '0', '0', '0', 'S#1', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
    return Instruction_ADD_T3_ffe08000_eb000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeb400000:
    // ADC{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '1', '0', '1', '0', 'S#1', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
    return Instruction_ADC_T2_ffe08000_eb400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeb600000:
    // SBC{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '1', '0', '1', '1', 'S#1', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
    return Instruction_SBC_T2_ffe08000_eb600000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeba00000:
    // SUB{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '1', '1', '0', '1', 'S#1', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
    return Instruction_SUB_T2_ffe08000_eba00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xebc00000:
    // RSB{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '1', '1', '1', '0', 'S#1', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
    return Instruction_RSB_T1_ffe08000_ebc00000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xef800d10) == 0xef000000)
    // VH<op><c> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', 'op#1', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VH_T1_ef800d10_ef000000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfff00000)
  {
  case 0xe8400000:
    // STREX<c> <Rd>, <Rt>, [<Rn>{, #<disp>}] - [] - ['1', '1', '1', '0', '1', '0', '0', '0', '0', '1', '0', '0', 'Rn#4', 'Rt#4', 'Rd#4', 'imm#8']
    return Instruction_STREX_T1_fff00000_e8400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xec400000:
    // MCRR<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm> - ['support it block', 'could_jmp'] - ['1', '1', '1', '0', '1', '1', '0', '0', '0', '1', '0', '0', 'Rt2#4', 'Rt#4', 'coproc#4', 'opc1#4', 'CRm#4']
    return Instruction_MCRR_T1_fff00000_ec400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xec500000:
    // MRRC<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm> - ['support it block', 'could_jmp'] - ['1', '1', '1', '0', '1', '1', '0', '0', '0', '1', '0', '1', 'Rt2#4', 'Rt#4', 'coproc#4', 'opc1#4', 'CRm#4']
    return Instruction_MRRC_T1_fff00000_ec500000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8800000:
    // STRB<c>.W <Rt>, [<Rn>, #<disp>] - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '1', '0', '0', '0', 'Rn#4', 'Rt#4', 'imm#12']
    return Instruction_STRB_T2_fff00000_f8800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8900000:
    // LDRB<c>.W <Rt>, [<Rn>{, #<disp>}] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '1', '0', '0', '1', 'Rn#4', 'Rt#4', 'imm#12']
    return Instruction_LDRB_T2_fff00000_f8900000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8a00000:
    // STRH<c>.W <Rt>, [<Rn>{, #<disp>}] - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '1', '0', '1', '0', 'Rn#4', 'Rt#4', 'imm#12']
    return Instruction_STRH_T2_fff00000_f8a00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8b00000:
    // LDRH<c>.W <Rt>, [<Rn>{, #<disp>}] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '1', '0', '1', '1', 'Rn#4', 'Rt#4', 'imm#12']
    return Instruction_LDRH_T2_fff00000_f8b00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8c00000:
    // STR<c>.W <Rt>, [<Rn>, #<disp>] - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '1', '1', '0', '0', 'Rn#4', 'Rt#4', 'imm#12']
    return Instruction_STR_T3_fff00000_f8c00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8d00000:
    // LDR<c>.W <Rt>, [<Rn>{, #<disp>}] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '1', '1', '0', '1', 'Rn#4', 'Rt#4', 'imm#12']
    return Instruction_LDR_T3_fff00000_f8d00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf9900000:
    // LDRSB<c> <Rt>, [<Rn>, #<disp>] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '1', '1', '0', '0', '1', 'Rn#4', 'Rt#4', 'imm#12']
    return Instruction_LDRSB_T1_fff00000_f9900000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf9b00000:
    // LDRSH<c> <Rt>, [<Rn>, #<disp>] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '1', '1', '0', '1', '1', 'Rn#4', 'Rt#4', 'imm#12']
    return Instruction_LDRSH_T1_fff00000_f9b00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfc400000:
    // MCRR2<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm> - ['support it block', 'could_jmp'] - ['1', '1', '1', '1', '1', '1', '0', '0', '0', '1', '0', '0', 'Rt2#4', 'Rt#4', 'coproc#4', 'opc1#4', 'CRm#4']
    return Instruction_MCRR2_T2_fff00000_fc400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfc500000:
    // MRRC2<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm> - ['support it block', 'could_jmp'] - ['1', '1', '1', '1', '1', '1', '0', '0', '0', '1', '0', '1', 'Rt2#4', 'Rt#4', 'coproc#4', 'opc1#4', 'CRm#4']
    return Instruction_MRRC2_T2_fff00000_fc500000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffb00010) == 0xefb00000)
    // VEXT<c>.8 <Qd>, <Qn>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'Vn#4', 'Vd#4', 'imm#4', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
    return Instruction_VEXT_T1_ffb00010_efb00000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfe100f00)
  {
  case 0xec000a00:
    // VSTM{mode}<c> <Rn>{!},  <list> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '0', 'Rn#4', 'Vd#4', '1', '0', '1', '0', 'imm#8']
    return Instruction_VSTM_T2_fe100f00_ec000a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xec000b00:
    // VSTM{mode}<c> <Rn>{!},  <list> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '0', 'Rn#4', 'Vd#4', '1', '0', '1', '1', 'imm#8']
    return Instruction_VSTM_T1_fe100f00_ec000b00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xec100a00:
    // VLDM{mode}<c> <Rn>{!},  <list> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', 'Rn#4', 'Vd#4', '1', '0', '1', '0', 'imm#8']
    return Instruction_VLDM_T2_fe100f00_ec100a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xec100b00:
    // VLDM{mode}<c> <Rn>{!},  <list> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', 'Rn#4', 'Vd#4', '1', '0', '1', '1', 'imm#8']
    return Instruction_VLDM_T1_fe100f00_ec100b00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfbf08000)
  {
  case 0xf2000000:
    // ADDW<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '1', '0', '0', '0', '0', '0', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_ADDW_T4_fbf08000_f2000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2400000:
    // MOVW<c> <Rd>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '1', '0', '0', '1', '0', '0', 'imm#4', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_MOVW_T3_fbf08000_f2400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2a00000:
    // SUBW<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '1', '0', '1', '0', '1', '0', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_SUBW_T4_fbf08000_f2a00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2c00000:
    // MOVT<c> <Rd>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '1', '0', '1', '1', '0', '0', 'imm#4', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_MOVT_T1_fbf08000_f2c00000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffd02000)
  {
  case 0xe8900000:
    // LDM<c>.W <Rn>{!}, <registers> - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '0', 'W#1', '1', 'Rn#4', 'P#1', 'M#1', '(0)', 'register_list#13']
    return Instruction_LDM_T2_ffd02000_e8900000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xe9100000:
    // LDMDB<c> <Rn>{!}, <registers> - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '0', '1', '0', '0', 'W#1', '1', 'Rn#4', 'P#1', 'M#1', '(0)', 'register_list#13']
    return Instruction_LDMDB_T1_ffd02000_e9100000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xef800f00)
  {
  case 0xef000600:
    // V<op><c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '0', 'N#1', 'Q#1', 'M#1', 'op#1', 'Vm#4']
    return Instruction_V_T1_ef800f00_ef000600(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000a00:
    // VP<op><c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '0', 'N#1', 'Q#1', 'M#1', 'op#1', 'Vm#4']
    return Instruction_VP_T1_ef800f00_ef000a00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode16 & 0x0000ff78) == 0x00004468)
    // ADD<c> <Rdm>, SP, <Rdm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '1', '0', '0', 'DM#1', '1', '1', '0', '1', 'Rdm#3']
    return Instruction_ADD_T1_0000ff78_00004468(rBinStrm, Offset, Opcode16, rInsn);
  switch (Opcode16 & 0x0000ff87)
  {
  case 0x00004485:
    // ADD<c> SP,<Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '1', '0', '0', '1', 'Rm#4', '1', '0', '1']
    return Instruction_ADD_T2_0000ff87_00004485(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004700:
    // BX<c> <Rm> - ['call'] - ['0', '1', '0', '0', '0', '1', '1', '1', '0', 'Rm#4', '(0)', '(0)', '(0)']
    return Instruction_BX_T1_0000ff87_00004700(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004780:
    // BLX<c> <Rm> - ['call'] - ['0', '1', '0', '0', '0', '1', '1', '1', '1', 'Rm#4', '(0)', '(0)', '(0)']
    return Instruction_BLX_T1_0000ff87_00004780(rBinStrm, Offset, Opcode16, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfe1f0000)
  {
  case 0xec1f0000:
    // LDC{L}<c> <coproc>, <CRd>, <label> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', '1', '1', '1', '1', 'CRd#4', 'coproc#4', 'imm#8']
    return Instruction_LDC_T1_fe1f0000_ec1f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfc1f0000:
    // LDC2{L}<c> <coproc>, <CRd>, <label> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', '1', '1', '1', '1', 'CRd#4', 'coproc#4', 'imm#8']
    return Instruction_LDC2_T2_fe1f0000_fc1f0000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xef800e10) == 0xef800610)
    // VQSHL{op}<c>.<type><size> <Qd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '1', '1', 'op#1', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
    return Instruction_VQSHL_T1_ef800e10_ef800610(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xef800a50) == 0xef800040)
    // V<op><c>.<dt> <Qd>, <Qn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', 'Q#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', 'op#1', '0', 'F#1', 'N#1', '1', 'M#1', '0', 'Vm#4']
    return Instruction_V_T1_ef800a50_ef800040(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffb00000)
  {
  case 0xf9000000:
    // VST1<c>.<size> <list>, [<Rn>{@<align>}]{!} - ['support it block'] - ['1', '1', '1', '1', '1', '0', '0', '1', '0', 'D#1', '0', '0', 'Rn#4', 'Vd#4', 'type#4', 'size#2', 'align#2', 'Rm#4']
    return Instruction_VST1_T1_ffb00000_f9000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf9200000:
    // VLD1<c>.<size> <list>, [<Rn>{@<align>}]{!} - ['support it block'] - ['1', '1', '1', '1', '1', '0', '0', '1', '0', 'D#1', '1', '0', 'Rn#4', 'Vd#4', 'type#4', 'size#2', 'align#2', 'Rm#4']
    return Instruction_VLD1_T1_ffb00000_f9200000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfbe08000)
  {
  case 0xf0000000:
    // AND{S}<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '0', '0', '0', '0', 'S#1', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_AND_T1_fbe08000_f0000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf0200000:
    // BIC{S}<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '0', '0', '0', '1', 'S#1', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_BIC_T1_fbe08000_f0200000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf0400000:
    // ORR{S}<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '0', '0', '1', '0', 'S#1', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_ORR_T1_fbe08000_f0400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf0600000:
    // ORN{S}<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '0', '0', '1', '1', 'S#1', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_ORN_T1_fbe08000_f0600000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf0800000:
    // EOR{S}<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '0', '1', '0', '0', 'S#1', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_EOR_T1_fbe08000_f0800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf1000000:
    // ADD{S}<c>.W <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '1', '0', '0', '0', 'S#1', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_ADD_T3_fbe08000_f1000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf1400000:
    // ADC{S}<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '1', '0', '1', '0', 'S#1', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_ADC_T1_fbe08000_f1400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf1600000:
    // SBC{S}<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '1', '0', '1', '1', 'S#1', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_SBC_T1_fbe08000_f1600000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf1a00000:
    // SUB{S}<c>.W <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '1', '1', '0', '1', 'S#1', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_SUB_T3_fbe08000_f1a00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf1c00000:
    // RSB{S}<c>.W <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '1', '1', '1', '0', 'S#1', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
    return Instruction_RSB_T2_fbe08000_f1c00000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode16 & 0x0000ffc0)
  {
  case 0x00000000:
    // MOVS <Rd>, <Rm> - ['could_jmp'] - ['0', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'Rm#3', 'Rd#3']
    return Instruction_MOVS_T2_0000ffc0_00000000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004000:
    // ANDS <Rdn>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '0', '0', '0', '0', 'Rm#3', 'Rdn#3']
    return Instruction_ANDS_T1_0000ffc0_00004000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004040:
    // EORS <Rdn>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '0', '0', '0', '1', 'Rm#3', 'Rdn#3']
    return Instruction_EORS_T1_0000ffc0_00004040(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004080:
    // LSLS <Rdn>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '0', '0', '1', '0', 'Rm#3', 'Rdn#3']
    return Instruction_LSLS_T1_0000ffc0_00004080(rBinStrm, Offset, Opcode16, rInsn);
  case 0x000040c0:
    // LSRS <Rdn>, <Rm> - ['support it block', 'could_jmp'] - ['0', '1', '0', '0', '0', '0', '0', '0', '1', '1', 'Rm#3', 'Rdn#3']
    return Instruction_LSRS_T1_0000ffc0_000040c0(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004100:
    // ASRS <Rdn>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '0', '1', '0', '0', 'Rm#3', 'Rdn#3']
    return Instruction_ASRS_T1_0000ffc0_00004100(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004140:
    // ADCS <Rdn>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '0', '1', '0', '1', 'Rm#3', 'Rdn#3']
    return Instruction_ADCS_T1_0000ffc0_00004140(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004180:
    // SBCS <Rdn>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '0', '1', '1', '0', 'Rm#3', 'Rdn#3']
    return Instruction_SBCS_T1_0000ffc0_00004180(rBinStrm, Offset, Opcode16, rInsn);
  case 0x000041c0:
    // RORS <Rdn>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '0', '1', '1', '1', 'Rm#3', 'Rdn#3']
    return Instruction_RORS_T1_0000ffc0_000041c0(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004200:
    // TST<c> <Rn>, <Rm> - [] - ['0', '1', '0', '0', '0', '0', '1', '0', '0', '0', 'Rm#3', 'Rn#3']
    return Instruction_TST_T1_0000ffc0_00004200(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004240:
    // RSBS <Rd>, <Rn>, #0 - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '1', '0', '0', '1', 'Rn#3', 'Rd#3']
    return Instruction_RSBS_T1_0000ffc0_00004240(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004280:
    // CMP<c> <Rn>, <Rm> - ['cond'] - ['0', '1', '0', '0', '0', '0', '1', '0', '1', '0', 'Rm#3', 'Rn#3']
    return Instruction_CMP_T1_0000ffc0_00004280(rBinStrm, Offset, Opcode16, rInsn);
  case 0x000042c0:
    // CMN<c> <Rn>, <Rm> - ['cond'] - ['0', '1', '0', '0', '0', '0', '1', '0', '1', '1', 'Rm#3', 'Rn#3']
    return Instruction_CMN_T1_0000ffc0_000042c0(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004300:
    // ORRS <Rdn>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '1', '1', '0', '0', 'Rm#3', 'Rdn#3']
    return Instruction_ORRS_T1_0000ffc0_00004300(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004340:
    // MULS <Rdm>, <Rn> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '1', '1', '0', '1', 'Rn#3', 'Rdm#3']
    return Instruction_MULS_T1_0000ffc0_00004340(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004380:
    // BICS <Rdn>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '1', '1', '1', '0', 'Rm#3', 'Rdn#3']
    return Instruction_BICS_T1_0000ffc0_00004380(rBinStrm, Offset, Opcode16, rInsn);
  case 0x000043c0:
    // MVNS <Rd>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '1', '1', '1', '1', 'Rm#3', 'Rd#3']
    return Instruction_MVNS_T1_0000ffc0_000043c0(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000b200:
    // SXTH<c> <Rd>, <Rm> - ['could_jmp'] - ['1', '0', '1', '1', '0', '0', '1', '0', '0', '0', 'Rm#3', 'Rd#3']
    return Instruction_SXTH_T1_0000ffc0_0000b200(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000b240:
    // SXTB<c> <Rd>, <Rm> - ['could_jmp'] - ['1', '0', '1', '1', '0', '0', '1', '0', '0', '1', 'Rm#3', 'Rd#3']
    return Instruction_SXTB_T1_0000ffc0_0000b240(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000b280:
    // UXTH<c> <Rd>, <Rm> - ['could_jmp'] - ['1', '0', '1', '1', '0', '0', '1', '0', '1', '0', 'Rm#3', 'Rd#3']
    return Instruction_UXTH_T1_0000ffc0_0000b280(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000b2c0:
    // UXTB<c> <Rd>, <Rm> - ['could_jmp'] - ['1', '0', '1', '1', '0', '0', '1', '0', '1', '1', 'Rm#3', 'Rd#3']
    return Instruction_UXTB_T1_0000ffc0_0000b2c0(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000ba00:
    // REV<c> <Rd>, <Rm> - ['could_jmp'] - ['1', '0', '1', '1', '1', '0', '1', '0', '0', '0', 'Rm#3', 'Rd#3']
    return Instruction_REV_T1_0000ffc0_0000ba00(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000ba40:
    // REV16<c> <Rd>, <Rm> - ['could_jmp'] - ['1', '0', '1', '1', '1', '0', '1', '0', '0', '1', 'Rm#3', 'Rd#3']
    return Instruction_REV16_T1_0000ffc0_0000ba40(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000bac0:
    // REVSH<c> <Rd>, <Rm> - ['could_jmp'] - ['1', '0', '1', '1', '1', '0', '1', '0', '1', '1', 'Rm#3', 'Rd#3']
    return Instruction_REVSH_T1_0000ffc0_0000bac0(rBinStrm, Offset, Opcode16, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xff100010)
  {
  case 0xee000010:
    // MCR<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['support it block', 'could_jmp'] - ['1', '1', '1', '0', '1', '1', '1', '0', 'opc1#3', '0', 'CRn#4', 'Rt#4', 'coproc#4', 'opc2#3', '1', 'CRm#4']
    return Instruction_MCR_T1_ff100010_ee000010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xee100010:
    // MRC<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['support it block', 'could_jmp'] - ['1', '1', '1', '0', '1', '1', '1', '0', 'opc1#3', '1', 'CRn#4', 'Rt#4', 'coproc#4', 'opc2#3', '1', 'CRm#4']
    return Instruction_MRC_T1_ff100010_ee100010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfe000010:
    // MCR2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['support it block', 'could_jmp'] - ['1', '1', '1', '1', '1', '1', '1', '0', 'opc1#3', '0', 'CRn#4', 'Rt#4', 'coproc#4', 'opc2#3', '1', 'CRm#4']
    return Instruction_MCR2_T2_ff100010_fe000010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfe100010:
    // MRC2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['support it block', 'could_jmp'] - ['1', '1', '1', '1', '1', '1', '1', '0', 'opc1#3', '1', 'CRn#4', 'Rt#4', 'coproc#4', 'opc2#3', '1', 'CRm#4']
    return Instruction_MRC2_T2_ff100010_fe100010(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xf800d001) == 0xf000c000)
    // BLX<c> <label> - ['thumb_branch_label'] - ['1', '1', '1', '1', '0', 'S#1', 'imm_h#10', '1', '1', 'J1#1', '0', 'J2#1', 'imm_l#10', '0']
    return Instruction_BLX_T2_f800d001_f000c000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfe500000)
  {
  case 0xe8400000:
    // STRD<c> <Rt>, <Rt2>, [<Rn>, #+/-<imm>]! - [] - ['1', '1', '1', '0', '1', '0', '0', 'P#1', 'U#1', '1', 'W#1', '0', 'Rn#4', 'Rt#4', 'Rt2#4', 'imm#8']
    return Instruction_STRD_T1_fe500000_e8400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xe8500000:
    // LDRD<c> <Rt>, <Rt2>, [<Rn>, #+/-<imm>]! - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '0', 'P#1', 'U#1', '1', 'W#1', '1', 'Rn#4', 'Rt#4', 'Rt2#4', 'imm#8']
    return Instruction_LDRD_T1_fe500000_e8500000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode16 & 0x0000ff80)
  {
  case 0x0000b000:
    // ADD<c> SP, SP, #<imm> - ['could_jmp'] - ['1', '0', '1', '1', '0', '0', '0', '0', '0', 'imm#7']
    return Instruction_ADD_T2_0000ff80_0000b000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000b080:
    // SUB<c> SP, SP, #<imm> - ['could_jmp'] - ['1', '0', '1', '1', '0', '0', '0', '0', '1', 'imm#7']
    return Instruction_SUB_T1_0000ff80_0000b080(rBinStrm, Offset, Opcode16, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xff000010)
  {
  case 0xee000000:
    // CDP<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', 'opc1#4', 'CRn#4', 'CRd#4', 'coproc#4', 'opc2#3', '0', 'CRm#4']
    return Instruction_CDP_T1_ff000010_ee000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfe000000:
    // CDP2<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '0', 'opc1#4', 'CRn#4', 'CRd#4', 'coproc#4', 'opc2#3', '0', 'CRm#4']
    return Instruction_CDP2_T2_ff000010_fe000000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfe100000)
  {
  case 0xec000000:
    // STC{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!} - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '0', 'Rn#4', 'CRd#4', 'coproc#4', 'imm#8']
    return Instruction_STC_T1_fe100000_ec000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xec100000:
    // LDC{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!} - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', 'Rn#4', 'CRd#4', 'coproc#4', 'imm#8']
    return Instruction_LDC_T1_fe100000_ec100000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfc000000:
    // STC2{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!} - ['support it block'] - ['1', '1', '1', '1', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '0', 'Rn#4', 'CRd#4', 'coproc#4', 'imm#8']
    return Instruction_STC2_T2_fe100000_fc000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfc100000:
    // LDC2{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!} - ['support it block'] - ['1', '1', '1', '1', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', 'Rn#4', 'CRd#4', 'coproc#4', 'imm#8']
    return Instruction_LDC2_T2_fe100000_fc100000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xf800d000)
  {
  case 0xf0008000:
    // B<c>.W <thumb_branch_label> - ['jmp'] - ['1', '1', '1', '1', '0', 'S#1', 'cond#4', 'imm#6', '1', '0', 'J1#1', '0', 'J2#1', 'imm#11']
    return Instruction_B_T3_f800d000_f0008000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf0009000:
    // B<c>.W <thumb_branch_label> - ['jmp'] - ['1', '1', '1', '1', '0', 'S#1', 'imm#10', '1', '0', 'J1#1', '1', 'J2#1', 'imm#11']
    return Instruction_B_T4_f800d000_f0009000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf000d000:
    // BL<c> <thumb_branch_label> - ['call'] - ['1', '1', '1', '1', '0', 'S#1', 'imm#10', '1', '1', 'J1#1', '1', 'J2#1', 'imm#11']
    return Instruction_BL_T1_f800d000_f000d000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode16 & 0x0000ff00)
  {
  case 0x00004400:
    // ADD<c> <Rdn>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '1', '0', '0', 'DN#1', 'Rm#4', 'Rdn#3']
    return Instruction_ADD_T2_0000ff00_00004400(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004500:
    // CMP<c> <Rn>, <Rm> - ['cond'] - ['0', '1', '0', '0', '0', '1', '0', '1', 'N#1', 'Rm#4', 'Rn#3']
    return Instruction_CMP_T2_0000ff00_00004500(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004600:
    // MOV<c> <Rd>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '1', '1', '0', 'D#1', 'Rm#4', 'Rd#3']
    return Instruction_MOV_T1_0000ff00_00004600(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000be00:
    // BKPT #<imm> - [] - ['1', '0', '1', '1', '1', '1', '1', '0', 'imm#8']
    return Instruction_BKPT_T1_0000ff00_0000be00(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000bf00:
    // IT{x{y{z}}} <firstcond> - [] - ['1', '0', '1', '1', '1', '1', '1', '1', 'firstcond#4', 'mask#4']
    return Instruction_IT_T1_0000ff00_0000bf00(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000df00:
    // SVC<c> #<imm> - ['syscall'] - ['1', '1', '0', '1', '1', '1', '1', '1', 'imm#8']
    return Instruction_SVC_T1_0000ff00_0000df00(rBinStrm, Offset, Opcode16, rInsn);
  default:
    break;
  }
  switch (Opcode16 & 0x0000fe00)
  {
  case 0x00001800:
    // ADDS <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['0', '0', '0', '1', '1', '0', '0', 'Rm#3', 'Rn#3', 'Rd#3']
    return Instruction_ADDS_T1_0000fe00_00001800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00001a00:
    // SUBS <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['0', '0', '0', '1', '1', '0', '1', 'Rm#3', 'Rn#3', 'Rd#3']
    return Instruction_SUBS_T1_0000fe00_00001a00(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00001c00:
    // ADDS <Rd>, <Rn>, #<imm> - [] - ['0', '0', '0', '1', '1', '1', '0', 'imm#3', 'Rn#3', 'Rd#3']
    return Instruction_ADDS_T1_0000fe00_00001c00(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00001e00:
    // SUBS <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['0', '0', '0', '1', '1', '1', '1', 'imm#3', 'Rn#3', 'Rd#3']
    return Instruction_SUBS_T1_0000fe00_00001e00(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00005000:
    // STR<c> <Rt>, [<Rn>, <Rm>] - [] - ['0', '1', '0', '1', '0', '0', '0', 'Rm#3', 'Rn#3', 'Rt#3']
    return Instruction_STR_T1_0000fe00_00005000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00005200:
    // STRH<c> <Rt>, [<Rn>, <Rm>] - [] - ['0', '1', '0', '1', '0', '0', '1', 'Rm#3', 'Rn#3', 'Rt#3']
    return Instruction_STRH_T1_0000fe00_00005200(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00005400:
    // STRB<c> <Rt>, [<Rn>, <Rm>] - [] - ['0', '1', '0', '1', '0', '1', '0', 'Rm#3', 'Rn#3', 'Rt#3']
    return Instruction_STRB_T1_0000fe00_00005400(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00005600:
    // LDRSB<c> <Rt>, [<Rn>, <Rm>] - ['could_jmp'] - ['0', '1', '0', '1', '0', '1', '1', 'Rm#3', 'Rn#3', 'Rt#3']
    return Instruction_LDRSB_T1_0000fe00_00005600(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00005800:
    // LDR<c> <Rt>, [<Rn>, <Rm>] - ['could_jmp'] - ['0', '1', '0', '1', '1', '0', '0', 'Rm#3', 'Rn#3', 'Rt#3']
    return Instruction_LDR_T1_0000fe00_00005800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00005a00:
    // LDRH<c> <Rt>, [<Rn>, <Rm>] - ['could_jmp'] - ['0', '1', '0', '1', '1', '0', '1', 'Rm#3', 'Rn#3', 'Rt#3']
    return Instruction_LDRH_T1_0000fe00_00005a00(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00005c00:
    // LDRB<c> <Rt>, [<Rn>, <Rm>] - ['could_jmp'] - ['0', '1', '0', '1', '1', '1', '0', 'Rm#3', 'Rn#3', 'Rt#3']
    return Instruction_LDRB_T1_0000fe00_00005c00(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00005e00:
    // LDRSH<c> <Rt>, [<Rn>, <Rm>] - ['could_jmp'] - ['0', '1', '0', '1', '1', '1', '1', 'Rm#3', 'Rn#3', 'Rt#3']
    return Instruction_LDRSH_T1_0000fe00_00005e00(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000b400:
    // PUSH<c> <registers> - ['could_jmp'] - ['1', '0', '1', '1', '0', '1', '0', 'M#1', 'register_list#8']
    return Instruction_PUSH_T1_0000fe00_0000b400(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000bc00:
    // POP<c> <registers> - ['could_ret'] - ['1', '0', '1', '1', '1', '1', '0', 'P#1', 'register_list#8']
    return Instruction_POP_T1_0000fe00_0000bc00(rBinStrm, Offset, Opcode16, rInsn);
  default:
    break;
  }
  if ((Opcode16 & 0x0000f500) == 0x0000b100)
    // CB{N}Z <Rn>, <label> - ['cond', 'jmp'] - ['1', '0', '1', '1', 'op#1', '0', 'imm#1', '1', 'imm#5', 'Rn#3']
    return Instruction_CB_T1_0000f500_0000b100(rBinStrm, Offset, Opcode16, rInsn);
  switch (Opcode16 & 0x0000f800)
  {
  case 0x00000000:
    // LSLS <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['0', '0', '0', '0', '0', 'imm#5', 'Rm#3', 'Rd#3']
    return Instruction_LSLS_T1_0000f800_00000000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00000800:
    // LSRS <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['0', '0', '0', '0', '1', 'imm#5', 'Rm#3', 'Rd#3']
    return Instruction_LSRS_T1_0000f800_00000800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00001000:
    // ASRS <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['0', '0', '0', '1', '0', 'imm#5', 'Rm#3', 'Rd#3']
    return Instruction_ASRS_T1_0000f800_00001000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00002000:
    // MOVS <Rd>, #<imm> - ['could_jmp'] - ['0', '0', '1', '0', '0', 'Rd#3', 'imm#8']
    return Instruction_MOVS_T1_0000f800_00002000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00002800:
    // CMP<c> <Rn>, #<imm> - ['cond'] - ['0', '0', '1', '0', '1', 'Rn#3', 'imm#8']
    return Instruction_CMP_T1_0000f800_00002800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00003000:
    // ADDS <Rdn>, #<imm> - ['could_jmp'] - ['0', '0', '1', '1', '0', 'Rdn#3', 'imm#8']
    return Instruction_ADDS_T2_0000f800_00003000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00003800:
    // SUBS <Rdn>, #<imm> - ['could_jmp'] - ['0', '0', '1', '1', '1', 'Rdn#3', 'imm#8']
    return Instruction_SUBS_T2_0000f800_00003800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004800:
    // LDR<c> <Rt>, <label> - ['could_jmp'] - ['0', '1', '0', '0', '1', 'Rt#3', 'imm#8']
    return Instruction_LDR_T1_0000f800_00004800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00006000:
    // STR<c> <Rt>, [<Rn>{, #<disp>}] - [] - ['0', '1', '1', '0', '0', 'imm#5', 'Rn#3', 'Rt#3']
    return Instruction_STR_T1_0000f800_00006000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00006800:
    // LDR<c> <Rt>, [<Rn>{, #<disp>}] - ['could_jmp'] - ['0', '1', '1', '0', '1', 'imm#5', 'Rn#3', 'Rt#3']
    return Instruction_LDR_T1_0000f800_00006800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00007000:
    // STRB<c> <Rt>, [<Rn>, #<imm5>] - [] - ['0', '1', '1', '1', '0', 'imm#5', 'Rn#3', 'Rt#3']
    return Instruction_STRB_T1_0000f800_00007000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00007800:
    // LDRB<c> <Rt>, [<Rn>{, #<disp>}] - ['could_jmp'] - ['0', '1', '1', '1', '1', 'imm#5', 'Rn#3', 'Rt#3']
    return Instruction_LDRB_T1_0000f800_00007800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00008000:
    // STRH<c> <Rt>, [<Rn>{, #<disp>}] - [] - ['1', '0', '0', '0', '0', 'imm#5', 'Rn#3', 'Rt#3']
    return Instruction_STRH_T1_0000f800_00008000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00008800:
    // LDRH<c> <Rt>, [<Rn>{, #<disp>}] - ['could_jmp'] - ['1', '0', '0', '0', '1', 'imm#5', 'Rn#3', 'Rt#3']
    return Instruction_LDRH_T1_0000f800_00008800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00009000:
    // STR<c> <Rt>, [SP, #<imm>] - [] - ['1', '0', '0', '1', '0', 'Rt#3', 'imm#8']
    return Instruction_STR_T2_0000f800_00009000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00009800:
    // LDR<c> <Rt>, [SP{,#<disp>}] - ['could_jmp'] - ['1', '0', '0', '1', '1', 'Rt#3', 'imm#8']
    return Instruction_LDR_T2_0000f800_00009800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000a000:
    // ADR<c> <Rd>, <label> - ['could_jmp'] - ['1', '0', '1', '0', '0', 'Rd#3', 'imm#8']
    return Instruction_ADR_T1_0000f800_0000a000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000a800:
    // ADD<c> <Rd>, SP, #<imm> - ['could_jmp'] - ['1', '0', '1', '0', '1', 'Rd#3', 'imm#8']
    return Instruction_ADD_T1_0000f800_0000a800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000c000:
    // STM<c> <Rn>!,<registers> - [] - ['1', '1', '0', '0', '0', 'Rn#3', 'register_list#8']
    return Instruction_STM_T1_0000f800_0000c000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000c800:
    // LDM<c> <Rn>, <registers> - ['could_jmp'] - ['1', '1', '0', '0', '1', 'Rn#3', 'register_list#8']
    return Instruction_LDM_T1_0000f800_0000c800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000e000:
    // B<c> <thumb_branch_label> - ['jmp'] - ['1', '1', '1', '0', '0', 'imm#11']
    return Instruction_B_T2_0000f800_0000e000(rBinStrm, Offset, Opcode16, rInsn);
  default:
    break;
  }
  if ((Opcode16 & 0x0000f000) == 0x0000d000)
    // B<c> <thumb_branch_label> - ['jmp'] - ['1', '1', '0', '1', 'cond#4', 'imm#8']
    return Instruction_B_T1_0000f000_0000d000(rBinStrm, Offset, Opcode16, rInsn);
  return false;
}
// SETEND <endian_specifier> - [] - ['1', '1', '1', '1', '0', '0', '0', '1', '0', '0', '0', '0', '(0)', '(0)', '(0)', '1', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', 'E#1', '(0)', '0', '0', '0', '0', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_SETEND_A1_fffffdff_f1010000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SETEND <endian_specifier>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Setend);
    rInsn.SetMnemonic("setend");
    // FIXME: not_implemented: "operand <endian_specifier>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VAND<c> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', '0', '0', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VAND_A1_ffb00f10_f2000110(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VAND<c> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vand);
    rInsn.SetMnemonic("vand");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VBIC<c> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', '0', '1', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VBIC_A1_ffb00f10_f2100110(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VBIC<c> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vbic);
    rInsn.SetMnemonic("vbic");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VADD<c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VADD_A1_ffa00f10_f2000d00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VADD<c>.F32 <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vadd);
    rInsn.SetMnemonic("vadd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCEQ<c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCEQ_A2_ffa00f10_f2000e00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCEQ<c>.F32 <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vceq);
    rInsn.SetMnemonic("vceq");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRECPS<c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VRECPS_A1_ffa00f10_f2000f10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRECPS<c>.F32 <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrecps);
    rInsn.SetMnemonic("vrecp");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VORR<c> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', '1', '0', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VORR_A1_ffb00f10_f2200110(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VORR<c> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vorr);
    rInsn.SetMnemonic("vorr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VORN<c> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', '1', '1', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VORN_A1_ffb00f10_f2300110(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VORN<c> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vorn);
    rInsn.SetMnemonic("vorn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSUB<c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', '1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VSUB_A1_ffa00f10_f2200d00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSUB<c>.F32 <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vsub);
    rInsn.SetMnemonic("vsub");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRSQRTS<c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', '1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VRSQRTS_A1_ffa00f10_f2200f10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRSQRTS<c>.F32 <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrsqrts);
    rInsn.SetMnemonic("vrsqrt");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op><c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', 'op#1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_V_A1_ff800f10_f2000d10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op><c>.F32 <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op><c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', 'op#1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_V_A1_ff800f10_f2000f00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op><c>.F32 <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VADD<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VADD_A1_ff800f10_f2000800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VADD<c>.<dt> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vadd);
    rInsn.SetMnemonic("vadd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VTST<c>.<size> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VTST_A1_ff800f10_f2000810(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VTST<c>.<size> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vtst);
    rInsn.SetMnemonic("vtst");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQDMULH<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQDMULH_A1_ff800f10_f2000b00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQDMULH<c>.<dt> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqdmulh);
    rInsn.SetMnemonic("vqdmulh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VPADD<c>.<dt> - [] - ['1', '1', '1', '1', '0', '0', '1', '0', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VPADD_A1_ff800f10_f2000b10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VPADD<c>.<dt>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vpadd);
    rInsn.SetMnemonic("vpadd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VEXT<c>.8 <Dd>, <Dn>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '1', 'D#1', '1', '1', 'Vn#4', 'Vd#4', 'imm#4', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VEXT_A1_ffb00010_f2b00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VEXT<c>.8 <Dd>, <Dn>, <Dm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vext);
    rInsn.SetMnemonic("vext");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".8");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<8, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSHL<c>.I<size> <Dd>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '0', '1', 'D#1', 'imm#6', 'Vd#4', '0', '1', '0', '1', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VSHL_A1_ff800f10_f2800510(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSHL<c>.I<size> <Dd>, <Dm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vshl);
    rInsn.SetMnemonic("vshl");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".I");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSHRN<c>.I<size> <Dd>, <Qm>, #<imm> - [] - ['1', '1', '1', '1', '0', '0', '1', '0', '1', 'D#1', 'imm#6', 'Vd#4', '1', '0', '0', '0', '0', '0', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VSHRN_A1_ff800fd0_f2800810(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSHRN<c>.I<size> <Dd>, <Qm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vshrn);
    rInsn.SetMnemonic("vshrn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".I");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRSHRN<c>.I<size> <Dd>, <Qm>, #<imm> - [] - ['1', '1', '1', '1', '0', '0', '1', '0', '1', 'D#1', 'imm#6', 'Vd#4', '1', '0', '0', '0', '0', '1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VRSHRN_A1_ff800fd0_f2800850(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRSHRN<c>.I<size> <Dd>, <Qm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrshrn);
    rInsn.SetMnemonic("vrshrn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".I");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VADDHN<c>.<dt> <Dd>, <Qn>, <Qm> - [] - ['1', '1', '1', '1', '0', '0', '1', '0', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VADDHN_A1_ff800f50_f2800400(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VADDHN<c>.<dt> <Dd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vaddhn);
    rInsn.SetMnemonic("vaddhn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSUBHN<c>.<dt> <Dd>, <Qn>, <Qm> - [] - ['1', '1', '1', '1', '0', '0', '1', '0', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VSUBHN_A1_ff800f50_f2800600(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSUBHN<c>.<dt> <Dd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vsubhn);
    rInsn.SetMnemonic("vsubhn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQD<op><c>.<dt> <Qd>, <Dn>, <Dm[x]> - [] - ['1', '1', '1', '1', '0', '0', '1', '0', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', 'op#1', '1', '1', 'N#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQD_A2_ff800b50_f2800340(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQD<op><c>.<dt> <Qd>, <Dn>, <Dm[x]>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqd);
    rInsn.SetMnemonic("vqd");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Dm[x]>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]> - [] - ['1', '1', '1', '1', '0', '0', '1', '0', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '1', 'N#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQDMULL_A2_ff800f50_f2800b40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqdmull);
    rInsn.SetMnemonic("vqdmull");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Dm[x]>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQD<op><c>.<dt> <Qd>, <Dn>, <Dm> - [] - ['1', '1', '1', '1', '0', '0', '1', '0', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', 'op#1', '1', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQD_A1_ff800d50_f2800900(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQD<op><c>.<dt> <Qd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqd);
    rInsn.SetMnemonic("vqd");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm> - [] - ['1', '1', '1', '1', '0', '0', '1', '0', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQDMULL_A1_ff800f50_f2800d00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqdmull);
    rInsn.SetMnemonic("vqdmull");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VEOR<c> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', '0', '0', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VEOR_A1_ffb00f10_f3000110(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VEOR<c> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Veor);
    rInsn.SetMnemonic("veor");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VPADD<c>.F32 - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VPADD_A1_ffa00f10_f3000d00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VPADD<c>.F32");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vpadd);
    rInsn.SetMnemonic("vpadd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMUL<c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VMUL_A1_ffa00f10_f3000d10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMUL<c>.F32 <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmul);
    rInsn.SetMnemonic("vmul");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCGE<c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCGE_A2_ffa00f10_f3000e00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCGE<c>.F32 <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcge);
    rInsn.SetMnemonic("vcge");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VABD<c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', '1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VABD_A1_ffa00f10_f3200d00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VABD<c>.F32 <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vabd);
    rInsn.SetMnemonic("vabd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCGT<c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', '1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCGT_A2_ffa00f10_f3200e00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCGT<c>.F32 <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcgt);
    rInsn.SetMnemonic("vcgt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op><c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', 'op#1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_V_A1_ff800f10_f3000e10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op><c>.F32 <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VP<op><c>.F32 <Dd>, <Dn>, <Dm> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', 'op#1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VP_A1_ff800f10_f3000f00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VP<op><c>.F32 <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vp);
    rInsn.SetMnemonic("vp");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op><c> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', 'op#2', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_V_A1_ff800f10_f3000110(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op><c> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSUB<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VSUB_A1_ff800f10_f3000800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSUB<c>.<dt> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vsub);
    rInsn.SetMnemonic("vsub");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCEQ<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VCEQ_A1_ff800f10_f3000810(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCEQ<c>.<dt> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vceq);
    rInsn.SetMnemonic("vceq");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQRDMULH<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQRDMULH_A1_ff800f10_f3000b00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQRDMULH<c>.<dt> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqrdmulh);
    rInsn.SetMnemonic("vqrdmulh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op><c>.8 <Dd>, <list>, <Dm> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'Vn#4', 'Vd#4', '1', '0', 'len#2', 'N#1', 'op#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_V_A1_ffb00c10_f3b00800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op><c>.8 <Dd>, <list>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".8");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <list>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VDUP<c>.<size> <Dd>, <Dm[x]> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'imm#4', 'Vd#4', '1', '1', '0', '0', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VDUP_A1_ffb00f90_f3b00c00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VDUP<c>.<size> <Dd>, <Dm[x]>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vdup);
    rInsn.SetMnemonic("vdup");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Dm[x]>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VREV<n><c>.<size> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '0', '0', 'op2#2', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VREV_A1_ffb30e10_f3b00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VREV<n><c>.<size> <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrev);
    rInsn.SetMnemonic("vrev");
    // FIXME: not_implemented: "field <n>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VPADDL<c>.<dt> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '0', '1', '0', 'op#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VPADDL_A1_ffb30f10_f3b00200(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VPADDL<c>.<dt> <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vpaddl);
    rInsn.SetMnemonic("vpaddl");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCLS<c>.<dt> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '0', '0', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCLS_A1_ffb30f90_f3b00400(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCLS<c>.<dt> <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcls);
    rInsn.SetMnemonic("vcl");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCLZ<c>.<dt> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '0', '0', '1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCLZ_A1_ffb30f90_f3b00480(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCLZ<c>.<dt> <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vclz);
    rInsn.SetMnemonic("vclz");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCNT<c>.8 <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '0', '1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCNT_A1_ffb30f90_f3b00500(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCNT<c>.8 <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcnt);
    rInsn.SetMnemonic("vcnt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".8");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMVN<c> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '0', '1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VMVN_A1_ffb30f90_f3b00580(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMVN<c> <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmvn);
    rInsn.SetMnemonic("vmvn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VPADAL<c>.<dt> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '1', '0', 'op#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VPADAL_A1_ffb30f10_f3b00600(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VPADAL<c>.<dt> <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vpadal);
    rInsn.SetMnemonic("vpadal");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQABS<c>.<dt> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '1', '1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQABS_A1_ffb30f90_f3b00700(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQABS<c>.<dt> <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqabs);
    rInsn.SetMnemonic("vqab");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQNEG<c>.<dt> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '1', '1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQNEG_A1_ffb30f90_f3b00780(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQNEG<c>.<dt> <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqneg);
    rInsn.SetMnemonic("vqneg");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCGT<c>.<dt> <Dd>, <Dm>, #0 - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '0', '0', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCGT_A1_ffb30b90_f3b10000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCGT<c>.<dt> <Dd>, <Dm>, #0");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcgt);
    rInsn.SetMnemonic("vcgt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, 0x0));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCGE<c>.<dt> <Dd>, <Dm>, #0 - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '0', '0', '1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCGE_A1_ffb30b90_f3b10080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCGE<c>.<dt> <Dd>, <Dm>, #0");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcge);
    rInsn.SetMnemonic("vcge");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, 0x0));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCEQ<c>.<dt> <Dd>, <Dm>, #0 - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '0', '1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCEQ_A1_ffb30b90_f3b10100(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCEQ<c>.<dt> <Dd>, <Dm>, #0");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vceq);
    rInsn.SetMnemonic("vceq");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, 0x0));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCLE<c>.<dt> <Dd>, <Dm>, #0 - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '0', '1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCLE_A1_ffb30b90_f3b10180(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCLE<c>.<dt> <Dd>, <Dm>, #0");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcle);
    rInsn.SetMnemonic("vcle");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, 0x0));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCLT<c>.<dt> <Dd>, <Dm>, #0 - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '1', '0', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCLT_A1_ffb30b90_f3b10200(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCLT<c>.<dt> <Dd>, <Dm>, #0");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vclt);
    rInsn.SetMnemonic("vclt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, 0x0));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VABS<c>.<dt> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '1', '1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VABS_A1_ffb30b90_f3b10300(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VABS<c>.<dt> <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vabs);
    rInsn.SetMnemonic("vab");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VNEG<c>.<dt> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '1', '1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VNEG_A1_ffb30b90_f3b10380(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VNEG<c>.<dt> <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vneg);
    rInsn.SetMnemonic("vneg");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSWP<c> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '0', '0', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VSWP_A1_ffb30f90_f3b20000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSWP<c> <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vswp);
    rInsn.SetMnemonic("vswp");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VTRN<c>.<size> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '0', '0', '1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VTRN_A1_ffb30f90_f3b20080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VTRN<c>.<size> <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vtrn);
    rInsn.SetMnemonic("vtrn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VUZP<c>.<size> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '0', '1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VUZP_A1_ffb30f90_f3b20100(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VUZP<c>.<size> <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vuzp);
    rInsn.SetMnemonic("vuzp");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VZIP<c>.<size> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '0', '1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VZIP_A1_ffb30f90_f3b20180(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VZIP<c>.<size> <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vzip);
    rInsn.SetMnemonic("vzip");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMOVN<c>.<dt> <Dd>, <Qm> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '1', '0', '0', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VMOVN_A1_ffb30fd0_f3b20200(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMOVN<c>.<dt> <Dd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmovn);
    rInsn.SetMnemonic("vmovn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQMOV{op}N<c>.<type><size> <Dd>, <Qm> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '1', '0', 'op2#2', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQMOV_A1_ffb30f10_f3b20200(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQMOV{op}N<c>.<type><size> <Dd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqmov);
    rInsn.SetMnemonic("vqmov");
    // FIXME: not_implemented: "field {op}";
    rInsn.AddMnemonicSuffix("N");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSHLL<c>.<type><size> <Qd>, <Dm>, #<imm> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '1', '1', '0', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VSHLL_A2_ffb30fd0_f3b20300(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSHLL<c>.<type><size> <Qd>, <Dm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vshll);
    rInsn.SetMnemonic("vshll");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "field: <esize>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCVT<c>.F16.F32 <Dd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '1', '1', 'op#1', '0', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCVT_A1_ffb30ed0_f3b20600(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCVT<c>.F16.F32 <Dd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcvt);
    rInsn.SetMnemonic("vcvt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F16");
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRECPE<c>.<dt> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '1', 'Vd#4', '0', '1', '0', 'F#1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VRECPE_A1_ffb30e90_f3b30400(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRECPE<c>.<dt> <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrecpe);
    rInsn.SetMnemonic("vrecpe");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRSQRTE<c>.<dt> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '1', 'Vd#4', '0', '1', '0', 'F#1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VRSQRTE_A1_ffb30e90_f3b30480(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRSQRTE<c>.<dt> <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrsqrte);
    rInsn.SetMnemonic("vrsqrte");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCVT<c>.<Td>.<Tm> <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '1', 'Vd#4', '0', '1', '1', 'op#2', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCVT_A1_ffb30e10_f3b30600(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCVT<c>.<Td>.<Tm> <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcvt);
    rInsn.SetMnemonic("vcvt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<7, 8>(Opcode)) /* op */)
    {
    case 0x00000002:
        rInsn.AddMnemonicSuffix(".S32.F32");
      break;

    case 0x00000003:
        rInsn.AddMnemonicSuffix(".U32.F32");
      break;

    case 0x00000000:
        rInsn.AddMnemonicSuffix(".F32.S32");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix(".F32.U32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSRI<c>.<size> <Dd>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '1', '0', '0', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VSRI_A1_ff800f10_f3800410(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSRI<c>.<size> <Dd>, <Dm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vsri);
    rInsn.SetMnemonic("vsri");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSLI<c>.<size> <Dd>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '1', '0', '1', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VSLI_A1_ff800f10_f3800510(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSLI<c>.<size> <Dd>, <Dm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vsli);
    rInsn.SetMnemonic("vsli");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRADDHN<c>.<dt> <Dd>, <Qn>, <Qm> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VRADDHN_A1_ff800f50_f3800400(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRADDHN<c>.<dt> <Dd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vraddhn);
    rInsn.SetMnemonic("vraddhn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRSUBHN<c>.<dt> <Dd>, <Qn>, <Qm> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VRSUBHN_A1_ff800f50_f3800600(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRSUBHN<c>.<dt> <Dd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrsubhn);
    rInsn.SetMnemonic("vrsubhn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op><c>.<dt> <Dd>, <Dn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'Q#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', 'op#1', '0', 'F#1', 'N#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_V_A1_fe800a50_f2800040(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op><c>.<dt> <Dd>, <Dn>, <Dm[x]>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Dm[x]>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMUL<c>.<dt> <Dd>, <Dn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'Q#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', 'F#1', 'N#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VMUL_A1_fe800e50_f2800840(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMUL<c>.<dt> <Dd>, <Dn>, <Dm[x]>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmul);
    rInsn.SetMnemonic("vmul");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Dm[x]>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQDMULH<c>.<dt> <Dd>, <Dn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'Q#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '1', '0', '0', 'N#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQDMULH_A2_fe800f50_f2800c40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQDMULH<c>.<dt> <Dd>, <Dn>, <Dm[x]>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqdmulh);
    rInsn.SetMnemonic("vqdmulh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Dm[x]>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQRDMULH<c>.<dt> <Dd>, <Dn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'Q#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQRDMULH_A2_fe800f50_f2800d40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQRDMULH<c>.<dt> <Dd>, <Dn>, <Dm[x]>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqrdmulh);
    rInsn.SetMnemonic("vqrdmulh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Dm[x]>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQADD<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '0', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VQADD_A1_fe800f10_f2000010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQADD<c>.<dt> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqadd);
    rInsn.SetMnemonic("vqadd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRHADD<c> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VRHADD_A1_fe800f10_f2000100(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRHADD<c> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrhadd);
    rInsn.SetMnemonic("vrhadd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQSUB<c>.<type><size> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '1', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VQSUB_A1_fe800f10_f2000210(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQSUB<c>.<type><size> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqsub);
    rInsn.SetMnemonic("vqsub");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCGT<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCGT_A1_fe800f10_f2000300(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCGT<c>.<dt> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcgt);
    rInsn.SetMnemonic("vcgt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCGE<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '1', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VCGE_A1_fe800f10_f2000310(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCGE<c>.<dt> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcge);
    rInsn.SetMnemonic("vcge");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VH<op><c> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', 'op#1', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VH_A1_fe800d10_f2000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VH<op><c> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vh);
    rInsn.SetMnemonic("vh");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSHL<c>.I<size> <Dd>, <Dm>, <Dn> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VSHL_A1_fe800f10_f2000400(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSHL<c>.I<size> <Dd>, <Dm>, <Dn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vshl);
    rInsn.SetMnemonic("vshl");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".I");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQSHL<c>.<type><size> <Dd>, <Dm>, <Dn> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VQSHL_A1_fe800f10_f2000410(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQSHL<c>.<type><size> <Dd>, <Dm>, <Dn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqshl);
    rInsn.SetMnemonic("vqshl");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRSHL<c>.<type><size> <Dd>, <Dm>, <Dn> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VRSHL_A1_fe800f10_f2000500(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRSHL<c>.<type><size> <Dd>, <Dm>, <Dn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrshl);
    rInsn.SetMnemonic("vrshl");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQRSHL<c>.<type><size> <Dd>, <Dm>, <Dn> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VQRSHL_A1_fe800f10_f2000510(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQRSHL<c>.<type><size> <Dd>, <Dm>, <Dn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqrshl);
    rInsn.SetMnemonic("vqrshl");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op><c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '0', 'N#1', 'Q#1', 'M#1', 'op#1', 'Vm#4']
bool ArmArchitecture::Instruction_V_A1_fe800f00_f2000600(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op><c>.<dt> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VABD<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VABD_A1_fe800f10_f2000700(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VABD<c>.<dt> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vabd);
    rInsn.SetMnemonic("vabd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VABA<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VABA_A1_fe800f10_f2000710(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VABA<c>.<dt> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vaba);
    rInsn.SetMnemonic("vaba");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VP<op><c>.<dt> <Dd>, <Dn>, <Dm> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '0', 'N#1', 'Q#1', 'M#1', 'op#1', 'Vm#4']
bool ArmArchitecture::Instruction_VP_A1_fe800f00_f2000a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VP<op><c>.<dt> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vp);
    rInsn.SetMnemonic("vp");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMOVL<c>.<dt> <Qd>, <Dm> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'imm#3', '0', '0', '0', 'Vd#4', '1', '0', '1', '0', '0', '0', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VMOVL_A1_fe870fd0_f2800a10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMOVL<c>.<dt> <Qd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmovl);
    rInsn.SetMnemonic("vmovl");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field: <imm>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSHR<c>.<type><size> <Dd>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '0', '0', '0', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VSHR_A1_fe800f10_f2800010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSHR<c>.<type><size> <Dd>, <Dm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vshr);
    rInsn.SetMnemonic("vshr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSRA<c>.<type><size> <Dd>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '0', '0', '1', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VSRA_A1_fe800f10_f2800110(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSRA<c>.<type><size> <Dd>, <Dm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vsra);
    rInsn.SetMnemonic("vsra");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRSHR<c>.<type><size> <Dd>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '0', '1', '0', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VRSHR_A1_fe800f10_f2800210(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRSHR<c>.<type><size> <Dd>, <Dm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrshr);
    rInsn.SetMnemonic("vrshr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRSRA<c>.<type><size> <Dd>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '0', '1', '1', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VRSRA_A1_fe800f10_f2800310(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRSRA<c>.<type><size> <Dd>, <Dm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrsra);
    rInsn.SetMnemonic("vrsra");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQSHL{op}<c>.<type><size> <Dd>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '1', '1', 'op#1', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VQSHL_A1_fe800e10_f2800610(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQSHL{op}<c>.<type><size> <Dd>, <Dm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqshl);
    rInsn.SetMnemonic("vqshl");
    // FIXME: not_implemented: "field {op}";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQSHR{op}N<c>.<type><size> <Dd>, <Qm>, #<imm> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'imm#6', 'Vd#4', '1', '0', '0', 'op#1', '0', '0', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VQSHR_A1_fe800ed0_f2800810(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQSHR{op}N<c>.<type><size> <Dd>, <Qm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqshr);
    rInsn.SetMnemonic("vqshr");
    // FIXME: not_implemented: "field {op}";
    rInsn.AddMnemonicSuffix("N");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQRSHR{op}N<c>.<type><size> <Dd>, <Qm>, #<imm> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'imm#6', 'Vd#4', '1', '0', '0', 'op#1', '0', '1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VQRSHR_A1_fe800ed0_f2800850(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQRSHR{op}N<c>.<type><size> <Dd>, <Qm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqrshr);
    rInsn.SetMnemonic("vqrshr");
    // FIXME: not_implemented: "field {op}";
    rInsn.AddMnemonicSuffix("N");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSHLL<c>.<type><size> <Qd>, <Dm>, #<imm> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'imm#6', 'Vd#4', '1', '0', '1', '0', '0', '0', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VSHLL_A1_fe800fd0_f2800a10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSHLL<c>.<type><size> <Qd>, <Dm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vshll);
    rInsn.SetMnemonic("vshll");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCVT<c>.<Td>.<Tm> <Dd>, <Dm>, #<fbits> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'imm#6', 'Vd#4', '1', '1', '1', 'op#1', '0', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VCVT_A1_fe800e90_f2800e10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCVT<c>.<Td>.<Tm> <Dd>, <Dm>, #<fbits>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcvt);
    rInsn.SetMnemonic("vcvt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBit<8>(Opcode)) /* op */)
    {
    case 0x00000002:
        rInsn.AddMnemonicSuffix(".S32.F32");
      break;

    case 0x00000003:
        rInsn.AddMnemonicSuffix(".U32.F32");
      break;

    case 0x00000000:
        rInsn.AddMnemonicSuffix(".F32.S32");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix(".F32.U32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand #<fbits>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VADDW<c>.<dt> <Qd>, <Qn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '0', 'op#1', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VADDW_A1_fe800e50_f2800000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VADDW<c>.<dt> <Qd>, <Qn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vaddw);
    rInsn.SetMnemonic("vaddw");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSUBW<c>.<dt> {<Qd>,} <Qn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '1', 'op#1', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VSUBW_A1_fe800e50_f2800200(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSUBW<c>.<dt> {<Qd>,} <Qn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vsubw);
    rInsn.SetMnemonic("vsubw");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    // FIXME: not_implemented: "operand {<Qd>,}";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VABAL<c>.<dt> <Qd>, <Dn>, <Dm> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '1', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VABAL_A2_fe800f50_f2800500(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VABAL<c>.<dt> <Qd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vabal);
    rInsn.SetMnemonic("vabal");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VABDL<c>.<dt> <Qd>, <Dn>, <Dm> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '1', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VABDL_A2_fe800f50_f2800700(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VABDL<c>.<dt> <Qd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vabdl);
    rInsn.SetMnemonic("vabdl");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op>L<c>.<dt> <Qd>, <Dn>, <Dm[x]> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', 'op#1', '1', '0', 'N#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_V_A2_fe800b50_f2800240(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op>L<c>.<dt> <Qd>, <Dn>, <Dm[x]>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddMnemonicSuffix("L");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Dm[x]>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '0', 'N#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VMULL_A2_fe800f50_f2800a40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmull);
    rInsn.SetMnemonic("vmull");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Dm[x]>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op>L<c>.<dt> <Qd>, <Dn>, <Dm> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', 'op#1', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_V_A2_fe800d50_f2800800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op>L<c>.<dt> <Qd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddMnemonicSuffix("L");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMULL<c>.<dt> <Qd>, <Dn>, <Dm> - [] - ['1', '1', '1', '1', '0', '0', '1', 'U#1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '1', 'op#1', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VMULL_A2_fe800d50_f2800c00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMULL<c>.<dt> <Qd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmull);
    rInsn.SetMnemonic("vmull");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VORR<c>.<dt> <Dd>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'imm#1', '1', 'D#1', '0', '0', '0', 'imm#3', 'Vd#4', 'cmode#4', '0', 'Q#1', '0', '1', 'imm#4']
bool ArmArchitecture::Instruction_VORR_A1_feb800b0_f2800010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VORR<c>.<dt> <Dd>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vorr);
    rInsn.SetMnemonic("vorr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field: <imm>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 3>(Opcode) | ExtractBits<16, 18>(Opcode) << 4 | ExtractBit<24>(Opcode) << 7) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VBIC<c>.<dt> <Dd>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'imm#1', '1', 'D#1', '0', '0', '0', 'imm#3', 'Vd#4', 'cmode#4', '0', 'Q#1', '1', '1', 'imm#4']
bool ArmArchitecture::Instruction_VBIC_A1_feb800b0_f2800030(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VBIC<c>.<dt> <Dd>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vbic);
    rInsn.SetMnemonic("vbic");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field: <imm>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 3>(Opcode) | ExtractBits<16, 18>(Opcode) << 4 | ExtractBit<24>(Opcode) << 7) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMOV<c>.<dt> <Dd>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'imm#1', '1', 'D#1', '0', '0', '0', 'imm#3', 'Vd#4', 'cmode#4', '0', 'Q#1', 'op#1', '1', 'imm#4']
bool ArmArchitecture::Instruction_VMOV_A1_feb80090_f2800010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMOV<c>.<dt> <Dd>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmov);
    rInsn.SetMnemonic("vmov");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field: <imm>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 3>(Opcode) | ExtractBits<16, 18>(Opcode) << 4 | ExtractBit<24>(Opcode) << 7) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op><c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'op#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_V_A1_fe800f10_f2000900(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op><c>.<dt> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMUL<c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '0', '0', '1', 'op#1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VMUL_A1_fe800f10_f2000910(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMUL<c>.<dt> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmul);
    rInsn.SetMnemonic("vmul");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VST1<c>.<size> <list>, [<Rn>{@<align>}], <Rm> - ['support it block', 'support it block'] - ['1', '1', '1', '1', '0', '1', '0', '0', '0', 'D#1', '0', '0', 'Rn#4', 'Vd#4', 'type#4', 'size#2', 'align#2', 'Rm#4']
bool ArmArchitecture::Instruction_VST1_A1_ffb00000_f4000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VST1<c>.<size> <list>, [<Rn>{@<align>}], <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vst1);
    rInsn.SetMnemonic("vst1");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    // FIXME: not_implemented: "operand <list>";
    // FIXME: not_implemented: "operand [<Rn>{@<align>}]";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VLD1<c>.<size> <list>, [<Rn>{@<align>}], <Rm> - ['support it block', 'support it block'] - ['1', '1', '1', '1', '0', '1', '0', '0', '0', 'D#1', '1', '0', 'Rn#4', 'Vd#4', 'type#4', 'size#2', 'align#2', 'Rm#4']
bool ArmArchitecture::Instruction_VLD1_A1_ffb00000_f4200000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VLD1<c>.<size> <list>, [<Rn>{@<align>}], <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vld1);
    rInsn.SetMnemonic("vld1");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    // FIXME: not_implemented: "operand <list>";
    // FIXME: not_implemented: "operand [<Rn>{@<align>}]";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VST1<c>.<size> <list>, [<Rn>{@<align>}], <Rm> - ['support it block'] - ['1', '1', '1', '1', '0', '1', '0', '0', '1', 'D#1', '0', '0', 'Rn#4', 'Vd#4', 'size#2', '0', '0', 'index_align#4', 'Rm#4']
bool ArmArchitecture::Instruction_VST1_A1_ffb00300_f4800000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VST1<c>.<size> <list>, [<Rn>{@<align>}], <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vst1);
    rInsn.SetMnemonic("vst1");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    // FIXME: not_implemented: "operand <list>";
    // FIXME: not_implemented: "operand [<Rn>{@<align>}]";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VLD1<c>.<size> <list>, [<Rn>{@<align>}], <Rm> - ['support it block'] - ['1', '1', '1', '1', '0', '1', '0', '0', '1', 'D#1', '1', '0', 'Rn#4', 'Vd#4', '1', '1', '0', '0', 'size#2', 'T#1', 'a#1', 'Rm#4']
bool ArmArchitecture::Instruction_VLD1_A1_ffb00f00_f4a00c00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VLD1<c>.<size> <list>, [<Rn>{@<align>}], <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vld1);
    rInsn.SetMnemonic("vld1");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    // FIXME: not_implemented: "operand <list>";
    // FIXME: not_implemented: "operand [<Rn>{@<align>}]";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VLD1<c>.<size> <list>, [<Rn>{@<align>}], <Rm> - ['support it block'] - ['1', '1', '1', '1', '0', '1', '0', '0', '1', 'D#1', '1', '0', 'Rn#4', 'Vd#4', 'size#2', '0', '0', 'index_align#4', 'Rm#4']
bool ArmArchitecture::Instruction_VLD1_A1_ffb00300_f4a00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VLD1<c>.<size> <list>, [<Rn>{@<align>}], <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vld1);
    rInsn.SetMnemonic("vld1");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    // FIXME: not_implemented: "operand <list>";
    // FIXME: not_implemented: "operand [<Rn>{@<align>}]";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// PLI [PC,#-0] - [] - ['1', '1', '1', '1', '0', '1', '0', '0', 'U#1', '1', '0', '1', 'Rn#4', '(1)', '(1)', '(1)', '(1)', 'imm#12']
bool ArmArchitecture::Instruction_PLI_A1_ff70f000_f450f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("PLI [PC,#-0]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Pli);
    rInsn.SetMnemonic("pli");
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CLREX - [] - ['1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '1', '1', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '0', '0', '1', '(1)', '(1)', '(1)', '(1)']
bool ArmArchitecture::Instruction_CLREX_A1_ffffffff_f57ff01f(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CLREX");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Clrex);
    rInsn.SetMnemonic("clrex");
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// DSB #<option> - [] - ['1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '1', '1', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '1', '0', '0', 'option#4']
bool ArmArchitecture::Instruction_DSB_A1_fffffff0_f57ff040(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("DSB #<option>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Dsb);
    rInsn.SetMnemonic("dsb");
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 3>(Opcode)) /* option */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// DMB #<option> - [] - ['1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '1', '1', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '1', '0', '1', 'option#4']
bool ArmArchitecture::Instruction_DMB_A1_fffffff0_f57ff050(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("DMB #<option>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Dmb);
    rInsn.SetMnemonic("dmb");
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 3>(Opcode)) /* option */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ISB #<option> - [] - ['1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '1', '1', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '1', '1', '0', 'option#4']
bool ArmArchitecture::Instruction_ISB_A1_fffffff0_f57ff060(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ISB #<option>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Isb);
    rInsn.SetMnemonic("isb");
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 3>(Opcode)) /* option */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// PLD [PC,#-0] - [] - ['1', '1', '1', '1', '0', '1', '0', '1', 'U#1', '(1)', '0', '1', '1', '1', '1', '1', '(1)', '(1)', '(1)', '(1)', 'imm#12']
bool ArmArchitecture::Instruction_PLD_A1_ff7ff000_f55ff000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("PLD [PC,#-0]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Pld);
    rInsn.SetMnemonic("pld");
    rInsn.AddOperand(Expr::MakeMem(64, nullptr, Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// PLI [<Rn>,+/-<Rm>{,<shift>}] - [] - ['1', '1', '1', '1', '0', '1', '1', '0', 'U#1', '1', '0', '1', 'Rn#4', '(1)', '(1)', '(1)', '(1)', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_PLI_A1_ff70f010_f650f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("PLI [<Rn>,+/-<Rm>{,<shift>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Pli);
    rInsn.SetMnemonic("pli");
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BLX <arm_branch_label> - ['call'] - ['1', '1', '1', '1', '1', '0', '1', 'H#1', 'imm#24']
bool ArmArchitecture::Instruction_BLX_A2_fe000000_fa000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BLX <arm_branch_label>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Blx);
    rInsn.SubType() |= Instruction::CallType;
    rInsn.SetMnemonic("blx");
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo) + (ExtractBits<0, 23>(Opcode)) << 2 | 0);
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MCRR2<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '1', '0', '0', '0', '1', '0', '0', 'Rt2#4', 'Rt#4', 'coproc#4', 'opc1#4', 'CRm#4']
bool ArmArchitecture::Instruction_MCRR2_A2_fff00000_fc400000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MCRR2<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mcrr2);
    rInsn.SetMnemonic("mcrr2");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <opc1>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rt2 */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <CRm>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MRRC2<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '1', '0', '0', '0', '1', '0', '1', 'Rt2#4', 'Rt#4', 'coproc#4', 'opc1#4', 'CRm#4']
bool ArmArchitecture::Instruction_MRRC2_A2_fff00000_fc500000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MRRC2<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mrrc2);
    rInsn.SetMnemonic("mrrc2");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <opc>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rt2 */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <CRm>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STC2{L}<c> <coproc>, <CRd>, [<Rn>],<option> - ['support it block', 'support it block'] - ['1', '1', '1', '1', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '0', 'Rn#4', 'CRd#4', 'coproc#4', 'imm#8']
bool ArmArchitecture::Instruction_STC2_A2_fe100000_fc000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STC2{L}<c> <coproc>, <CRd>, [<Rn>],<option>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Stc2);
    rInsn.SetMnemonic("stc2");
    if ((ExtractBit<22>(Opcode)) /* D */)
        rInsn.AddMnemonicSuffix("L");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <CRd>";
    // FIXME: not_implemented: "operand [<Rn>],<option>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDC2{L}<c> <coproc>, <CRd>, [PC],<option> - ['support it block', 'support it block'] - ['1', '1', '1', '1', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', '1', '1', '1', '1', 'CRd#4', 'coproc#4', 'imm#8']
bool ArmArchitecture::Instruction_LDC2_A2_fe1f0000_fc1f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDC2{L}<c> <coproc>, <CRd>, [PC],<option>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldc2);
    rInsn.SetMnemonic("ldc2");
    if ((ExtractBit<22>(Opcode)) /* D */)
        rInsn.AddMnemonicSuffix("L");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <CRd>";
    // FIXME: not_implemented: "operand [PC],<option>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDC2{L}<c> <coproc>, <CRd>, [<Rn>],<option> - ['support it block', 'support it block'] - ['1', '1', '1', '1', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', 'Rn#4', 'CRd#4', 'coproc#4', 'imm#8']
bool ArmArchitecture::Instruction_LDC2_A2_fe100000_fc100000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDC2{L}<c> <coproc>, <CRd>, [<Rn>],<option>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldc2);
    rInsn.SetMnemonic("ldc2");
    if ((ExtractBit<22>(Opcode)) /* D */)
        rInsn.AddMnemonicSuffix("L");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <CRd>";
    // FIXME: not_implemented: "operand [<Rn>],<option>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MCR2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '1', '1', '0', 'opc1#3', '0', 'CRn#4', 'Rt#4', 'coproc#4', 'opc2#3', '1', 'CRm#4']
bool ArmArchitecture::Instruction_MCR2_A2_ff100010_fe000010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MCR2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mcr2);
    rInsn.SetMnemonic("mcr2");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <opc1>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <CRn>";
    // FIXME: not_implemented: "operand <CRm>{,<opc2>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MRC2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '1', '1', '0', 'opc1#3', '1', 'CRn#4', 'Rt#4', 'coproc#4', 'opc2#3', '1', 'CRm#4']
bool ArmArchitecture::Instruction_MRC2_A2_ff100010_fe100010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MRC2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mrc2);
    rInsn.SetMnemonic("mrc2");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <opc1>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <CRn>";
    // FIXME: not_implemented: "operand <CRm>{,<opc2>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CDP2<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '0', 'opc1#4', 'CRn#4', 'CRd#4', 'coproc#4', 'opc2#3', '0', 'CRm#4']
bool ArmArchitecture::Instruction_CDP2_A2_ff000010_fe000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CDP2<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Cdp2);
    rInsn.SetMnemonic("cdp2");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <opc1>";
    // FIXME: not_implemented: "operand <CRd>";
    // FIXME: not_implemented: "operand <CRn>";
    // FIXME: not_implemented: "operand <CRm>";
    // FIXME: not_implemented: "operand <opc2>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRD<c> <Rt>, <Rt2>, [PC,#-0] - ['could_jmp'] - ['cond#4', '0', '0', '0', '(1)', 'U#1', '1', '(0)', '0', '1', '1', '1', '1', 'Rt#4', 'imm_h#4', '1', '1', '0', '1', 'imm_l#4']
bool ArmArchitecture::Instruction_LDRD_A1_0f7f00f0_014f00d0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRD<c> <Rt>, <Rt2>, [PC,#-0]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrd);
    rInsn.SetMnemonic("ldrd");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */ + 1), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(64, nullptr, Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRH<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['cond#4', '0', '0', '0', '(1)', 'U#1', '1', '(0)', '1', '1', '1', '1', '1', 'Rt#4', 'imm_h#4', '1', '0', '1', '1', 'imm_l#4']
bool ArmArchitecture::Instruction_LDRH_A1_0f7f00f0_015f00b0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRH<c> <Rt>, [PC,#-0]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrh);
    rInsn.SetMnemonic("ldrh");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSB<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['cond#4', '0', '0', '0', '(1)', 'U#1', '1', '(0)', '1', '1', '1', '1', '1', 'Rt#4', 'imm_h#4', '1', '1', '0', '1', 'imm_l#4']
bool ArmArchitecture::Instruction_LDRSB_A1_0f7f00f0_015f00d0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSB<c> <Rt>, [PC,#-0]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrsb);
    rInsn.SetMnemonic("ldrsb");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSH<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['cond#4', '0', '0', '0', '(1)', 'U#1', '1', '(0)', '1', '1', '1', '1', '1', 'Rt#4', 'imm_h#4', '1', '1', '1', '1', 'imm_l#4']
bool ArmArchitecture::Instruction_LDRSH_A1_0f7f00f0_015f00f0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSH<c> <Rt>, [PC,#-0]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrsh);
    rInsn.SetMnemonic("ldrsh");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MUL{S}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '0', '0', 'S#1', 'Rd#4', '(0)', '(0)', '(0)', '(0)', 'Rm#4', '1', '0', '0', '1', 'Rn#4']
bool ArmArchitecture::Instruction_MUL_A1_0fe0f0f0_00000090(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MUL{S}<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mul);
    rInsn.SetMnemonic("mul");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// AND{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '0', '0', 'S#1', 'Rn#4', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
bool ArmArchitecture::Instruction_AND_A1_0fe00090_00000010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("AND{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_And);
    rInsn.SetMnemonic("and");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeRegShiftWithSources(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rs */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// AND{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '0', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_AND_A1_0fe00010_00000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("AND{S}<c> <Rd>, <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_And);
    rInsn.SetMnemonic("and");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MLA{S}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '0', '1', 'S#1', 'Rd#4', 'Ra#4', 'Rm#4', '1', '0', '0', '1', 'Rn#4']
bool ArmArchitecture::Instruction_MLA_A1_0fe000f0_00200090(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MLA{S}<c> <Rd>, <Rn>, <Rm>, <Ra>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mla);
    rInsn.SetMnemonic("mla");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Ra */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// EOR{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '0', '1', 'S#1', 'Rn#4', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
bool ArmArchitecture::Instruction_EOR_A1_0fe00090_00200010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("EOR{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Eor);
    rInsn.SetMnemonic("eor");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeRegShiftWithSources(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rs */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// EOR{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '0', '1', 'S#1', 'Rn#4', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_EOR_A1_0fe00010_00200000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("EOR{S}<c> <Rd>, <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Eor);
    rInsn.SetMnemonic("eor");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UMAAL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '1', '0', '0', 'RdHi#4', 'RdLo#4', 'Rm#4', '1', '0', '0', '1', 'Rn#4']
bool ArmArchitecture::Instruction_UMAAL_A1_0ff000f0_00400090(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UMAAL<c> <RdLo>, <RdHi>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Umaal);
    rInsn.SetMnemonic("umaal");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    // FIXME: not_implemented: "operand <RdLo>";
    // FIXME: not_implemented: "operand <RdHi>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SUB{S}<c> <Rd>, SP, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '1', '0', 'S#1', '1', '1', '0', '1', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_SUB_A1_0fef0010_004d0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SUB{S}<c> <Rd>, SP, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sub);
    rInsn.SetMnemonic("sub");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Sp, &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SUB{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '1', '0', 'S#1', 'Rn#4', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SUB_A1_0fe00090_00400010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SUB{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sub);
    rInsn.SetMnemonic("sub");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeRegShiftWithSources(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rs */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SUB{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '1', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_SUB_A1_0fe00010_00400000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SUB{S}<c> <Rd>, <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sub);
    rInsn.SetMnemonic("sub");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MLS<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '1', '1', '0', 'Rd#4', 'Ra#4', 'Rm#4', '1', '0', '0', '1', 'Rn#4']
bool ArmArchitecture::Instruction_MLS_A1_0ff000f0_00600090(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MLS<c> <Rd>, <Rn>, <Rm>, <Ra>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mls);
    rInsn.SetMnemonic("ml");
    rInsn.AddMnemonicSuffix("s");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Ra */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// RSB{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '1', '1', 'S#1', 'Rn#4', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
bool ArmArchitecture::Instruction_RSB_A1_0fe00090_00600010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("RSB{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Rsb);
    rInsn.SetMnemonic("rsb");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeRegShiftWithSources(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rs */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// RSB{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '0', '1', '1', 'S#1', 'Rn#4', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_RSB_A1_0fe00010_00600000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("RSB{S}<c> <Rd>, <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Rsb);
    rInsn.SetMnemonic("rsb");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADD{S}<c> <Rd>, SP, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '0', '0', 'S#1', '1', '1', '0', '1', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_ADD_A1_0fef0010_008d0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADD{S}<c> <Rd>, SP, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Add);
    rInsn.SetMnemonic("add");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Sp, &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UMULL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '0', '0', 'S#1', 'RdHi#4', 'RdLo#4', 'Rm#4', '1', '0', '0', '1', 'Rn#4']
bool ArmArchitecture::Instruction_UMULL_A1_0fe000f0_00800090(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UMULL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Umull);
    rInsn.SetMnemonic("umull");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    // FIXME: not_implemented: "operand <RdLo>";
    // FIXME: not_implemented: "operand <RdHi>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADD{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '0', '0', 'S#1', 'Rn#4', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
bool ArmArchitecture::Instruction_ADD_A1_0fe00090_00800010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADD{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Add);
    rInsn.SetMnemonic("add");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeRegShiftWithSources(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rs */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADD{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '0', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_ADD_A1_0fe00010_00800000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADD{S}<c> <Rd>, <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Add);
    rInsn.SetMnemonic("add");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UMLAL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '0', '1', 'S#1', 'RdHi#4', 'RdLo#4', 'Rm#4', '1', '0', '0', '1', 'Rn#4']
bool ArmArchitecture::Instruction_UMLAL_A1_0fe000f0_00a00090(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UMLAL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Umlal);
    rInsn.SetMnemonic("umlal");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    // FIXME: not_implemented: "operand <RdLo>";
    // FIXME: not_implemented: "operand <RdHi>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '0', '1', 'S#1', 'Rn#4', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
bool ArmArchitecture::Instruction_ADC_A1_0fe00090_00a00010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Adc);
    rInsn.SetMnemonic("adc");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeRegShiftWithSources(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rs */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADC{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '0', '1', 'S#1', 'Rn#4', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_ADC_A1_0fe00010_00a00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADC{S}<c> <Rd>, <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Adc);
    rInsn.SetMnemonic("adc");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMULL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '1', '0', 'S#1', 'RdHi#4', 'RdLo#4', 'Rm#4', '1', '0', '0', '1', 'Rn#4']
bool ArmArchitecture::Instruction_SMULL_A1_0fe000f0_00c00090(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMULL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smull);
    rInsn.SetMnemonic("smull");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    // FIXME: not_implemented: "operand <RdLo>";
    // FIXME: not_implemented: "operand <RdHi>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SBC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '1', '0', 'S#1', 'Rn#4', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SBC_A1_0fe00090_00c00010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SBC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sbc);
    rInsn.SetMnemonic("sbc");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeRegShiftWithSources(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rs */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SBC{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '1', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_SBC_A1_0fe00010_00c00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SBC{S}<c> <Rd>, <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sbc);
    rInsn.SetMnemonic("sbc");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMLAL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '1', '1', 'S#1', 'RdHi#4', 'RdLo#4', 'Rm#4', '1', '0', '0', '1', 'Rn#4']
bool ArmArchitecture::Instruction_SMLAL_A1_0fe000f0_00e00090(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMLAL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smlal);
    rInsn.SetMnemonic("smlal");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    // FIXME: not_implemented: "operand <RdLo>";
    // FIXME: not_implemented: "operand <RdHi>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// RSC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '1', '1', 'S#1', 'Rn#4', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
bool ArmArchitecture::Instruction_RSC_A1_0fe00090_00e00010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("RSC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Rsc);
    rInsn.SetMnemonic("rsc");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeRegShiftWithSources(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rs */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// RSC{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', '1', '1', '1', 'S#1', 'Rn#4', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_RSC_A1_0fe00010_00e00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("RSC{S}<c> <Rd>, <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Rsc);
    rInsn.SetMnemonic("rsc");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRHT<c> <Rt>, [<Rn>], +/-<Rm> - [] - ['cond#4', '0', '0', '0', '0', 'U#1', '0', '1', '0', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '0', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_STRHT_A2_0f700ff0_002000b0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRHT<c> <Rt>, [<Rn>], +/-<Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strht);
    rInsn.SetMnemonic("strht");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
    if ((ExtractBit<23>(Opcode)) /* U */)
      rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));

    else
      rInsn.AddOperand(-Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));

  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRHT<c> <Rt>, [<Rn>], +/-<Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', 'U#1', '0', '1', '1', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '0', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_LDRHT_A2_0f700ff0_003000b0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRHT<c> <Rt>, [<Rn>], +/-<Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrht);
    rInsn.SetMnemonic("ldrht");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
    if ((ExtractBit<23>(Opcode)) /* U */)
      rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));

    else
      rInsn.AddOperand(-Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));

  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSBT<c> <Rt>, [<Rn>], +/-<Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', 'U#1', '0', '1', '1', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '1', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_LDRSBT_A2_0f700ff0_003000d0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSBT<c> <Rt>, [<Rn>], +/-<Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrsbt);
    rInsn.SetMnemonic("ldrsbt");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
    if ((ExtractBit<23>(Opcode)) /* U */)
      rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));

    else
      rInsn.AddOperand(-Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));

  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSHT<c> <Rt>, [<Rn>], +/-<Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', 'U#1', '0', '1', '1', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_LDRSHT_A2_0f700ff0_003000f0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSHT<c> <Rt>, [<Rn>], +/-<Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrsht);
    rInsn.SetMnemonic("ldrsht");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
    if ((ExtractBit<23>(Opcode)) /* U */)
      rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));

    else
      rInsn.AddOperand(-Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));

  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRHT<c> <Rt>, [<Rn>] {,#<disp>} - [] - ['cond#4', '0', '0', '0', '0', 'U#1', '1', '1', '0', 'Rn#4', 'Rt#4', 'imm_h#4', '1', '0', '1', '1', 'imm_l#4']
bool ArmArchitecture::Instruction_STRHT_A1_0f7000f0_006000b0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRHT<c> <Rt>, [<Rn>] {,#<disp>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strht);
    rInsn.SetMnemonic("strht");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
    // FIXME: not_implemented: "operand {,#<disp>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRHT<c> <Rt>, [<Rn>] {,#<disp>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', 'U#1', '1', '1', '1', 'Rn#4', 'Rt#4', 'imm_h#4', '1', '0', '1', '1', 'imm_l#4']
bool ArmArchitecture::Instruction_LDRHT_A1_0f7000f0_007000b0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRHT<c> <Rt>, [<Rn>] {,#<disp>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrht);
    rInsn.SetMnemonic("ldrht");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
    // FIXME: not_implemented: "operand {,#<disp>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSBT<c> <Rt>, [<Rn>] {,#<disp>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', 'U#1', '1', '1', '1', 'Rn#4', 'Rt#4', 'imm_h#4', '1', '1', '0', '1', 'imm_l#4']
bool ArmArchitecture::Instruction_LDRSBT_A1_0f7000f0_007000d0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSBT<c> <Rt>, [<Rn>] {,#<disp>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrsbt);
    rInsn.SetMnemonic("ldrsbt");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
    // FIXME: not_implemented: "operand {,#<disp>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSHT<c> <Rt>, [<Rn>] {,#<disp>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '0', 'U#1', '1', '1', '1', 'Rn#4', 'Rt#4', 'imm_h#4', '1', '1', '1', '1', 'imm_l#4']
bool ArmArchitecture::Instruction_LDRSHT_A1_0f7000f0_007000f0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSHT<c> <Rt>, [<Rn>] {,#<disp>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrsht);
    rInsn.SetMnemonic("ldrsht");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
    // FIXME: not_implemented: "operand {,#<disp>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MRS<c> <Rd>, <spec_reg> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '0', '0', '0', '(1)', '(1)', '(1)', '(1)', 'Rd#4', '(0)', '(0)', '(0)', '(0)', '0', '0', '0', '0', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_MRS_A1_0fff0fff_010f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MRS<c> <Rd>, <spec_reg>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mrs);
    rInsn.SetMnemonic("mr");
    rInsn.AddMnemonicSuffix("s");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <spec_reg>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMLA<x><y><c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '0', '0', '0', 'Rd#4', 'Ra#4', 'Rm#4', '1', 'M#1', 'N#1', '0', 'Rn#4']
bool ArmArchitecture::Instruction_SMLA_A1_0ff00090_01000080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMLA<x><y><c> <Rd>, <Rn>, <Rm>, <Ra>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smla);
    rInsn.SetMnemonic("smla");
    if ((ExtractBit<5>(Opcode)) /* N */)
      rInsn.AddMnemonicSuffix("t");

    else
      rInsn.AddMnemonicSuffix("b");

    if ((ExtractBit<6>(Opcode)) /* M */)
      rInsn.AddMnemonicSuffix("t");

    else
      rInsn.AddMnemonicSuffix("b");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Ra */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// QADD<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '0', '0', '0', 'Rn#4', 'Rd#4', '(0)', '(0)', '(0)', '(0)', '0', '1', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_QADD_A1_0ff00ff0_01000050(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("QADD<c> <Rd>, <Rm>, <Rn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Qadd);
    rInsn.SetMnemonic("qadd");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// TST<c> <Rn>, <Rm>, <type> <Rs> - [] - ['cond#4', '0', '0', '0', '1', '0', '0', '0', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
bool ArmArchitecture::Instruction_TST_A1_0ff0f090_01100010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("TST<c> <Rn>, <Rm>, <type> <Rs>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Tst);
    rInsn.SetMnemonic("tst");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeRegShiftWithSources(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rs */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// TST<c> <Rn>, <Rm>{,<shift>} - [] - ['cond#4', '0', '0', '0', '1', '0', '0', '0', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_TST_A1_0ff0f010_01100000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("TST<c> <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Tst);
    rInsn.SetMnemonic("tst");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BX<c> Rm - ['call'] - ['cond#4', '0', '0', '0', '1', '0', '0', '1', '0', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '0', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_BX_A1_0ffffff0_012fff10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BX<c> Rm");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Bx);
    rInsn.SubType() |= Instruction::CallType;
    rInsn.SetMnemonic("bx");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BXJ<c> <Rm> - ['call'] - ['cond#4', '0', '0', '0', '1', '0', '0', '1', '0', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '0', 'Rm#4']
bool ArmArchitecture::Instruction_BXJ_A1_0ffffff0_012fff20(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BXJ<c> <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Bxj);
    rInsn.SubType() |= Instruction::CallType;
    rInsn.SetMnemonic("bxj");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BLX<c> <Rm> - ['call'] - ['cond#4', '0', '0', '0', '1', '0', '0', '1', '0', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_BLX_A1_0ffffff0_012fff30(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BLX<c> <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Blx);
    rInsn.SubType() |= Instruction::CallType;
    rInsn.SetMnemonic("blx");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMLAW<y><c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '0', '1', '0', 'Rd#4', 'Ra#4', 'Rm#4', '1', 'M#1', '0', '0', 'Rn#4']
bool ArmArchitecture::Instruction_SMLAW_A1_0ff000b0_01200080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMLAW<y><c> <Rd>, <Rn>, <Rm>, <Ra>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smlaw);
    rInsn.SetMnemonic("smlaw");
    if ((ExtractBit<6>(Opcode)) /* M */)
      rInsn.AddMnemonicSuffix("t");

    else
      rInsn.AddMnemonicSuffix("b");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Ra */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMULW<y><c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '0', '1', '0', 'Rd#4', 'SBZ#4', 'Rm#4', '1', 'M#1', '1', '0', 'Rn#4']
bool ArmArchitecture::Instruction_SMULW_A1_0ff000b0_012000a0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMULW<y><c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smulw);
    rInsn.SetMnemonic("smulw");
    if ((ExtractBit<6>(Opcode)) /* M */)
      rInsn.AddMnemonicSuffix("t");

    else
      rInsn.AddMnemonicSuffix("b");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// QSUB<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '0', '1', '0', 'Rn#4', 'Rd#4', '(0)', '(0)', '(0)', '(0)', '0', '1', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_QSUB_A1_0ff00ff0_01200050(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("QSUB<c> <Rd>, <Rm>, <Rn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Qsub);
    rInsn.SetMnemonic("qsub");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BKPT #<imm> - [] - ['cond#4', '0', '0', '0', '1', '0', '0', '1', '0', 'imm#12', '0', '1', '1', '1', 'imm#4']
bool ArmArchitecture::Instruction_BKPT_A1_0ff000f0_01200070(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BKPT #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Bkpt);
    rInsn.SetMnemonic("bkpt");
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 3>(Opcode) | ExtractBits<8, 19>(Opcode) << 4) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MSR<c> <spec_reg>, <Rn> - [] - ['cond#4', '0', '0', '0', '1', '0', '0', '1', '0', 'mask#2', '0', '0', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '0', '0', '0', 'Rn#4']
bool ArmArchitecture::Instruction_MSR_A1_0ff3fff0_0120f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MSR<c> <spec_reg>, <Rn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Msr);
    rInsn.SetMnemonic("msr");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    // FIXME: not_implemented: "operand <spec_reg>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// TEQ<c> <Rn>, <Rm>, <type> <Rs> - [] - ['cond#4', '0', '0', '0', '1', '0', '0', '1', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
bool ArmArchitecture::Instruction_TEQ_A1_0ff0f090_01300010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("TEQ<c> <Rn>, <Rm>, <type> <Rs>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Teq);
    rInsn.SetMnemonic("teq");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeRegShiftWithSources(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rs */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// TEQ<c> <Rn>, <Rm>{,<shift>} - [] - ['cond#4', '0', '0', '0', '1', '0', '0', '1', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_TEQ_A1_0ff0f010_01300000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("TEQ<c> <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Teq);
    rInsn.SetMnemonic("teq");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMLAL<x><y><c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '1', '0', '0', 'RdHi#4', 'RdLo#4', 'Rm#4', '1', 'M#1', 'N#1', '0', 'Rn#4']
bool ArmArchitecture::Instruction_SMLAL_A1_0ff00090_01400080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMLAL<x><y><c> <RdLo>, <RdHi>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smlal);
    rInsn.SetMnemonic("smlal");
    if ((ExtractBit<5>(Opcode)) /* N */)
      rInsn.AddMnemonicSuffix("t");

    else
      rInsn.AddMnemonicSuffix("b");

    if ((ExtractBit<6>(Opcode)) /* M */)
      rInsn.AddMnemonicSuffix("t");

    else
      rInsn.AddMnemonicSuffix("b");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    // FIXME: not_implemented: "operand <RdLo>";
    // FIXME: not_implemented: "operand <RdHi>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// QDADD<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '1', '0', '0', 'Rn#4', 'Rd#4', '(0)', '(0)', '(0)', '(0)', '0', '1', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_QDADD_A1_0ff00ff0_01400050(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("QDADD<c> <Rd>, <Rm>, <Rn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Qdadd);
    rInsn.SetMnemonic("qdadd");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CMP<c> <Rn>, <Rm>, <type> <Rs> - ['cond'] - ['cond#4', '0', '0', '0', '1', '0', '1', '0', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
bool ArmArchitecture::Instruction_CMP_A1_0ff0f090_01500010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CMP<c> <Rn>, <Rm>, <type> <Rs>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Cmp);
    rInsn.SetMnemonic("cmp");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeRegShiftWithSources(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rs */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CMP<c> <Rn>, <Rm>{,<shift>} - ['cond'] - ['cond#4', '0', '0', '0', '1', '0', '1', '0', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_CMP_A1_0ff0f010_01500000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CMP<c> <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Cmp);
    rInsn.SetMnemonic("cmp");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CLZ<c> <Rd>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '1', '1', '0', '(1)', '(1)', '(1)', '(1)', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_CLZ_A1_0fff0ff0_016f0f10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CLZ<c> <Rd>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Clz);
    rInsn.SetMnemonic("clz");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMUL<x><y><c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '1', '1', '0', 'Rd#4', 'SBZ#4', 'Rm#4', '1', 'M#1', 'N#1', '0', 'Rn#4']
bool ArmArchitecture::Instruction_SMUL_A1_0ff00090_01600080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMUL<x><y><c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smul);
    rInsn.SetMnemonic("smul");
    if ((ExtractBit<5>(Opcode)) /* N */)
      rInsn.AddMnemonicSuffix("t");

    else
      rInsn.AddMnemonicSuffix("b");

    if ((ExtractBit<6>(Opcode)) /* M */)
      rInsn.AddMnemonicSuffix("t");

    else
      rInsn.AddMnemonicSuffix("b");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// QDSUB<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', '1', '1', '0', 'Rn#4', 'Rd#4', '(0)', '(0)', '(0)', '(0)', '0', '1', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_QDSUB_A1_0ff00ff0_01600050(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("QDSUB<c> <Rd>, <Rm>, <Rn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Qdsub);
    rInsn.SetMnemonic("qdsub");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CMN<c> <Rn>, <Rm>, <type> <Rs> - ['cond'] - ['cond#4', '0', '0', '0', '1', '0', '1', '1', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
bool ArmArchitecture::Instruction_CMN_A1_0ff0f090_01700010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CMN<c> <Rn>, <Rm>, <type> <Rs>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Cmn);
    rInsn.SetMnemonic("cmn");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeRegShiftWithSources(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rs */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CMN<c> <Rn>, <Rm>{,<shift>} - ['cond'] - ['cond#4', '0', '0', '0', '1', '0', '1', '1', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_CMN_A1_0ff0f010_01700000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CMN<c> <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Cmn);
    rInsn.SetMnemonic("cmn");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SWP{B}<c> <Rt>, <Rt2>, [<Rn>] - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '0', 'B#1', '0', '0', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '0', '0', '1', 'Rt2#4']
bool ArmArchitecture::Instruction_SWP_A1_0fb00ff0_01000090(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SWP{B}<c> <Rt>, <Rt2>, [<Rn>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Swp);
    rInsn.SetMnemonic("swp");
    if ((ExtractBit<22>(Opcode)) /* B */)
        rInsn.AddMnemonicSuffix("B");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rt2 */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STREX<c> <Rd>, <Rt>, [<Rn>] - [] - ['cond#4', '0', '0', '0', '1', '1', '0', '0', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', 'Rt#4']
bool ArmArchitecture::Instruction_STREX_A1_0ff00ff0_01800f90(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STREX<c> <Rd>, <Rt>, [<Rn>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strex);
    rInsn.SetMnemonic("strex");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDREX<c> <Rt>, [<Rn>] - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '0', '1', 'Rn#4', 'Rt#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', '(1)', '(1)', '(1)', '(1)']
bool ArmArchitecture::Instruction_LDREX_A1_0ff00fff_01900f9f(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDREX<c> <Rt>, [<Rn>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrex);
    rInsn.SetMnemonic("ldrex");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ORR{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '0', 'S#1', 'Rn#4', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
bool ArmArchitecture::Instruction_ORR_A1_0fe00090_01800010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ORR{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Orr);
    rInsn.SetMnemonic("orr");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeRegShiftWithSources(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rs */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ORR{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_ORR_A1_0fe00010_01800000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ORR{S}<c> <Rd>, <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Orr);
    rInsn.SetMnemonic("orr");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STREXD<c> <Rd>, <Rt>, <Rt2>, [<Rn>] - [] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', 'Rt#4']
bool ArmArchitecture::Instruction_STREXD_A1_0ff00ff0_01a00f90(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STREXD<c> <Rd>, <Rt>, <Rt2>, [<Rn>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strexd);
    rInsn.SetMnemonic("strexd");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rt */ + 1), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(64, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDREXD<c> <Rt>, <Rt2>, [<Rn>] - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', '1', 'Rn#4', 'Rt#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', '(1)', '(1)', '(1)', '(1)']
bool ArmArchitecture::Instruction_LDREXD_A1_0ff00fff_01b00f9f(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDREXD<c> <Rt>, <Rt2>, [<Rn>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrexd);
    rInsn.SetMnemonic("ldrexd");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */ + 1), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(64, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MOV{S}<c> <Rd>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', '0', '0', '0', '0', '0', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_MOV_A1_0fef0ff0_01a00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MOV{S}<c> <Rd>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mov);
    rInsn.SetMnemonic("mov");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// RRX{S}<c> <Rd>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', '0', '0', '0', '0', '0', '1', '1', '0', 'Rm#4']
bool ArmArchitecture::Instruction_RRX_A1_0fef0ff0_01a00060(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("RRX{S}<c> <Rd>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Rrx);
    rInsn.SetMnemonic("rrx");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LSL{S}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'Rm#4', '0', '0', '0', '1', 'Rn#4']
bool ArmArchitecture::Instruction_LSL_A1_0fef00f0_01a00010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LSL{S}<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Lsl);
    rInsn.SetMnemonic("lsl");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LSR{S}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'Rm#4', '0', '0', '1', '1', 'Rn#4']
bool ArmArchitecture::Instruction_LSR_A1_0fef00f0_01a00030(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LSR{S}<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Lsr);
    rInsn.SetMnemonic("lsr");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ASR{S}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'Rm#4', '0', '1', '0', '1', 'Rn#4']
bool ArmArchitecture::Instruction_ASR_A1_0fef00f0_01a00050(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ASR{S}<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Asr);
    rInsn.SetMnemonic("asr");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ROR{S}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'Rm#4', '0', '1', '1', '1', 'Rn#4']
bool ArmArchitecture::Instruction_ROR_A1_0fef00f0_01a00070(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ROR{S}<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ror);
    rInsn.SetMnemonic("ror");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LSL{S}<c> <Rd>, <Rm>, #<imm5> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'imm#5', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_LSL_A1_0fef0070_01a00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LSL{S}<c> <Rd>, <Rm>, #<imm5>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Lsl);
    rInsn.SetMnemonic("lsl");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<7, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LSR{S}<c> <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'imm#5', '0', '1', '0', 'Rm#4']
bool ArmArchitecture::Instruction_LSR_A1_0fef0070_01a00020(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LSR{S}<c> <Rd>, <Rm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Lsr);
    rInsn.SetMnemonic("lsr");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<7, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ASR{S}<c> <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'imm#5', '1', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_ASR_A1_0fef0070_01a00040(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ASR{S}<c> <Rd>, <Rm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Asr);
    rInsn.SetMnemonic("asr");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<7, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ROR{S}<c> <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'imm#5', '1', '1', '0', 'Rm#4']
bool ArmArchitecture::Instruction_ROR_A1_0fef0070_01a00060(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ROR{S}<c> <Rd>, <Rm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ror);
    rInsn.SetMnemonic("ror");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<7, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STREXB<c> <Rd>, <Rt>, [<Rn>] - [] - ['cond#4', '0', '0', '0', '1', '1', '1', '0', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', 'Rt#4']
bool ArmArchitecture::Instruction_STREXB_A1_0ff00ff0_01c00f90(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STREXB<c> <Rd>, <Rt>, [<Rn>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strexb);
    rInsn.SetMnemonic("strexb");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDREXB<c> <Rt>, [<Rn>] - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '1', '0', '1', 'Rn#4', 'Rt#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', '(1)', '(1)', '(1)', '(1)']
bool ArmArchitecture::Instruction_LDREXB_A1_0ff00fff_01d00f9f(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDREXB<c> <Rt>, [<Rn>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrexb);
    rInsn.SetMnemonic("ldrexb");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BIC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '1', '0', 'S#1', 'Rn#4', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
bool ArmArchitecture::Instruction_BIC_A1_0fe00090_01c00010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BIC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Bic);
    rInsn.SetMnemonic("bic");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeRegShiftWithSources(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rs */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BIC{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '1', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_BIC_A1_0fe00010_01c00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BIC{S}<c> <Rd>, <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Bic);
    rInsn.SetMnemonic("bic");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STREXH<c> <Rd>, <Rt>, [<Rn>] - [] - ['cond#4', '0', '0', '0', '1', '1', '1', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', 'Rt#4']
bool ArmArchitecture::Instruction_STREXH_A1_0ff00ff0_01e00f90(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STREXH<c> <Rd>, <Rt>, [<Rn>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strexh);
    rInsn.SetMnemonic("strexh");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDREXH<c> <Rt>, [<Rn>] - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '1', '1', '1', 'Rn#4', 'Rt#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', '(1)', '(1)', '(1)', '(1)']
bool ArmArchitecture::Instruction_LDREXH_A1_0ff00fff_01f00f9f(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDREXH<c> <Rt>, [<Rn>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrexh);
    rInsn.SetMnemonic("ldrexh");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MVN{S}<c> <Rd>, <Rm>, <type> <Rs> - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '1', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'Rs#4', '0', 'type#2', '1', 'Rm#4']
bool ArmArchitecture::Instruction_MVN_A1_0fef0090_01e00010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MVN{S}<c> <Rd>, <Rm>, <type> <Rs>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mvn);
    rInsn.SetMnemonic("mvn");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeRegShiftWithSources(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rs */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MVN{S}<c> <Rd>, <Rm>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '0', '0', '1', '1', '1', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_MVN_A1_0fef0010_01e00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MVN{S}<c> <Rd>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mvn);
    rInsn.SetMnemonic("mvn");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRH<c> <Rt>, [<Rn>],+/-<Rm> - [] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '0', 'W#1', '0', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '0', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_STRH_A1_0e500ff0_000000b0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRH<c> <Rt>, [<Rn>],+/-<Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strh);
    rInsn.SetMnemonic("strh");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
    if ((ExtractBit<23>(Opcode)) /* U */)
      rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));

    else
      rInsn.AddOperand(-Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));

  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRD<c> <Rt>, <Rt2>, [<Rn>],+/-<Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '0', 'W#1', '0', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '1', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_LDRD_A1_0e500ff0_000000d0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRD<c> <Rt>, <Rt2>, [<Rn>],+/-<Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrd);
    rInsn.SetMnemonic("ldrd");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */ + 1), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(64, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
    if ((ExtractBit<23>(Opcode)) /* U */)
      rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));

    else
      rInsn.AddOperand(-Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));

  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRD<c> <Rt>, <Rt2>, [<Rn>],+/-<Rm> - [] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '0', 'W#1', '0', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_STRD_A1_0e500ff0_000000f0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRD<c> <Rt>, <Rt2>, [<Rn>],+/-<Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strd);
    rInsn.SetMnemonic("strd");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */ + 1), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(64, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
    if ((ExtractBit<23>(Opcode)) /* U */)
      rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));

    else
      rInsn.AddOperand(-Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));

  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRH<c> <Rt>, [<Rn>],+/-<Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '0', 'W#1', '1', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '0', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_LDRH_A1_0e500ff0_001000b0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRH<c> <Rt>, [<Rn>],+/-<Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrh);
    rInsn.SetMnemonic("ldrh");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
    if ((ExtractBit<23>(Opcode)) /* U */)
      rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));

    else
      rInsn.AddOperand(-Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));

  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSB<c> <Rt>, [<Rn>],+/-<Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '0', 'W#1', '1', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '1', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_LDRSB_A1_0e500ff0_001000d0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSB<c> <Rt>, [<Rn>],+/-<Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrsb);
    rInsn.SetMnemonic("ldrsb");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
    if ((ExtractBit<23>(Opcode)) /* U */)
      rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));

    else
      rInsn.AddOperand(-Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));

  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSH<c> <Rt>, [<Rn>],+/-<Rm> - ['could_jmp'] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '0', 'W#1', '1', 'Rn#4', 'Rt#4', '(0)', '(0)', '(0)', '(0)', '1', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_LDRSH_A1_0e500ff0_001000f0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSH<c> <Rt>, [<Rn>],+/-<Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrsh);
    rInsn.SetMnemonic("ldrsh");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
    if ((ExtractBit<23>(Opcode)) /* U */)
      rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));

    else
      rInsn.AddOperand(-Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));

  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRH<c> <Rt>, [<Rn>, #<disp>]! - [] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '1', 'W#1', '0', 'Rn#4', 'Rt#4', 'imm_h#4', '1', '0', '1', '1', 'imm_l#4']
bool ArmArchitecture::Instruction_STRH_A1_0e5000f0_004000b0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRH<c> <Rt>, [<Rn>, #<disp>]!");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strh);
    rInsn.SetMnemonic("strh");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddAttribute(ARM_Attribute_WriteBack);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<8, 11>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode)))));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRD<c> <Rt>, <Rt2>, [<Rn>, #<disp>]! - ['could_jmp'] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '1', 'W#1', '0', 'Rn#4', 'Rt#4', 'imm_h#4', '1', '1', '0', '1', 'imm_l#4']
bool ArmArchitecture::Instruction_LDRD_A1_0e5000f0_004000d0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRD<c> <Rt>, <Rt2>, [<Rn>, #<disp>]!");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrd);
    rInsn.SetMnemonic("ldrd");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddAttribute(ARM_Attribute_WriteBack);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */ + 1), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(64, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<8, 11>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode)))));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRD<c> <Rt>, <Rt2>, [<Rn>, #<disp>]! - [] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '1', 'W#1', '0', 'Rn#4', 'Rt#4', 'imm_h#4', '1', '1', '1', '1', 'imm_l#4']
bool ArmArchitecture::Instruction_STRD_A1_0e5000f0_004000f0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRD<c> <Rt>, <Rt2>, [<Rn>, #<disp>]!");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strd);
    rInsn.SetMnemonic("strd");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddAttribute(ARM_Attribute_WriteBack);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */ + 1), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(64, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<8, 11>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode)))));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRH<c> <Rt>, [<Rn>, #<disp>]! - ['could_jmp'] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '1', 'W#1', '1', 'Rn#4', 'Rt#4', 'imm_h#4', '1', '0', '1', '1', 'imm_l#4']
bool ArmArchitecture::Instruction_LDRH_A1_0e5000f0_005000b0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRH<c> <Rt>, [<Rn>, #<disp>]!");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrh);
    rInsn.SetMnemonic("ldrh");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddAttribute(ARM_Attribute_WriteBack);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<8, 11>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode)))));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSB<c> <Rt>, [<Rn>, #<disp>]! - ['could_jmp'] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '1', 'W#1', '1', 'Rn#4', 'Rt#4', 'imm_h#4', '1', '1', '0', '1', 'imm_l#4']
bool ArmArchitecture::Instruction_LDRSB_A1_0e5000f0_005000d0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSB<c> <Rt>, [<Rn>, #<disp>]!");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrsb);
    rInsn.SetMnemonic("ldrsb");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddAttribute(ARM_Attribute_WriteBack);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<8, 11>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode)))));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSH<c> <Rt>, [<Rn>, #<disp>]! - ['could_jmp'] - ['cond#4', '0', '0', '0', 'P#1', 'U#1', '1', 'W#1', '1', 'Rn#4', 'Rt#4', 'imm_h#4', '1', '1', '1', '1', 'imm_l#4']
bool ArmArchitecture::Instruction_LDRSH_A1_0e5000f0_005000f0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSH<c> <Rt>, [<Rn>, #<disp>]!");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrsh);
    rInsn.SetMnemonic("ldrsh");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddAttribute(ARM_Attribute_WriteBack);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<8, 11>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode)))));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// AND{S}<c> <Rd>, <Rn>, #<arm_expand_imm_c> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '0', '0', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#12']
bool ArmArchitecture::Instruction_AND_A1_0fe00000_02000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("AND{S}<c> <Rd>, <Rn>, #<arm_expand_imm_c>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_And);
    rInsn.SetMnemonic("and");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, arm::ArmExpandImm((ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// EOR{S}<c> <Rd>, <Rn>, #<arm_expand_imm_c> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '0', '0', '1', 'S#1', 'Rn#4', 'Rd#4', 'imm#12']
bool ArmArchitecture::Instruction_EOR_A1_0fe00000_02200000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("EOR{S}<c> <Rd>, <Rn>, #<arm_expand_imm_c>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Eor);
    rInsn.SetMnemonic("eor");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, arm::ArmExpandImm((ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SUB <Rd>, PC, #0 - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '0', '1', '0', '0', '1', '1', '1', '1', 'Rd#4', 'imm#12']
bool ArmArchitecture::Instruction_SUB_A2_0fff0000_024f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SUB <Rd>, PC, #0");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sub);
    rInsn.SetMnemonic("sub");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, 0x0));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SUB{S}<c> <Rd>, SP, #<arm_expand_imm> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '0', '1', '0', 'S#1', '1', '1', '0', '1', 'Rd#4', 'imm#12']
bool ArmArchitecture::Instruction_SUB_A1_0fef0000_024d0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SUB{S}<c> <Rd>, SP, #<arm_expand_imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sub);
    rInsn.SetMnemonic("sub");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Sp, &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, arm::ArmExpandImm((ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SUB{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '0', '1', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#12']
bool ArmArchitecture::Instruction_SUB_A1_0fe00000_02400000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SUB{S}<c> <Rd>, <Rn>, #<arm_expand_imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sub);
    rInsn.SetMnemonic("sub");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, arm::ArmExpandImm((ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// RSB{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '0', '1', '1', 'S#1', 'Rn#4', 'Rd#4', 'imm#12']
bool ArmArchitecture::Instruction_RSB_A1_0fe00000_02600000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("RSB{S}<c> <Rd>, <Rn>, #<arm_expand_imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Rsb);
    rInsn.SetMnemonic("rsb");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, arm::ArmExpandImm((ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADR<c> <Rd>, <arm_expand_label> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '1', '0', '0', '0', '1', '1', '1', '1', 'Rd#4', 'imm#12']
bool ArmArchitecture::Instruction_ADR_A1_0fff0000_028f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADR<c> <Rd>, <arm_expand_label>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Adr);
    rInsn.SetMnemonic("adr");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo) + (ExtractBits<0, 11>(Opcode)) /* imm */);
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADD{S}<c> <Rd>, SP, #<arm_expand_imm> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '1', '0', '0', 'S#1', '1', '1', '0', '1', 'Rd#4', 'imm#12']
bool ArmArchitecture::Instruction_ADD_A1_0fef0000_028d0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADD{S}<c> <Rd>, SP, #<arm_expand_imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Add);
    rInsn.SetMnemonic("add");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Sp, &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, arm::ArmExpandImm((ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADD{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '1', '0', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#12']
bool ArmArchitecture::Instruction_ADD_A1_0fe00000_02800000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADD{S}<c> <Rd>, <Rn>, #<arm_expand_imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Add);
    rInsn.SetMnemonic("add");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, arm::ArmExpandImm((ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADC{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '1', '0', '1', 'S#1', 'Rn#4', 'Rd#4', 'imm#12']
bool ArmArchitecture::Instruction_ADC_A1_0fe00000_02a00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADC{S}<c> <Rd>, <Rn>, #<arm_expand_imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Adc);
    rInsn.SetMnemonic("adc");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, arm::ArmExpandImm((ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SBC{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '1', '1', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#12']
bool ArmArchitecture::Instruction_SBC_A1_0fe00000_02c00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SBC{S}<c> <Rd>, <Rn>, #<arm_expand_imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sbc);
    rInsn.SetMnemonic("sbc");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, arm::ArmExpandImm((ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// RSC{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['cond#4', '0', '0', '1', '0', '1', '1', '1', 'S#1', 'Rn#4', 'Rd#4', 'imm#12']
bool ArmArchitecture::Instruction_RSC_A1_0fe00000_02e00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("RSC{S}<c> <Rd>, <Rn>, #<arm_expand_imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Rsc);
    rInsn.SetMnemonic("rsc");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, arm::ArmExpandImm((ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MOVW<c> <Rd>, #<imm> - ['could_jmp'] - ['cond#4', '0', '0', '1', '1', '0', '0', '0', '0', 'imm#4', 'Rd#4', 'imm#12']
bool ArmArchitecture::Instruction_MOVW_A2_0ff00000_03000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MOVW<c> <Rd>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Movw);
    rInsn.SetMnemonic("movw");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 11>(Opcode) | ExtractBits<16, 19>(Opcode) << 12) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// TST<c> <Rn>, #<arm_expand_imm_c> - [] - ['cond#4', '0', '0', '1', '1', '0', '0', '0', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'imm#12']
bool ArmArchitecture::Instruction_TST_A1_0ff0f000_03100000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("TST<c> <Rn>, #<arm_expand_imm_c>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Tst);
    rInsn.SetMnemonic("tst");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, arm::ArmExpandImm((ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// NOP<c> - [] - ['cond#4', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0', '0', '0', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '0', '0', '0', '0', '0', '0', '0']
bool ArmArchitecture::Instruction_NOP_A1_0fffffff_0320f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("NOP<c>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Nop);
    rInsn.SetMnemonic("nop");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// YIELD<c> - [] - ['cond#4', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0', '0', '0', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '0', '0', '0', '0', '0', '0', '1']
bool ArmArchitecture::Instruction_YIELD_A1_0fffffff_0320f001(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("YIELD<c>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Yield);
    rInsn.SetMnemonic("yield");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// WFE<c> - [] - ['cond#4', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0', '0', '0', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '0', '0', '0', '0', '0', '1', '0']
bool ArmArchitecture::Instruction_WFE_A1_0fffffff_0320f002(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("WFE<c>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Wfe);
    rInsn.SetMnemonic("wfe");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// WFI<c> - [] - ['cond#4', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0', '0', '0', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '0', '0', '0', '0', '0', '1', '1']
bool ArmArchitecture::Instruction_WFI_A1_0fffffff_0320f003(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("WFI<c>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Wfi);
    rInsn.SetMnemonic("wfi");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SEV<c> - [] - ['cond#4', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0', '0', '0', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '0', '0', '0', '0', '1', '0', '0']
bool ArmArchitecture::Instruction_SEV_A1_0fffffff_0320f004(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SEV<c>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sev);
    rInsn.SetMnemonic("sev");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// DBG<c> #<option> - [] - ['cond#4', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0', '0', '0', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '1', '1', '1', '1', 'option#4']
bool ArmArchitecture::Instruction_DBG_A1_0ffffff0_0320f0f0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("DBG<c> #<option>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Dbg);
    rInsn.SetMnemonic("dbg");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 3>(Opcode)) /* option */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MSR<c> <spec_reg>, #<arm_expand_imm> - [] - ['cond#4', '0', '0', '1', '1', '0', '0', '1', '0', 'mask#2', '0', '0', '(1)', '(1)', '(1)', '(1)', 'imm#12']
bool ArmArchitecture::Instruction_MSR_A1_0ff3f000_0320f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MSR<c> <spec_reg>, #<arm_expand_imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Msr);
    rInsn.SetMnemonic("msr");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    // FIXME: not_implemented: "operand <spec_reg>";
    rInsn.AddOperand(Expr::MakeBitVector(32, arm::ArmExpandImm((ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// TEQ<c> <Rn>, #<arm_expand_imm_c> - [] - ['cond#4', '0', '0', '1', '1', '0', '0', '1', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'imm#12']
bool ArmArchitecture::Instruction_TEQ_A1_0ff0f000_03300000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("TEQ<c> <Rn>, #<arm_expand_imm_c>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Teq);
    rInsn.SetMnemonic("teq");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, arm::ArmExpandImm((ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MOVT<c> <Rd>, #<imm> - ['could_jmp'] - ['cond#4', '0', '0', '1', '1', '0', '1', '0', '0', 'imm#4', 'Rd#4', 'imm#12']
bool ArmArchitecture::Instruction_MOVT_A1_0ff00000_03400000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MOVT<c> <Rd>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Movt);
    rInsn.SetMnemonic("movt");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 11>(Opcode) | ExtractBits<16, 19>(Opcode) << 12) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CMP<c> <Rn>, #<arm_expand_imm> - ['cond'] - ['cond#4', '0', '0', '1', '1', '0', '1', '0', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'imm#12']
bool ArmArchitecture::Instruction_CMP_A1_0ff0f000_03500000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CMP<c> <Rn>, #<arm_expand_imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Cmp);
    rInsn.SetMnemonic("cmp");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, arm::ArmExpandImm((ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CMN<c> <Rn>, #<arm_expand_imm> - ['cond'] - ['cond#4', '0', '0', '1', '1', '0', '1', '1', '1', 'Rn#4', '(0)', '(0)', '(0)', '(0)', 'imm#12']
bool ArmArchitecture::Instruction_CMN_A1_0ff0f000_03700000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CMN<c> <Rn>, #<arm_expand_imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Cmn);
    rInsn.SetMnemonic("cmn");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, arm::ArmExpandImm((ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ORR{S}<c> <Rd>, <Rn>, #<arm_expand_imm_c> - ['could_jmp'] - ['cond#4', '0', '0', '1', '1', '1', '0', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#12']
bool ArmArchitecture::Instruction_ORR_A1_0fe00000_03800000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ORR{S}<c> <Rd>, <Rn>, #<arm_expand_imm_c>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Orr);
    rInsn.SetMnemonic("orr");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, arm::ArmExpandImm((ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MOV{S}<c> <Rd>, #<arm_expand_imm_c> - ['could_jmp'] - ['cond#4', '0', '0', '1', '1', '1', '0', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'imm#12']
bool ArmArchitecture::Instruction_MOV_A1_0fef0000_03a00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MOV{S}<c> <Rd>, #<arm_expand_imm_c>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mov);
    rInsn.SetMnemonic("mov");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, arm::ArmExpandImm((ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BIC{S}<c> <Rd>, <Rn>, #<arm_expand_imm_c> - ['could_jmp'] - ['cond#4', '0', '0', '1', '1', '1', '1', '0', 'S#1', 'Rn#4', 'Rd#4', 'imm#12']
bool ArmArchitecture::Instruction_BIC_A1_0fe00000_03c00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BIC{S}<c> <Rd>, <Rn>, #<arm_expand_imm_c>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Bic);
    rInsn.SetMnemonic("bic");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, arm::ArmExpandImm((ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MVN{S}<c> <Rd>, #<arm_expand_imm_c> - ['could_jmp'] - ['cond#4', '0', '0', '1', '1', '1', '1', '1', 'S#1', '(0)', '(0)', '(0)', '(0)', 'Rd#4', 'imm#12']
bool ArmArchitecture::Instruction_MVN_A1_0fef0000_03e00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MVN{S}<c> <Rd>, #<arm_expand_imm_c>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mvn);
    rInsn.SetMnemonic("mvn");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, arm::ArmExpandImm((ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDR<c> <Rt>, <u_label> - ['could_jmp'] - ['cond#4', '0', '1', '0', '(1)', 'U#1', '0', '(0)', '1', '1', '1', '1', '1', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_LDR_A1_0f7f0000_051f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDR<c> <Rt>, <u_label>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldr);
    rInsn.SetMnemonic("ldr");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    if ((ExtractBit<23>(Opcode)) /* U */)
      rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo) + (ExtractBits<0, 11>(Opcode)) /* imm */));

    else
      rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo) - (ExtractBits<0, 11>(Opcode)) /* imm */));

  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRB<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['cond#4', '0', '1', '0', '(1)', 'U#1', '1', '(0)', '1', '1', '1', '1', '1', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_LDRB_A1_0f7f0000_055f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRB<c> <Rt>, [PC,#-0]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrb);
    rInsn.SetMnemonic("ldrb");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// POP<c> <Rt> - ['could_ret'] - ['cond#4', '0', '1', '0', '0', '1', '0', '0', '1', '1', '1', '0', '1', 'Rt#4', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '0', '0']
bool ArmArchitecture::Instruction_POP_A2_0fff0fff_049d0004(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("POP<c> <Rt>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Pop);
    rInsn.SetMnemonic("pop");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRT<c> <Rt>, [<Rn>] {,#<disp>} - ['could_jmp'] - ['cond#4', '0', '1', '0', '0', 'U#1', '0', '1', '1', 'Rn#4', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_LDRT_A1_0f700000_04300000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRT<c> <Rt>, [<Rn>] {,#<disp>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrt);
    rInsn.SetMnemonic("ldrt");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
    // FIXME: not_implemented: "operand {,#<disp>}";
    if ((ExtractBits<0, 11>(Opcode)) /* imm */)
        rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 11>(Opcode)) /* imm */));

  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRBT<c> <Rt>, [<Rn>], #<imm> - [] - ['cond#4', '0', '1', '0', '0', 'U#1', '1', '1', '0', 'Rn#4', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_STRBT_A1_0f700000_04600000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRBT<c> <Rt>, [<Rn>], #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strbt);
    rInsn.SetMnemonic("strbt");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRBT<c> <Rt>, [<Rn>], #<imm> - ['could_jmp'] - ['cond#4', '0', '1', '0', '0', 'U#1', '1', '1', '1', 'Rn#4', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_LDRBT_A1_0f700000_04700000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRBT<c> <Rt>, [<Rn>], #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrbt);
    rInsn.SetMnemonic("ldrbt");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRT<c> <Rt>, [<Rn>] {, #<imm>} - [] - ['cond#4', '0', '1', '0', '0', 'W#1', '0', '1', '0', 'Rn#4', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_STRT_A1_0f700000_04200000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRT<c> <Rt>, [<Rn>] {, #<imm>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strt);
    rInsn.SetMnemonic("strt");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
    // FIXME: not_implemented: "operand {";
    // FIXME: not_implemented: "operand #<imm>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// PUSH<c> <Rt> - [] - ['cond#4', '0', '1', '0', '1', '0', '0', '1', '0', '1', '1', '0', '1', 'Rt#4', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '0', '0']
bool ArmArchitecture::Instruction_PUSH_A2_0fff0fff_052d0004(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("PUSH<c> <Rt>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Push);
    rInsn.SetMnemonic("push");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STR<c> <Rt>, [<Rn>, #<disp>]! - [] - ['cond#4', '0', '1', '0', 'P#1', 'U#1', '0', 'W#1', '0', 'Rn#4', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_STR_A1_0e500000_04000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STR<c> <Rt>, [<Rn>, #<disp>]!");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Str);
    rInsn.SetMnemonic("str");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddAttribute(ARM_Attribute_WriteBack);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDR<c> <Rt>, [<Rn>, #<disp>]! - ['could_jmp'] - ['cond#4', '0', '1', '0', 'P#1', 'U#1', '0', 'W#1', '1', 'Rn#4', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_LDR_A1_0e500000_04100000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDR<c> <Rt>, [<Rn>, #<disp>]!");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldr);
    rInsn.SetMnemonic("ldr");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddAttribute(ARM_Attribute_WriteBack);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRB<c> <Rt>, [<Rn>, #<disp>]! - [] - ['cond#4', '0', '1', '0', 'P#1', 'U#1', '1', 'W#1', '0', 'Rn#4', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_STRB_A1_0e500000_04400000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRB<c> <Rt>, [<Rn>, #<disp>]!");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strb);
    rInsn.SetMnemonic("strb");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddAttribute(ARM_Attribute_WriteBack);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRB<c> <Rt>, [<Rn>, #<disp>]! - ['could_jmp'] - ['cond#4', '0', '1', '0', 'P#1', 'U#1', '1', 'W#1', '1', 'Rn#4', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_LDRB_A1_0e500000_04500000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRB<c> <Rt>, [<Rn>, #<disp>]!");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrb);
    rInsn.SetMnemonic("ldrb");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddAttribute(ARM_Attribute_WriteBack);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SADD16_A1_0ff00ff0_06100f10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SADD16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sadd16);
    rInsn.SetMnemonic("sadd16");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SASX_A1_0ff00ff0_06100f30(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SASX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sasx);
    rInsn.SetMnemonic("sasx");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SSAX_A1_0ff00ff0_06100f50(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SSAX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ssax);
    rInsn.SetMnemonic("ssax");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SSUB16_A1_0ff00ff0_06100f70(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SSUB16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ssub16);
    rInsn.SetMnemonic("ssub16");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SADD8_A1_0ff00ff0_06100f90(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SADD8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sadd8);
    rInsn.SetMnemonic("sadd8");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SSUB8_A1_0ff00ff0_06100ff0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SSUB8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ssub8);
    rInsn.SetMnemonic("ssub8");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// QADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_QADD16_A1_0ff00ff0_06200f10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("QADD16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Qadd16);
    rInsn.SetMnemonic("qadd16");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// QASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_QASX_A1_0ff00ff0_06200f30(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("QASX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Qasx);
    rInsn.SetMnemonic("qasx");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// QSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_QSAX_A1_0ff00ff0_06200f50(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("QSAX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Qsax);
    rInsn.SetMnemonic("qsax");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// QSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_QSUB16_A1_0ff00ff0_06200f70(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("QSUB16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Qsub16);
    rInsn.SetMnemonic("qsub16");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// QADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_QADD8_A1_0ff00ff0_06200f90(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("QADD8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Qadd8);
    rInsn.SetMnemonic("qadd8");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// QSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_QSUB8_A1_0ff00ff0_06200ff0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("QSUB8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Qsub8);
    rInsn.SetMnemonic("qsub8");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SHADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SHADD16_A1_0ff00ff0_06300f10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SHADD16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Shadd16);
    rInsn.SetMnemonic("shadd16");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SHASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SHASX_A1_0ff00ff0_06300f30(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SHASX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Shasx);
    rInsn.SetMnemonic("shasx");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SHSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SHSAX_A1_0ff00ff0_06300f50(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SHSAX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Shsax);
    rInsn.SetMnemonic("shsax");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SHSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SHSUB16_A1_0ff00ff0_06300f70(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SHSUB16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Shsub16);
    rInsn.SetMnemonic("shsub16");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SHADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SHADD8_A1_0ff00ff0_06300f90(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SHADD8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Shadd8);
    rInsn.SetMnemonic("shadd8");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SHSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '0', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SHSUB8_A1_0ff00ff0_06300ff0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SHSUB8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Shsub8);
    rInsn.SetMnemonic("shsub8");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UADD16<c> <Rd>, <Rn>, <Rm> - [] - ['cond#4', '0', '1', '1', '0', '0', '1', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UADD16_A1_0ff00ff0_06500f10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UADD16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uadd16);
    rInsn.SetMnemonic("uadd16");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UASX_A1_0ff00ff0_06500f30(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UASX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uasx);
    rInsn.SetMnemonic("uasx");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// USAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_USAX_A1_0ff00ff0_06500f50(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("USAX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Usax);
    rInsn.SetMnemonic("usax");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// USUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_USUB16_A1_0ff00ff0_06500f70(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("USUB16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Usub16);
    rInsn.SetMnemonic("usub16");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UADD8_A1_0ff00ff0_06500f90(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UADD8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uadd8);
    rInsn.SetMnemonic("uadd8");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// USUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '0', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_USUB8_A1_0ff00ff0_06500ff0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("USUB8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Usub8);
    rInsn.SetMnemonic("usub8");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UQADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UQADD16_A1_0ff00ff0_06600f10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UQADD16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uqadd16);
    rInsn.SetMnemonic("uqadd16");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UQASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UQASX_A1_0ff00ff0_06600f30(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UQASX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uqasx);
    rInsn.SetMnemonic("uqasx");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UQSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UQSAX_A1_0ff00ff0_06600f50(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UQSAX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uqsax);
    rInsn.SetMnemonic("uqsax");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UQSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UQSUB16_A1_0ff00ff0_06600f70(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UQSUB16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uqsub16);
    rInsn.SetMnemonic("uqsub16");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UQADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UQADD8_A1_0ff00ff0_06600f90(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UQADD8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uqadd8);
    rInsn.SetMnemonic("uqadd8");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UQSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UQSUB8_A1_0ff00ff0_06600ff0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UQSUB8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uqsub8);
    rInsn.SetMnemonic("uqsub8");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UHADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UHADD16_A1_0ff00ff0_06700f10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UHADD16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uhadd16);
    rInsn.SetMnemonic("uhadd16");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UHASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UHASX_A1_0ff00ff0_06700f30(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UHASX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uhasx);
    rInsn.SetMnemonic("uhasx");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UHSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UHSAX_A1_0ff00ff0_06700f50(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UHSAX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uhsax);
    rInsn.SetMnemonic("uhsax");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UHSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UHSUB16_A1_0ff00ff0_06700f70(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UHSUB16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uhsub16);
    rInsn.SetMnemonic("uhsub16");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UHADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UHADD8_A1_0ff00ff0_06700f90(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UHADD8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uhadd8);
    rInsn.SetMnemonic("uhadd8");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UHSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '0', '1', '1', '1', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UHSUB8_A1_0ff00ff0_06700ff0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UHSUB8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uhsub8);
    rInsn.SetMnemonic("uhsub8");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SXTB16<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '0', '0', '1', '1', '1', '1', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SXTB16_A1_0fff03f0_068f0070(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SXTB16<c> <Rd>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sxtb16);
    rInsn.SetMnemonic("sxtb16");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SEL<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '0', '0', 'Rn#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SEL_A1_0ff00ff0_06800fb0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SEL<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sel);
    rInsn.SetMnemonic("sel");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// PKHTB<c> <Rd>, <Rn>, <Rm>{,ASR #<imm>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '0', '0', 'Rn#4', 'Rd#4', 'imm#5', 'tb#1', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_PKHTB_A1_0ff00030_06800010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("PKHTB<c> <Rd>, <Rn>, <Rm>{,ASR #<imm>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Pkhtb);
    rInsn.SetMnemonic("pkhtb");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,ASR";
    // FIXME: not_implemented: "operand #<imm>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SXTAB16<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '0', '0', 'Rn#4', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SXTAB16_A1_0ff003f0_06800070(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SXTAB16<c> <Rd>, <Rn>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sxtab16);
    rInsn.SetMnemonic("sxtab16");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SXTB<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '1', '0', '1', '1', '1', '1', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SXTB_A1_0fff03f0_06af0070(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SXTB<c> <Rd>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sxtb);
    rInsn.SetMnemonic("sxtb");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SXTAB<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '1', '0', 'Rn#4', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SXTAB_A1_0ff003f0_06a00070(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SXTAB<c> <Rd>, <Rn>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sxtab);
    rInsn.SetMnemonic("sxtab");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SSAT16<c> <Rd>, #<imm>, <Rn> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '1', '0', 'sat_imm#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rn#4']
bool ArmArchitecture::Instruction_SSAT16_A1_0ff00ff0_06a00f30(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SSAT16<c> <Rd>, #<imm>, <Rn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ssat16);
    rInsn.SetMnemonic("ssat16");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 19>(Opcode)) /* sat_imm */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// REV<c> <Rd>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '1', '1', '(1)', '(1)', '(1)', '(1)', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_REV_A1_0fff0ff0_06bf0f30(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("REV<c> <Rd>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Rev);
    rInsn.SetMnemonic("rev");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// REV16<c> <Rd>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '1', '1', '(1)', '(1)', '(1)', '(1)', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_REV16_A1_0fff0ff0_06bf0fb0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("REV16<c> <Rd>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Rev16);
    rInsn.SetMnemonic("rev16");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SXTH<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '1', '1', '1', '1', '1', '1', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SXTH_A1_0fff03f0_06bf0070(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SXTH<c> <Rd>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sxth);
    rInsn.SetMnemonic("sxth");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SXTAH<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '1', '1', 'Rn#4', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SXTAH_A1_0ff003f0_06b00070(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SXTAH<c> <Rd>, <Rn>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sxtah);
    rInsn.SetMnemonic("sxtah");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SSAT<c> <Rd>, #<imm>, <Rn>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '0', '1', 'sat_imm#5', 'Rd#4', 'imm#5', 'sh#1', '0', '1', 'Rn#4']
bool ArmArchitecture::Instruction_SSAT_A1_0fe00030_06a00010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SSAT<c> <Rd>, #<imm>, <Rn>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ssat);
    rInsn.SetMnemonic("ssat");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 20>(Opcode)) /* sat_imm */));
    // FIXME: not_implemented: "operand <Rn>{,<shift>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UXTB16<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '1', '0', '0', '1', '1', '1', '1', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UXTB16_A1_0fff03f0_06cf0070(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UXTB16<c> <Rd>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uxtb16);
    rInsn.SetMnemonic("uxtb16");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UXTAB16<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '1', '0', '0', 'Rn#4', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UXTAB16_A1_0ff003f0_06c00070(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UXTAB16<c> <Rd>, <Rn>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uxtab16);
    rInsn.SetMnemonic("uxtab16");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UXTB<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '1', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UXTB_A1_0fff03f0_06ef0070(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UXTB<c> <Rd>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uxtb);
    rInsn.SetMnemonic("uxtb");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UXTAB<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '1', '1', '0', 'Rn#4', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UXTAB_A1_0ff003f0_06e00070(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UXTAB<c> <Rd>, <Rn>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uxtab);
    rInsn.SetMnemonic("uxtab");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// USAT16<c> <Rd>, #<imm4>, <Rn> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '1', '1', '0', 'sat_imm#4', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rn#4']
bool ArmArchitecture::Instruction_USAT16_A1_0ff00ff0_06e00f30(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("USAT16<c> <Rd>, #<imm4>, <Rn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Usat16);
    rInsn.SetMnemonic("usat16");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    // FIXME: not_implemented: "operand #<imm4>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// RBIT<c> <Rd>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '1', '1', '1', '(1)', '(1)', '(1)', '(1)', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_RBIT_A1_0fff0ff0_06ff0f30(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("RBIT<c> <Rd>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Rbit);
    rInsn.SetMnemonic("rbit");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// REVSH<c> <Rd>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '1', '1', '1', '(1)', '(1)', '(1)', '(1)', 'Rd#4', '(1)', '(1)', '(1)', '(1)', '1', '0', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_REVSH_A1_0fff0ff0_06ff0fb0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("REVSH<c> <Rd>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Revsh);
    rInsn.SetMnemonic("revsh");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UXTH<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UXTH_A1_0fff03f0_06ff0070(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UXTH<c> <Rd>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uxth);
    rInsn.SetMnemonic("uxth");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UXTAH<c> <Rd>, <Rn>, <Rm>{,<rotation>} - [] - ['cond#4', '0', '1', '1', '0', '1', '1', '1', '1', 'Rn#4', 'Rd#4', 'rotate#2', '(0)', '(0)', '0', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UXTAH_A1_0ff003f0_06f00070(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UXTAH<c> <Rd>, <Rn>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uxtah);
    rInsn.SetMnemonic("uxtah");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// USAT<c> <Rd>, #<imm5>, <Rn>{,<shift>} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', '1', '1', '1', 'sat_imm#5', 'Rd#4', 'imm#5', 'sh#1', '0', '1', 'Rn#4']
bool ArmArchitecture::Instruction_USAT_A1_0fe00030_06e00010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("USAT<c> <Rd>, #<imm5>, <Rn>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Usat);
    rInsn.SetMnemonic("usat");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<7, 11>(Opcode)) /* imm */));
    // FIXME: not_implemented: "operand <Rn>{,<shift>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRT<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!} - [] - ['cond#4', '0', '1', '1', '0', 'W#1', '0', '1', '0', 'Rn#4', 'Rt#4', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_STRT_A2_0f700010_06200000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRT<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strt);
    rInsn.SetMnemonic("strt");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    if ((ExtractBit<23>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRT<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', 'W#1', '0', '1', '1', 'Rn#4', 'Rt#4', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_LDRT_A2_0f700010_06300000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRT<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrt);
    rInsn.SetMnemonic("ldrt");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    if ((ExtractBit<23>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRBT<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!} - [] - ['cond#4', '0', '1', '1', '0', 'W#1', '1', '1', '0', 'Rn#4', 'Rt#4', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_STRBT_A2_0f700010_06600000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRBT<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strbt);
    rInsn.SetMnemonic("strbt");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    if ((ExtractBit<23>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRBT<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!} - ['could_jmp'] - ['cond#4', '0', '1', '1', '0', 'W#1', '1', '1', '1', 'Rn#4', 'Rt#4', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_LDRBT_A2_0f700010_06700000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRBT<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrbt);
    rInsn.SetMnemonic("ldrbt");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    if ((ExtractBit<23>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMUAD{X}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '0', '0', '0', '0', 'Rd#4', '1', '1', '1', '1', 'Rm#4', '0', '0', 'M#1', '1', 'Rn#4']
bool ArmArchitecture::Instruction_SMUAD_A1_0ff0f0d0_0700f010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMUAD{X}<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smuad);
    rInsn.SetMnemonic("smuad");
    if ((ExtractBit<5>(Opcode)) /* M */)
        rInsn.AddMnemonicSuffix("X");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMUSD{X}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '0', '0', '0', '0', 'Rd#4', '1', '1', '1', '1', 'Rm#4', '0', '1', 'M#1', '1', 'Rn#4']
bool ArmArchitecture::Instruction_SMUSD_A1_0ff0f0d0_0700f050(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMUSD{X}<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smusd);
    rInsn.SetMnemonic("smusd");
    if ((ExtractBit<5>(Opcode)) /* M */)
        rInsn.AddMnemonicSuffix("X");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMLAD{X}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '0', '0', '0', '0', 'Rd#4', 'Ra#4', 'Rm#4', '0', '0', 'M#1', '1', 'Rn#4']
bool ArmArchitecture::Instruction_SMLAD_A1_0ff000d0_07000010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMLAD{X}<c> <Rd>, <Rn>, <Rm>, <Ra>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smlad);
    rInsn.SetMnemonic("smlad");
    if ((ExtractBit<5>(Opcode)) /* M */)
        rInsn.AddMnemonicSuffix("X");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Ra */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMLSD{X}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '0', '0', '0', '0', 'Rd#4', 'Ra#4', 'Rm#4', '0', '1', 'M#1', '1', 'Rn#4']
bool ArmArchitecture::Instruction_SMLSD_A1_0ff000d0_07000050(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMLSD{X}<c> <Rd>, <Rn>, <Rm>, <Ra>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smlsd);
    rInsn.SetMnemonic("smlsd");
    if ((ExtractBit<5>(Opcode)) /* M */)
        rInsn.AddMnemonicSuffix("X");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Ra */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMLALD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '0', '1', '0', '0', 'RdHi#4', 'RdLo#4', 'Rm#4', '0', '0', 'M#1', '1', 'Rn#4']
bool ArmArchitecture::Instruction_SMLALD_A1_0ff000d0_07400010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMLALD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smlald);
    rInsn.SetMnemonic("smlald");
    if ((ExtractBit<5>(Opcode)) /* M */)
        rInsn.AddMnemonicSuffix("X");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    // FIXME: not_implemented: "operand <RdLo>";
    // FIXME: not_implemented: "operand <RdHi>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMLSLD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '0', '1', '0', '0', 'RdHi#4', 'RdLo#4', 'Rm#4', '0', '1', 'M#1', '1', 'Rn#4']
bool ArmArchitecture::Instruction_SMLSLD_A1_0ff000d0_07400050(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMLSLD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smlsld);
    rInsn.SetMnemonic("smlsld");
    if ((ExtractBit<5>(Opcode)) /* M */)
        rInsn.AddMnemonicSuffix("X");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    // FIXME: not_implemented: "operand <RdLo>";
    // FIXME: not_implemented: "operand <RdHi>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMMUL{R}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '0', '1', '0', '1', 'Rd#4', '1', '1', '1', '1', 'Rm#4', '0', '0', 'R#1', '1', 'Rn#4']
bool ArmArchitecture::Instruction_SMMUL_A1_0ff0f0d0_0750f010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMMUL{R}<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smmul);
    rInsn.SetMnemonic("smmul");
    if ((ExtractBit<5>(Opcode)) /* R */)
        rInsn.AddMnemonicSuffix("R");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMMLA{R}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '0', '1', '0', '1', 'Rd#4', 'Ra#4', 'Rm#4', '0', '0', 'R#1', '1', 'Rn#4']
bool ArmArchitecture::Instruction_SMMLA_A1_0ff000d0_07500010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMMLA{R}<c> <Rd>, <Rn>, <Rm>, <Ra>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smmla);
    rInsn.SetMnemonic("smmla");
    if ((ExtractBit<5>(Opcode)) /* R */)
        rInsn.AddMnemonicSuffix("R");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Ra */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMMLS{R}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '0', '1', '0', '1', 'Rd#4', 'Ra#4', 'Rm#4', '1', '1', 'R#1', '1', 'Rn#4']
bool ArmArchitecture::Instruction_SMMLS_A1_0ff000d0_075000d0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMMLS{R}<c> <Rd>, <Rn>, <Rm>, <Ra>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smmls);
    rInsn.SetMnemonic("smml");
    rInsn.AddMnemonicSuffix("s");
    if ((ExtractBit<5>(Opcode)) /* R */)
        rInsn.AddMnemonicSuffix("R");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Ra */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// USAD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '1', '0', '0', '0', 'Rd#4', '1', '1', '1', '1', 'Rm#4', '0', '0', '0', '1', 'Rn#4']
bool ArmArchitecture::Instruction_USAD8_A1_0ff0f0f0_0780f010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("USAD8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Usad8);
    rInsn.SetMnemonic("usad8");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// USADA8<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '1', '0', '0', '0', 'Rd#4', 'Ra#4', 'Rm#4', '0', '0', '0', '1', 'Rn#4']
bool ArmArchitecture::Instruction_USADA8_A1_0ff000f0_07800010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("USADA8<c> <Rd>, <Rn>, <Rm>, <Ra>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Usada8);
    rInsn.SetMnemonic("usada8");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Ra */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SBFX<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '1', '0', '1', 'widthm1#5', 'Rd#4', 'lsb#5', '1', '0', '1', 'Rn#4']
bool ArmArchitecture::Instruction_SBFX_A1_0fe00070_07a00050(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SBFX<c> <Rd>, <Rn>, #<lsb>, #<width>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sbfx);
    rInsn.SetMnemonic("sbfx");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand #<lsb>";
    // FIXME: not_implemented: "operand #<width>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BFC<c> <Rd>, #<lsb>, #<width> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '1', '1', '0', 'msb#5', 'Rd#4', 'lsb#5', '0', '0', '1', '1', '1', '1', '1']
bool ArmArchitecture::Instruction_BFC_A1_0fe0007f_07c0001f(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BFC<c> <Rd>, #<lsb>, #<width>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Bfc);
    rInsn.SetMnemonic("bfc");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    // FIXME: not_implemented: "operand #<lsb>";
    // FIXME: not_implemented: "operand #<width>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BFI<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '1', '1', '0', 'msb#5', 'Rd#4', 'lsb#5', '0', '0', '1', 'Rn#4']
bool ArmArchitecture::Instruction_BFI_A1_0fe00070_07c00010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BFI<c> <Rd>, <Rn>, #<lsb>, #<width>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Bfi);
    rInsn.SetMnemonic("bfi");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand #<lsb>";
    // FIXME: not_implemented: "operand #<width>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UBFX<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - ['cond#4', '0', '1', '1', '1', '1', '1', '1', 'widthm1#5', 'Rd#4', 'lsb#5', '1', '0', '1', 'Rn#4']
bool ArmArchitecture::Instruction_UBFX_A1_0fe00070_07e00050(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UBFX<c> <Rd>, <Rn>, #<lsb>, #<width>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ubfx);
    rInsn.SetMnemonic("ubfx");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand #<lsb>";
    // FIXME: not_implemented: "operand #<width>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STR<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!} - [] - ['cond#4', '0', '1', '1', 'P#1', 'U#1', '0', 'W#1', '0', 'Rn#4', 'Rt#4', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_STR_A1_0e500010_06000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STR<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Str);
    rInsn.SetMnemonic("str");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDR<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!} - ['could_jmp'] - ['cond#4', '0', '1', '1', 'P#1', 'U#1', '0', 'W#1', '1', 'Rn#4', 'Rt#4', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_LDR_A1_0e500010_06100000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDR<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldr);
    rInsn.SetMnemonic("ldr");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    if ((ExtractBit<23>(Opcode)) /* U */)
        rInsn.AddOperand(Expr::MakeMem(32, nullptr, arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */)));

  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRB<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!} - [] - ['cond#4', '0', '1', '1', 'P#1', 'U#1', '1', 'W#1', '0', 'Rn#4', 'Rt#4', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_STRB_A1_0e500010_06400000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRB<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strb);
    rInsn.SetMnemonic("strb");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRB<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!} - ['could_jmp'] - ['cond#4', '0', '1', '1', 'P#1', 'U#1', '1', 'W#1', '1', 'Rn#4', 'Rt#4', 'imm#5', 'type#2', '0', 'Rm#4']
bool ArmArchitecture::Instruction_LDRB_A1_0e500010_06500000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRB<c> <Rt>, [<Rn>,+/-<Rm>{,<shift>}]{!}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrb);
    rInsn.SetMnemonic("ldrb");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    if ((ExtractBit<23>(Opcode)) /* U */)
      rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */)));

    else
      rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) - arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<5, 6>(Opcode)) /* type */, (ExtractBits<7, 11>(Opcode)) /* imm */)));

  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STMDA<c> <Rn>{!}, <registers> - [] - ['cond#4', '1', '0', '0', '0', '0', '0', 'W#1', '0', 'Rn#4', 'register_list#16']
bool ArmArchitecture::Instruction_STMDA_A1_0fd00000_08000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STMDA<c> <Rn>{!}, <registers>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Stmda);
    rInsn.SetMnemonic("stmda");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeVecId(arm::RegisterList(16, (ExtractBits<0, 15>(Opcode)) /* register_list */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDMDA<c> <Rn>{!}, <registers> - ['could_jmp'] - ['cond#4', '1', '0', '0', '0', '0', '0', 'W#1', '1', 'Rn#4', 'register_list#16']
bool ArmArchitecture::Instruction_LDMDA_A1_0fd00000_08100000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDMDA<c> <Rn>{!}, <registers>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldmda);
    rInsn.SetMnemonic("ldmda");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeVecId(arm::RegisterList(16, (ExtractBits<0, 15>(Opcode)) /* register_list */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// POP<c> <registers> - ['could_ret'] - ['cond#4', '1', '0', '0', '0', '1', '0', '1', '1', '1', '1', '0', '1', 'register_list#16']
bool ArmArchitecture::Instruction_POP_A1_0fff0000_08bd0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("POP<c> <registers>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Pop);
    rInsn.SetMnemonic("pop");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeVecId(arm::RegisterList(16, (ExtractBits<0, 15>(Opcode)) /* register_list */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STM<c> <Rn>{!}, <registers> - [] - ['cond#4', '1', '0', '0', '0', '1', '0', 'W#1', '0', 'Rn#4', 'register_list#16']
bool ArmArchitecture::Instruction_STM_A1_0fd00000_08800000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STM<c> <Rn>{!}, <registers>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Stm);
    rInsn.SetMnemonic("stm");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeVecId(arm::RegisterList(16, (ExtractBits<0, 15>(Opcode)) /* register_list */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDM<c> <Rn>{!}, <registers> - ['could_jmp'] - ['cond#4', '1', '0', '0', '0', '1', '0', 'W#1', '1', 'Rn#4', 'register_list#16']
bool ArmArchitecture::Instruction_LDM_A1_0fd00000_08900000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDM<c> <Rn>{!}, <registers>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldm);
    rInsn.SetMnemonic("ldm");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeVecId(arm::RegisterList(16, (ExtractBits<0, 15>(Opcode)) /* register_list */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// PUSH<c> <registers> - [] - ['cond#4', '1', '0', '0', '1', '0', '0', '1', '0', '1', '1', '0', '1', 'register_list#16']
bool ArmArchitecture::Instruction_PUSH_A1_0fff0000_092d0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("PUSH<c> <registers>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Push);
    rInsn.SetMnemonic("push");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeVecId(arm::RegisterList(16, (ExtractBits<0, 15>(Opcode)) /* register_list */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STMDB<c> <Rn>{!}, <registers> - [] - ['cond#4', '1', '0', '0', '1', '0', '0', 'W#1', '0', 'Rn#4', 'register_list#16']
bool ArmArchitecture::Instruction_STMDB_A1_0fd00000_09000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STMDB<c> <Rn>{!}, <registers>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Stmdb);
    rInsn.SetMnemonic("stmdb");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeVecId(arm::RegisterList(16, (ExtractBits<0, 15>(Opcode)) /* register_list */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDMDB<c> <Rn>{!}, <registers> - ['could_jmp'] - ['cond#4', '1', '0', '0', '1', '0', '0', 'W#1', '1', 'Rn#4', 'register_list#16']
bool ArmArchitecture::Instruction_LDMDB_A1_0fd00000_09100000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDMDB<c> <Rn>{!}, <registers>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldmdb);
    rInsn.SetMnemonic("ldmdb");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeVecId(arm::RegisterList(16, (ExtractBits<0, 15>(Opcode)) /* register_list */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STMIB<c> <Rn>{!}, <registers> - [] - ['cond#4', '1', '0', '0', '1', '1', '0', 'W#1', '0', 'Rn#4', 'register_list#16']
bool ArmArchitecture::Instruction_STMIB_A1_0fd00000_09800000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STMIB<c> <Rn>{!}, <registers>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Stmib);
    rInsn.SetMnemonic("stmib");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeVecId(arm::RegisterList(16, (ExtractBits<0, 15>(Opcode)) /* register_list */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDMIB<c> <Rn>{!}, <registers> - ['could_jmp'] - ['cond#4', '1', '0', '0', '1', '1', '0', 'W#1', '1', 'Rn#4', 'register_list#16']
bool ArmArchitecture::Instruction_LDMIB_A1_0fd00000_09900000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDMIB<c> <Rn>{!}, <registers>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldmib);
    rInsn.SetMnemonic("ldmib");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeVecId(arm::RegisterList(16, (ExtractBits<0, 15>(Opcode)) /* register_list */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// B<c> <arm_branch_label> - ['jmp'] - ['cond#4', '1', '0', '1', '0', 'imm#24']
bool ArmArchitecture::Instruction_B_A1_0f000000_0a000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("B<c> <arm_branch_label>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_B);
    rInsn.SubType() |= Instruction::JumpType;
    rInsn.SetMnemonic("b");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo) + SignExtend<u32, 26>((ExtractBits<0, 23>(Opcode)) << 2 | 0));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BL<c> <arm_branch_label> - ['call'] - ['cond#4', '1', '0', '1', '1', 'imm#24']
bool ArmArchitecture::Instruction_BL_A1_0f000000_0b000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BL<c> <arm_branch_label>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Bl);
    rInsn.SubType() |= Instruction::CallType;
    rInsn.SetMnemonic("bl");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo) + SignExtend<u32, 26>((ExtractBits<0, 23>(Opcode)) << 2 | 0));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MCRR<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm> - ['could_jmp'] - ['cond#4', '1', '1', '0', '0', '0', '1', '0', '0', 'Rt2#4', 'Rt#4', 'coproc#4', 'opc1#4', 'CRm#4']
bool ArmArchitecture::Instruction_MCRR_A1_0ff00000_0c400000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MCRR<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mcrr);
    rInsn.SetMnemonic("mcrr");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <opc1>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rt2 */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <CRm>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MRRC<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm> - ['could_jmp'] - ['cond#4', '1', '1', '0', '0', '0', '1', '0', '1', 'Rt2#4', 'Rt#4', 'coproc#4', 'opc1#4', 'CRm#4']
bool ArmArchitecture::Instruction_MRRC_A1_0ff00000_0c500000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MRRC<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mrrc);
    rInsn.SetMnemonic("mrrc");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <opc>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rt2 */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <CRm>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMOV<c> <Rt>, <Rt2>, <Sm>, <Sm1> - ['support it block'] - ['cond#4', '1', '1', '0', '0', '0', '1', '0', 'op#1', 'Rt2#4', 'Rt#4', '1', '0', '1', '0', '0', '0', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VMOV_A1_0fe00fd0_0c400a10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMOV<c> <Rt>, <Rt2>, <Sm>, <Sm1>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmov);
    rInsn.SetMnemonic("vmov");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rt2 */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Sm1>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMOV<c> <Rt>, <Rt2>, <Dm> - ['support it block'] - ['cond#4', '1', '1', '0', '0', '0', '1', '0', 'op#1', 'Rt2#4', 'Rt#4', '1', '0', '1', '1', '0', '0', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VMOV_A1_0fe00fd0_0c400b10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMOV<c> <Rt>, <Rt2>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmov);
    rInsn.SetMnemonic("vmov");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rt2 */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// FLDMX - ['support it block'] - ['cond#4', '1', '1', '0', '0', '1', 'D#1', '1', '1', '1', '1', '0', '1', 'Vd#4', '1', '0', '1', '0', 'imm#8']
bool ArmArchitecture::Instruction_FLDMX_A2_0fbf0f00_0cbd0a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("FLDMX");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Fldmx);
    rInsn.SetMnemonic("fldmx");
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VPOP <list> - [] - ['cond#4', '1', '1', '0', '0', '1', 'D#1', '1', '1', '1', '1', '0', '1', 'Vd#4', '1', '0', '1', '1', 'imm#8']
bool ArmArchitecture::Instruction_VPOP_A1_0fbf0f00_0cbd0b00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VPOP <list>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vpop);
    rInsn.SetMnemonic("vpop");
    // FIXME: not_implemented: "operand <list>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// FSTMX - ['support it block'] - ['cond#4', '1', '1', '0', '1', '0', 'D#1', '1', '0', '1', '1', '0', '1', 'Vd#4', '1', '0', '1', '0', 'imm#8']
bool ArmArchitecture::Instruction_FSTMX_A2_0fbf0f00_0d2d0a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("FSTMX");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Fstmx);
    rInsn.SetMnemonic("fstmx");
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VPUSH<c> <list> - [] - ['cond#4', '1', '1', '0', '1', '0', 'D#1', '1', '0', '1', '1', '0', '1', 'Vd#4', '1', '0', '1', '1', 'imm#8']
bool ArmArchitecture::Instruction_VPUSH_A1_0fbf0f00_0d2d0b00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VPUSH<c> <list>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vpush);
    rInsn.SetMnemonic("vpush");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    // FIXME: not_implemented: "operand <list>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSTR<c> <Sd>, [<Rn>{,#+/-<imm>}] - [] - ['cond#4', '1', '1', '0', '1', 'U#1', 'D#1', '0', '0', 'Rn#4', 'Vd#4', '1', '0', '1', '0', 'imm#8']
bool ArmArchitecture::Instruction_VSTR_A2_0f300f00_0d000a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSTR<c> <Sd>, [<Rn>{,#+/-<imm>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vstr);
    rInsn.SetMnemonic("vstr");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand [<Rn>{,#+/-<imm>}]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSTR<c> <Dd>, [<Rn>{,#+/-<imm>}] - [] - ['cond#4', '1', '1', '0', '1', 'U#1', 'D#1', '0', '0', 'Rn#4', 'Vd#4', '1', '0', '1', '1', 'imm#8']
bool ArmArchitecture::Instruction_VSTR_A1_0f300f00_0d000b00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSTR<c> <Dd>, [<Rn>{,#+/-<imm>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vstr);
    rInsn.SetMnemonic("vstr");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand [<Rn>{,#+/-<imm>}]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VLDR<c> <Sd>, [PC,#-0] - ['support it block', 'support it block'] - ['cond#4', '1', '1', '0', '1', 'U#1', 'D#1', '0', '1', 'Rn#4', 'Vd#4', '1', '0', '1', '0', 'imm#8']
bool ArmArchitecture::Instruction_VLDR_A2_0f300f00_0d100a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VLDR<c> <Sd>, [PC,#-0]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vldr);
    rInsn.SetMnemonic("vldr");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VLDR<c> <Dd>, [PC,#-0] - ['support it block', 'support it block'] - ['cond#4', '1', '1', '0', '1', 'U#1', 'D#1', '0', '1', 'Rn#4', 'Vd#4', '1', '0', '1', '1', 'imm#8']
bool ArmArchitecture::Instruction_VLDR_A1_0f300f00_0d100b00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VLDR<c> <Dd>, [PC,#-0]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vldr);
    rInsn.SetMnemonic("vldr");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STC{L}<c> <coproc>, <CRd>, [<Rn>],<option> - ['support it block', 'support it block'] - ['cond#4', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '0', 'Rn#4', 'CRd#4', 'coproc#4', 'imm#8']
bool ArmArchitecture::Instruction_STC_A1_0e100000_0c000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STC{L}<c> <coproc>, <CRd>, [<Rn>],<option>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Stc);
    rInsn.SetMnemonic("stc");
    if ((ExtractBit<22>(Opcode)) /* D */)
        rInsn.AddMnemonicSuffix("L");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <CRd>";
    // FIXME: not_implemented: "operand [<Rn>],<option>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// FSTMX - ['support it block'] - ['cond#4', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '0', 'Rn#4', 'Vd#4', '1', '0', '1', '0', 'imm#8']
bool ArmArchitecture::Instruction_FSTMX_A2_0e100f00_0c000a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("FSTMX");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Fstmx);
    rInsn.SetMnemonic("fstmx");
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSTM{mode}<c> <Rn>{!},  <list> - [] - ['cond#4', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '0', 'Rn#4', 'Vd#4', '1', '0', '1', '1', 'imm#8']
bool ArmArchitecture::Instruction_VSTM_A1_0e100f00_0c000b00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSTM{mode}<c> <Rn>{!},  <list>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vstm);
    rInsn.SetMnemonic("vstm");
    // FIXME: not_implemented: "field {mode}";
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand ";
    // FIXME: not_implemented: "operand <list>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDC{L}<c> <coproc>, <CRd>, [PC],<option> - ['support it block', 'support it block'] - ['cond#4', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', '1', '1', '1', '1', 'CRd#4', 'coproc#4', 'imm#8']
bool ArmArchitecture::Instruction_LDC_A1_0e1f0000_0c1f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDC{L}<c> <coproc>, <CRd>, [PC],<option>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldc);
    rInsn.SetMnemonic("ldc");
    if ((ExtractBit<22>(Opcode)) /* D */)
        rInsn.AddMnemonicSuffix("L");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <CRd>";
    // FIXME: not_implemented: "operand [PC],<option>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDC{L}<c> <coproc>, <CRd>, [<Rn>],<option> - ['support it block', 'support it block'] - ['cond#4', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', 'Rn#4', 'CRd#4', 'coproc#4', 'imm#8']
bool ArmArchitecture::Instruction_LDC_A1_0e100000_0c100000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDC{L}<c> <coproc>, <CRd>, [<Rn>],<option>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldc);
    rInsn.SetMnemonic("ldc");
    if ((ExtractBit<22>(Opcode)) /* D */)
        rInsn.AddMnemonicSuffix("L");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <CRd>";
    // FIXME: not_implemented: "operand [<Rn>],<option>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// FLDMX - ['support it block'] - ['cond#4', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', 'Rn#4', 'Vd#4', '1', '0', '1', '0', 'imm#8']
bool ArmArchitecture::Instruction_FLDMX_A2_0e100f00_0c100a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("FLDMX");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Fldmx);
    rInsn.SetMnemonic("fldmx");
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VLDM{mode}<c> <Rn>{!},  <list> - [] - ['cond#4', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', 'Rn#4', 'Vd#4', '1', '0', '1', '1', 'imm#8']
bool ArmArchitecture::Instruction_VLDM_A1_0e100f00_0c100b00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VLDM{mode}<c> <Rn>{!},  <list>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vldm);
    rInsn.SetMnemonic("vldm");
    // FIXME: not_implemented: "field {mode}";
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand ";
    // FIXME: not_implemented: "operand <list>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMOV<c> <Rt>, <Sn> - ['support it block'] - ['cond#4', '1', '1', '1', '0', '0', '0', '0', 'op#1', 'Vn#4', 'Rt#4', '1', '0', '1', '0', 'N#1', '(0)', '(0)', '1', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VMOV_A1_0fe00f7f_0e000a10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMOV<c> <Rt>, <Sn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmov);
    rInsn.SetMnemonic("vmov");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op><c>.F32 <Sd>, <Sn>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '0', 'D#1', '0', '0', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', 'op#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_V_A2_0fb00e10_0e000a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op><c>.F32 <Sd>, <Sn>, <Sm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VNMLS<c>.F32 <Sd>, <Sn>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '0', 'D#1', '0', '1', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', 'op#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VNMLS_A1_0fb00e10_0e100a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VNMLS<c>.F32 <Sd>, <Sn>, <Sm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vnmls);
    rInsn.SetMnemonic("vnml");
    rInsn.AddMnemonicSuffix("s");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMUL<c>.F32 <Sd>, <Sn>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '0', 'D#1', '1', '0', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VMUL_A2_0fb00e50_0e200a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMUL<c>.F32 <Sd>, <Sn>, <Sm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmul);
    rInsn.SetMnemonic("vmul");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VNMUL<c>.F32 <Sd>, <Sn>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '0', 'D#1', '1', '0', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VNMUL_A2_0fb00e50_0e200a40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VNMUL<c>.F32 <Sd>, <Sn>, <Sm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vnmul);
    rInsn.SetMnemonic("vnmul");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VADD<c>.F32 <Sd>, <Sn>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '0', 'D#1', '1', '1', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VADD_A2_0fb00e50_0e300a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VADD<c>.F32 <Sd>, <Sn>, <Sm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vadd);
    rInsn.SetMnemonic("vadd");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSUB<c>.F32 <Sd>, <Sn>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '0', 'D#1', '1', '1', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VSUB_A2_0fb00e50_0e300a40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSUB<c>.F32 <Sd>, <Sn>, <Sm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vsub);
    rInsn.SetMnemonic("vsub");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMOV<c>.<size> <Dd[x]>, <Rt> - [] - ['cond#4', '1', '1', '1', '0', '0', 'opc1#2', '0', 'Vd#4', 'Rt#4', '1', '0', '1', '1', 'D#1', 'opc2#2', '1', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VMOV_A1_0f900f1f_0e000b10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMOV<c>.<size> <Dd[x]>, <Rt>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmov);
    rInsn.SetMnemonic("vmov");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    // FIXME: not_implemented: "operand <Dd[x]>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMSR<c> FPSCR, <Rt> - [] - ['cond#4', '1', '1', '1', '0', '1', '1', '1', '0', '0', '0', '0', '1', 'Rt#4', '1', '0', '1', '0', '0', '(0)', '(0)', '1', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VMSR_A1_0fff0fff_0ee10a10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMSR<c> FPSCR, <Rt>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmsr);
    rInsn.SetMnemonic("vmsr");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    // FIXME: not_implemented: "operand FPSCR";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMRS<c> <Rt>, FPSCR - [] - ['cond#4', '1', '1', '1', '0', '1', '1', '1', '1', '0', '0', '0', '1', 'Rt#4', '1', '0', '1', '0', '0', '(0)', '(0)', '1', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VMRS_A1_0fff0fff_0ef10a10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMRS<c> <Rt>, FPSCR");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmrs);
    rInsn.SetMnemonic("vmr");
    rInsn.AddMnemonicSuffix("s");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    // FIXME: not_implemented: "operand FPSCR";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VDIV<c>.F32 <Sd>, <Sn>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '0', '0', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VDIV_A1_0fb00e50_0e800a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VDIV<c>.F32 <Sd>, <Sn>, <Sm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vdiv);
    rInsn.SetMnemonic("vdiv");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMOV<c>.F32 <Sd>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '0', '0', '0', 'Vd#4', '1', '0', '1', 'sz#1', '0', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VMOV_A2_0fbf0ed0_0eb00a40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMOV<c>.F32 <Sd>, <Sm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmov);
    rInsn.SetMnemonic("vmov");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VABS<c>.F32 <Sd>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '0', '0', '0', 'Vd#4', '1', '0', '1', 'sz#1', '1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VABS_A2_0fbf0ed0_0eb00ac0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VABS<c>.F32 <Sd>, <Sm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vabs);
    rInsn.SetMnemonic("vab");
    rInsn.AddMnemonicSuffix("s");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VNEG<c>.F32 <Sd>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '0', '0', '1', 'Vd#4', '1', '0', '1', 'sz#1', '0', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VNEG_A2_0fbf0ed0_0eb10a40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VNEG<c>.F32 <Sd>, <Sm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vneg);
    rInsn.SetMnemonic("vneg");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSQRT<c>.F32 <Sd>, <Sm> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '0', '0', '1', 'Vd#4', '1', '0', '1', 'sz#1', '1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VSQRT_A1_0fbf0ed0_0eb10ac0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSQRT<c>.F32 <Sd>, <Sm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vsqrt);
    rInsn.SetMnemonic("vsqrt");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCVT<y><c>.F16.F32 <Sd>, <Sm> - ['support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '0', '1', 'op#1', 'Vd#4', '1', '0', '1', '0', 'T#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCVT_A1_0fbe0f50_0eb20a40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCVT<y><c>.F16.F32 <Sd>, <Sm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcvt);
    rInsn.SetMnemonic("vcvt");
    if ((ExtractBit<5>(Opcode)) /* M */)
      rInsn.AddMnemonicSuffix("t");

    else
      rInsn.AddMnemonicSuffix("b");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddMnemonicSuffix(".F16");
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCMP{E}<c>.F32 <Sd>, <Sm> - ['support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '1', '0', '0', 'Vd#4', '1', '0', '1', 'sz#1', 'E#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCMP_A1_0fbf0e50_0eb40a40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCMP{E}<c>.F32 <Sd>, <Sm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcmp);
    rInsn.SetMnemonic("vcmp");
    if ((ExtractBit<7>(Opcode)) /* E */)
        rInsn.AddMnemonicSuffix("E");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCMP{E}<c>.F32 <Sd>, #0.0 - ['support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '1', '0', '1', 'Vd#4', '1', '0', '1', 'sz#1', 'E#1', '1', '(0)', '0', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VCMP_A2_0fbf0e7f_0eb50a40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCMP{E}<c>.F32 <Sd>, #0.0");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcmp);
    rInsn.SetMnemonic("vcmp");
    if ((ExtractBit<7>(Opcode)) /* E */)
        rInsn.AddMnemonicSuffix("E");

    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(BitVector(0.0f)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCVT<c>.F32.F64 <Sd>, <Dm> - ['support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '1', '1', '1', 'Vd#4', '1', '0', '1', 'sz#1', '1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCVT_A1_0fbf0ed0_0eb70ac0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCVT<c>.F32.F64 <Sd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcvt);
    rInsn.SetMnemonic("vcvt");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddMnemonicSuffix(".F64");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCVT<c>.F32.<Td> <Sd>, <Sd>, #<fbits> - ['support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', '1', 'op#1', '1', 'U#1', 'Vd#4', '1', '0', '1', 'sf#1', 'sx#1', '1', 'imm#1', '0', 'imm#4']
bool ArmArchitecture::Instruction_VCVT_A1_0fba0e50_0eba0a40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCVT<c>.F32.<Td> <Sd>, <Sd>, #<fbits>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcvt);
    rInsn.SetMnemonic("vcvt");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddMnemonicSuffix(".");
    if ((ExtractBit<7>(Opcode)) /* sx */)
      rInsn.AddMnemonicSuffix("32");

    else
      rInsn.AddMnemonicSuffix("16");

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand #<fbits>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCVT<c>.F32.<Tm> <Sd>, <Sm> - ['support it block', 'support it block', 'support it block', 'support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', '1', 'opc2#3', 'Vd#4', '1', '0', '1', 'sz#1', 'op#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCVT_A1_0fb80e50_0eb80a40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCVT<c>.F32.<Tm> <Sd>, <Sm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcvt);
    rInsn.SetMnemonic("vcvt");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddMnemonicSuffix(".");
    if ((ExtractBit<7>(Opcode)) /* op */)
      rInsn.AddMnemonicSuffix("S");

    else
      rInsn.AddMnemonicSuffix("U");

    rInsn.AddMnemonicSuffix("32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMOV<c>.F32 <Sd>, #<imm> - ['support it block', 'support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'D#1', '1', '1', 'imm_h#4', 'Vd#4', '1', '0', '1', 'sz#1', '(0)', '0', '(0)', '0', 'imm_l#4']
bool ArmArchitecture::Instruction_VMOV_A2_0fb00ef0_0eb00a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMOV<c>.F32 <Sd>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmov);
    rInsn.SetMnemonic("vmov");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 19>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VDUP<c>.<size> - ['support it block'] - ['cond#4', '1', '1', '1', '0', '1', 'b_size#1', 'Q#1', '0', 'Vd#4', 'Rt#4', '1', '0', '1', '1', 'D#1', '0', 'e_size#1', '1', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VDUP_A1_0f900f5f_0e800b10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VDUP<c>.<size>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vdup);
    rInsn.SetMnemonic("vdup");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMOV<c>.<dt> <Rt>, <Dn[x]> - [] - ['cond#4', '1', '1', '1', '0', 'U#1', 'opc1#2', '1', 'Vn#4', 'Rt#4', '1', '0', '1', '1', 'N#1', 'opc2#2', '1', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VMOV_A1_0f100f1f_0e100b10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMOV<c>.<dt> <Rt>, <Dn[x]>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmov);
    rInsn.SetMnemonic("vmov");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddMnemonicSuffix(".");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Dn[x]>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MCR<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - [] - ['cond#4', '1', '1', '1', '0', 'opc1#3', '0', 'CRn#4', 'Rt#4', 'coproc#4', 'opc2#3', '1', 'CRm#4']
bool ArmArchitecture::Instruction_MCR_A1_0f100010_0e000010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MCR<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mcr);
    rInsn.SetMnemonic("mcr");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <opc1>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <CRn>";
    // FIXME: not_implemented: "operand <CRm>{,<opc2>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MRC<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['could_jmp'] - ['cond#4', '1', '1', '1', '0', 'opc1#3', '1', 'CRn#4', 'Rt#4', 'coproc#4', 'opc2#3', '1', 'CRm#4']
bool ArmArchitecture::Instruction_MRC_A1_0f100010_0e100010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MRC<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mrc);
    rInsn.SetMnemonic("mrc");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <opc1>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <CRn>";
    // FIXME: not_implemented: "operand <CRm>{,<opc2>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CDP<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2> - [] - ['cond#4', '1', '1', '1', '0', 'opc1#4', 'CRn#4', 'CRd#4', 'coproc#4', 'opc2#3', '0', 'CRm#4']
bool ArmArchitecture::Instruction_CDP_A1_0f000010_0e000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CDP<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Cdp);
    rInsn.SetMnemonic("cdp");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <opc1>";
    // FIXME: not_implemented: "operand <CRd>";
    // FIXME: not_implemented: "operand <CRn>";
    // FIXME: not_implemented: "operand <CRm>";
    // FIXME: not_implemented: "operand <opc2>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SVC<c> #<imm> - ['syscall'] - ['cond#4', '1', '1', '1', '1', 'imm#24']
bool ArmArchitecture::Instruction_SVC_A1_0f000000_0f000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SVC<c> #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Svc);
    rInsn.SetMnemonic("svc");
    rInsn.SetTestedFlags(arm::ConditionFromValue((ExtractBits<28, 31>(Opcode)) /* cond */));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 23>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MOVS <Rd>, <Rm> - ['could_jmp'] - ['0', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'Rm#3', 'Rd#3']
bool ArmArchitecture::Instruction_MOVS_T2_0000ffc0_00000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MOVS <Rd>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Movs);
    rInsn.SetMnemonic("mov");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LSLS <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['0', '0', '0', '0', '0', 'imm#5', 'Rm#3', 'Rd#3']
bool ArmArchitecture::Instruction_LSLS_T1_0000f800_00000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LSLS <Rd>, <Rm>, #<imm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Lsls);
    rInsn.SetMnemonic("lsl");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<6, 10>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LSRS <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['0', '0', '0', '0', '1', 'imm#5', 'Rm#3', 'Rd#3']
bool ArmArchitecture::Instruction_LSRS_T1_0000f800_00000800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LSRS <Rd>, <Rm>, #<imm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Lsrs);
    rInsn.SetMnemonic("lsr");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<6, 10>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ASRS <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['0', '0', '0', '1', '0', 'imm#5', 'Rm#3', 'Rd#3']
bool ArmArchitecture::Instruction_ASRS_T1_0000f800_00001000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ASRS <Rd>, <Rm>, #<imm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Asrs);
    rInsn.SetMnemonic("asr");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<6, 10>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADDS <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['0', '0', '0', '1', '1', '0', '0', 'Rm#3', 'Rn#3', 'Rd#3']
bool ArmArchitecture::Instruction_ADDS_T1_0000fe00_00001800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADDS <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Adds);
    rInsn.SetMnemonic("add");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<6, 8>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SUBS <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['0', '0', '0', '1', '1', '0', '1', 'Rm#3', 'Rn#3', 'Rd#3']
bool ArmArchitecture::Instruction_SUBS_T1_0000fe00_00001a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SUBS <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Subs);
    rInsn.SetMnemonic("sub");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<6, 8>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADDS <Rd>, <Rn>, #<imm> - [] - ['0', '0', '0', '1', '1', '1', '0', 'imm#3', 'Rn#3', 'Rd#3']
bool ArmArchitecture::Instruction_ADDS_T1_0000fe00_00001c00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADDS <Rd>, <Rn>, #<imm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Adds);
    rInsn.SetMnemonic("add");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<6, 8>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SUBS <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['0', '0', '0', '1', '1', '1', '1', 'imm#3', 'Rn#3', 'Rd#3']
bool ArmArchitecture::Instruction_SUBS_T1_0000fe00_00001e00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SUBS <Rd>, <Rn>, #<imm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Subs);
    rInsn.SetMnemonic("sub");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<6, 8>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MOVS <Rd>, #<imm> - ['could_jmp'] - ['0', '0', '1', '0', '0', 'Rd#3', 'imm#8']
bool ArmArchitecture::Instruction_MOVS_T1_0000f800_00002000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MOVS <Rd>, #<imm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Movs);
    rInsn.SetMnemonic("mov");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 10>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CMP<c> <Rn>, #<imm> - ['cond'] - ['0', '0', '1', '0', '1', 'Rn#3', 'imm#8']
bool ArmArchitecture::Instruction_CMP_T1_0000f800_00002800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CMP<c> <Rn>, #<imm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Cmp);
    rInsn.SetMnemonic("cmp");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 10>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADDS <Rdn>, #<imm> - ['could_jmp'] - ['0', '0', '1', '1', '0', 'Rdn#3', 'imm#8']
bool ArmArchitecture::Instruction_ADDS_T2_0000f800_00003000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADDS <Rdn>, #<imm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Adds);
    rInsn.SetMnemonic("add");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 10>(Opcode)) /* Rdn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SUBS <Rdn>, #<imm> - ['could_jmp'] - ['0', '0', '1', '1', '1', 'Rdn#3', 'imm#8']
bool ArmArchitecture::Instruction_SUBS_T2_0000f800_00003800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SUBS <Rdn>, #<imm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Subs);
    rInsn.SetMnemonic("sub");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 10>(Opcode)) /* Rdn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ANDS <Rdn>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '0', '0', '0', '0', 'Rm#3', 'Rdn#3']
bool ArmArchitecture::Instruction_ANDS_T1_0000ffc0_00004000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ANDS <Rdn>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Ands);
    rInsn.SetMnemonic("and");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rdn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// EORS <Rdn>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '0', '0', '0', '1', 'Rm#3', 'Rdn#3']
bool ArmArchitecture::Instruction_EORS_T1_0000ffc0_00004040(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("EORS <Rdn>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Eors);
    rInsn.SetMnemonic("eor");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rdn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LSLS <Rdn>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '0', '0', '1', '0', 'Rm#3', 'Rdn#3']
bool ArmArchitecture::Instruction_LSLS_T1_0000ffc0_00004080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LSLS <Rdn>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Lsls);
    rInsn.SetMnemonic("lsl");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rdn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LSRS <Rdn>, <Rm> - ['support it block', 'could_jmp'] - ['0', '1', '0', '0', '0', '0', '0', '0', '1', '1', 'Rm#3', 'Rdn#3']
bool ArmArchitecture::Instruction_LSRS_T1_0000ffc0_000040c0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LSRS <Rdn>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Lsrs);
    rInsn.SetMnemonic("lsr");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rdn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ASRS <Rdn>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '0', '1', '0', '0', 'Rm#3', 'Rdn#3']
bool ArmArchitecture::Instruction_ASRS_T1_0000ffc0_00004100(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ASRS <Rdn>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Asrs);
    rInsn.SetMnemonic("asr");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rdn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADCS <Rdn>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '0', '1', '0', '1', 'Rm#3', 'Rdn#3']
bool ArmArchitecture::Instruction_ADCS_T1_0000ffc0_00004140(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADCS <Rdn>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Adcs);
    rInsn.SetMnemonic("adc");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rdn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SBCS <Rdn>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '0', '1', '1', '0', 'Rm#3', 'Rdn#3']
bool ArmArchitecture::Instruction_SBCS_T1_0000ffc0_00004180(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SBCS <Rdn>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Sbcs);
    rInsn.SetMnemonic("sbc");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rdn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// RORS <Rdn>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '0', '1', '1', '1', 'Rm#3', 'Rdn#3']
bool ArmArchitecture::Instruction_RORS_T1_0000ffc0_000041c0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("RORS <Rdn>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Rors);
    rInsn.SetMnemonic("ror");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rdn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// TST<c> <Rn>, <Rm> - [] - ['0', '1', '0', '0', '0', '0', '1', '0', '0', '0', 'Rm#3', 'Rn#3']
bool ArmArchitecture::Instruction_TST_T1_0000ffc0_00004200(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("TST<c> <Rn>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Tst);
    rInsn.SetMnemonic("tst");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// RSBS <Rd>, <Rn>, #0 - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '1', '0', '0', '1', 'Rn#3', 'Rd#3']
bool ArmArchitecture::Instruction_RSBS_T1_0000ffc0_00004240(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("RSBS <Rd>, <Rn>, #0");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Rsbs);
    rInsn.SetMnemonic("rsb");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, 0x0));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CMP<c> <Rn>, <Rm> - ['cond'] - ['0', '1', '0', '0', '0', '0', '1', '0', '1', '0', 'Rm#3', 'Rn#3']
bool ArmArchitecture::Instruction_CMP_T1_0000ffc0_00004280(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CMP<c> <Rn>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Cmp);
    rInsn.SetMnemonic("cmp");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CMN<c> <Rn>, <Rm> - ['cond'] - ['0', '1', '0', '0', '0', '0', '1', '0', '1', '1', 'Rm#3', 'Rn#3']
bool ArmArchitecture::Instruction_CMN_T1_0000ffc0_000042c0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CMN<c> <Rn>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Cmn);
    rInsn.SetMnemonic("cmn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ORRS <Rdn>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '1', '1', '0', '0', 'Rm#3', 'Rdn#3']
bool ArmArchitecture::Instruction_ORRS_T1_0000ffc0_00004300(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ORRS <Rdn>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Orrs);
    rInsn.SetMnemonic("orr");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rdn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MULS <Rdm>, <Rn> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '1', '1', '0', '1', 'Rn#3', 'Rdm#3']
bool ArmArchitecture::Instruction_MULS_T1_0000ffc0_00004340(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MULS <Rdm>, <Rn>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Muls);
    rInsn.SetMnemonic("mul");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rdm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rn */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BICS <Rdn>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '1', '1', '1', '0', 'Rm#3', 'Rdn#3']
bool ArmArchitecture::Instruction_BICS_T1_0000ffc0_00004380(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BICS <Rdn>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Bics);
    rInsn.SetMnemonic("bic");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rdn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MVNS <Rd>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '0', '1', '1', '1', '1', 'Rm#3', 'Rd#3']
bool ArmArchitecture::Instruction_MVNS_T1_0000ffc0_000043c0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MVNS <Rd>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Mvns);
    rInsn.SetMnemonic("mvn");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADD<c> SP,<Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '1', '0', '0', '1', 'Rm#4', '1', '0', '1']
bool ArmArchitecture::Instruction_ADD_T2_0000ff87_00004485(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADD<c> SP,<Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Add);
    rInsn.SetMnemonic("add");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Sp, &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 6>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADD<c> <Rdm>, SP, <Rdm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '1', '0', '0', 'DM#1', '1', '1', '0', '1', 'Rdm#3']
bool ArmArchitecture::Instruction_ADD_T1_0000ff78_00004468(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADD<c> <Rdm>, SP, <Rdm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Add);
    rInsn.SetMnemonic("add");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBit<7>(Opcode)) << 3 | (ExtractBits<0, 2>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Sp, &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBit<7>(Opcode)) << 3 | (ExtractBits<0, 2>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADD<c> <Rdn>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '1', '0', '0', 'DN#1', 'Rm#4', 'Rdn#3']
bool ArmArchitecture::Instruction_ADD_T2_0000ff00_00004400(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADD<c> <Rdn>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Add);
    rInsn.SetMnemonic("add");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rdn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 6>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CMP<c> <Rn>, <Rm> - ['cond'] - ['0', '1', '0', '0', '0', '1', '0', '1', 'N#1', 'Rm#4', 'Rn#3']
bool ArmArchitecture::Instruction_CMP_T2_0000ff00_00004500(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CMP<c> <Rn>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Cmp);
    rInsn.SetMnemonic("cmp");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 6>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MOV<c> <Rd>, <Rm> - ['could_jmp'] - ['0', '1', '0', '0', '0', '1', '1', '0', 'D#1', 'Rm#4', 'Rd#3']
bool ArmArchitecture::Instruction_MOV_T1_0000ff00_00004600(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MOV<c> <Rd>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Mov);
    rInsn.SetMnemonic("mov");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 6>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BX<c> <Rm> - ['call'] - ['0', '1', '0', '0', '0', '1', '1', '1', '0', 'Rm#4', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_BX_T1_0000ff87_00004700(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BX<c> <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Bx);
    rInsn.SubType() |= Instruction::CallType;
    rInsn.SetMnemonic("bx");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 6>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BLX<c> <Rm> - ['call'] - ['0', '1', '0', '0', '0', '1', '1', '1', '1', 'Rm#4', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_BLX_T1_0000ff87_00004780(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BLX<c> <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Blx);
    rInsn.SubType() |= Instruction::CallType;
    rInsn.SetMnemonic("blx");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 6>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDR<c> <Rt>, <label> - ['could_jmp'] - ['0', '1', '0', '0', '1', 'Rt#3', 'imm#8']
bool ArmArchitecture::Instruction_LDR_T1_0000f800_00004800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDR<c> <Rt>, <label>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Ldr);
    rInsn.SetMnemonic("ldr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 10>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo) + (ExtractBits<0, 7>(Opcode)) /* imm */);
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STR<c> <Rt>, [<Rn>, <Rm>] - [] - ['0', '1', '0', '1', '0', '0', '0', 'Rm#3', 'Rn#3', 'Rt#3']
bool ArmArchitecture::Instruction_STR_T1_0000fe00_00005000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STR<c> <Rt>, [<Rn>, <Rm>]");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Str);
    rInsn.SetMnemonic("str");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<6, 8>(Opcode)) /* Rm */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRH<c> <Rt>, [<Rn>, <Rm>] - [] - ['0', '1', '0', '1', '0', '0', '1', 'Rm#3', 'Rn#3', 'Rt#3']
bool ArmArchitecture::Instruction_STRH_T1_0000fe00_00005200(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRH<c> <Rt>, [<Rn>, <Rm>]");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Strh);
    rInsn.SetMnemonic("strh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<6, 8>(Opcode)) /* Rm */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRB<c> <Rt>, [<Rn>, <Rm>] - [] - ['0', '1', '0', '1', '0', '1', '0', 'Rm#3', 'Rn#3', 'Rt#3']
bool ArmArchitecture::Instruction_STRB_T1_0000fe00_00005400(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRB<c> <Rt>, [<Rn>, <Rm>]");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Strb);
    rInsn.SetMnemonic("strb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<6, 8>(Opcode)) /* Rm */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSB<c> <Rt>, [<Rn>, <Rm>] - ['could_jmp'] - ['0', '1', '0', '1', '0', '1', '1', 'Rm#3', 'Rn#3', 'Rt#3']
bool ArmArchitecture::Instruction_LDRSB_T1_0000fe00_00005600(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSB<c> <Rt>, [<Rn>, <Rm>]");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Ldrsb);
    rInsn.SetMnemonic("ldrsb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<6, 8>(Opcode)) /* Rm */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDR<c> <Rt>, [<Rn>, <Rm>] - ['could_jmp'] - ['0', '1', '0', '1', '1', '0', '0', 'Rm#3', 'Rn#3', 'Rt#3']
bool ArmArchitecture::Instruction_LDR_T1_0000fe00_00005800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDR<c> <Rt>, [<Rn>, <Rm>]");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Ldr);
    rInsn.SetMnemonic("ldr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<6, 8>(Opcode)) /* Rm */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRH<c> <Rt>, [<Rn>, <Rm>] - ['could_jmp'] - ['0', '1', '0', '1', '1', '0', '1', 'Rm#3', 'Rn#3', 'Rt#3']
bool ArmArchitecture::Instruction_LDRH_T1_0000fe00_00005a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRH<c> <Rt>, [<Rn>, <Rm>]");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Ldrh);
    rInsn.SetMnemonic("ldrh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<6, 8>(Opcode)) /* Rm */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRB<c> <Rt>, [<Rn>, <Rm>] - ['could_jmp'] - ['0', '1', '0', '1', '1', '1', '0', 'Rm#3', 'Rn#3', 'Rt#3']
bool ArmArchitecture::Instruction_LDRB_T1_0000fe00_00005c00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRB<c> <Rt>, [<Rn>, <Rm>]");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Ldrb);
    rInsn.SetMnemonic("ldrb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<6, 8>(Opcode)) /* Rm */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSH<c> <Rt>, [<Rn>, <Rm>] - ['could_jmp'] - ['0', '1', '0', '1', '1', '1', '1', 'Rm#3', 'Rn#3', 'Rt#3']
bool ArmArchitecture::Instruction_LDRSH_T1_0000fe00_00005e00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSH<c> <Rt>, [<Rn>, <Rm>]");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Ldrsh);
    rInsn.SetMnemonic("ldrsh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<6, 8>(Opcode)) /* Rm */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STR<c> <Rt>, [<Rn>{, #<disp>}] - [] - ['0', '1', '1', '0', '0', 'imm#5', 'Rn#3', 'Rt#3']
bool ArmArchitecture::Instruction_STR_T1_0000f800_00006000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STR<c> <Rt>, [<Rn>{, #<disp>}]");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Str);
    rInsn.SetMnemonic("str");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<6, 10>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDR<c> <Rt>, [<Rn>{, #<disp>}] - ['could_jmp'] - ['0', '1', '1', '0', '1', 'imm#5', 'Rn#3', 'Rt#3']
bool ArmArchitecture::Instruction_LDR_T1_0000f800_00006800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDR<c> <Rt>, [<Rn>{, #<disp>}]");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Ldr);
    rInsn.SetMnemonic("ldr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<6, 10>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRB<c> <Rt>, [<Rn>, #<imm5>] - [] - ['0', '1', '1', '1', '0', 'imm#5', 'Rn#3', 'Rt#3']
bool ArmArchitecture::Instruction_STRB_T1_0000f800_00007000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRB<c> <Rt>, [<Rn>, #<imm5>]");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Strb);
    rInsn.SetMnemonic("strb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rt */), &m_CpuInfo));
    // FIXME: not_implemented: "[<Rn>";
    // FIXME: not_implemented: "operand #<imm5>]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRB<c> <Rt>, [<Rn>{, #<disp>}] - ['could_jmp'] - ['0', '1', '1', '1', '1', 'imm#5', 'Rn#3', 'Rt#3']
bool ArmArchitecture::Instruction_LDRB_T1_0000f800_00007800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRB<c> <Rt>, [<Rn>{, #<disp>}]");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Ldrb);
    rInsn.SetMnemonic("ldrb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<6, 10>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRH<c> <Rt>, [<Rn>{, #<disp>}] - [] - ['1', '0', '0', '0', '0', 'imm#5', 'Rn#3', 'Rt#3']
bool ArmArchitecture::Instruction_STRH_T1_0000f800_00008000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRH<c> <Rt>, [<Rn>{, #<disp>}]");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Strh);
    rInsn.SetMnemonic("strh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<6, 10>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRH<c> <Rt>, [<Rn>{, #<disp>}] - ['could_jmp'] - ['1', '0', '0', '0', '1', 'imm#5', 'Rn#3', 'Rt#3']
bool ArmArchitecture::Instruction_LDRH_T1_0000f800_00008800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRH<c> <Rt>, [<Rn>{, #<disp>}]");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Ldrh);
    rInsn.SetMnemonic("ldrh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<6, 10>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STR<c> <Rt>, [SP, #<imm>] - [] - ['1', '0', '0', '1', '0', 'Rt#3', 'imm#8']
bool ArmArchitecture::Instruction_STR_T2_0000f800_00009000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STR<c> <Rt>, [SP, #<imm>]");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Str);
    rInsn.SetMnemonic("str");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 10>(Opcode)) /* Rt */), &m_CpuInfo));
    // FIXME: not_implemented: "operand [SP";
    // FIXME: not_implemented: "operand #<imm>]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDR<c> <Rt>, [SP{,#<disp>}] - ['could_jmp'] - ['1', '0', '0', '1', '1', 'Rt#3', 'imm#8']
bool ArmArchitecture::Instruction_LDR_T2_0000f800_00009800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDR<c> <Rt>, [SP{,#<disp>}]");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Ldr);
    rInsn.SetMnemonic("ldr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 10>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_Reg_Sp, &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) << 2 | 0)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADR<c> <Rd>, <label> - ['could_jmp'] - ['1', '0', '1', '0', '0', 'Rd#3', 'imm#8']
bool ArmArchitecture::Instruction_ADR_T1_0000f800_0000a000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADR<c> <Rd>, <label>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Adr);
    rInsn.SetMnemonic("adr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 10>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo) + (ExtractBits<0, 7>(Opcode)) /* imm */);
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADD<c> <Rd>, SP, #<imm> - ['could_jmp'] - ['1', '0', '1', '0', '1', 'Rd#3', 'imm#8']
bool ArmArchitecture::Instruction_ADD_T1_0000f800_0000a800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADD<c> <Rd>, SP, #<imm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Add);
    rInsn.SetMnemonic("add");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 10>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Sp, &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADD<c> SP, SP, #<imm> - ['could_jmp'] - ['1', '0', '1', '1', '0', '0', '0', '0', '0', 'imm#7']
bool ArmArchitecture::Instruction_ADD_T2_0000ff80_0000b000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADD<c> SP, SP, #<imm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Add);
    rInsn.SetMnemonic("add");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Sp, &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Sp, &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 6>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SUB<c> SP, SP, #<imm> - ['could_jmp'] - ['1', '0', '1', '1', '0', '0', '0', '0', '1', 'imm#7']
bool ArmArchitecture::Instruction_SUB_T1_0000ff80_0000b080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SUB<c> SP, SP, #<imm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Sub);
    rInsn.SetMnemonic("sub");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Sp, &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Sp, &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 6>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SXTH<c> <Rd>, <Rm> - ['could_jmp'] - ['1', '0', '1', '1', '0', '0', '1', '0', '0', '0', 'Rm#3', 'Rd#3']
bool ArmArchitecture::Instruction_SXTH_T1_0000ffc0_0000b200(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SXTH<c> <Rd>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Sxth);
    rInsn.SetMnemonic("sxth");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SXTB<c> <Rd>, <Rm> - ['could_jmp'] - ['1', '0', '1', '1', '0', '0', '1', '0', '0', '1', 'Rm#3', 'Rd#3']
bool ArmArchitecture::Instruction_SXTB_T1_0000ffc0_0000b240(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SXTB<c> <Rd>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Sxtb);
    rInsn.SetMnemonic("sxtb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UXTH<c> <Rd>, <Rm> - ['could_jmp'] - ['1', '0', '1', '1', '0', '0', '1', '0', '1', '0', 'Rm#3', 'Rd#3']
bool ArmArchitecture::Instruction_UXTH_T1_0000ffc0_0000b280(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UXTH<c> <Rd>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Uxth);
    rInsn.SetMnemonic("uxth");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UXTB<c> <Rd>, <Rm> - ['could_jmp'] - ['1', '0', '1', '1', '0', '0', '1', '0', '1', '1', 'Rm#3', 'Rd#3']
bool ArmArchitecture::Instruction_UXTB_T1_0000ffc0_0000b2c0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UXTB<c> <Rd>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Uxtb);
    rInsn.SetMnemonic("uxtb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// PUSH<c> <registers> - ['could_jmp'] - ['1', '0', '1', '1', '0', '1', '0', 'M#1', 'register_list#8']
bool ArmArchitecture::Instruction_PUSH_T1_0000fe00_0000b400(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("PUSH<c> <registers>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Push);
    rInsn.SetMnemonic("push");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeVecId(arm::RegisterList(8, (ExtractBits<0, 7>(Opcode)) /* register_list */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SETEND <endian_specifier> - [] - ['1', '0', '1', '1', '0', '1', '1', '0', '0', '1', '0', '(1)', 'E#1', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_SETEND_T1_0000fff7_0000b650(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SETEND <endian_specifier>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Setend);
    rInsn.SetMnemonic("setend");
    // FIXME: not_implemented: "operand <endian_specifier>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// REV<c> <Rd>, <Rm> - ['could_jmp'] - ['1', '0', '1', '1', '1', '0', '1', '0', '0', '0', 'Rm#3', 'Rd#3']
bool ArmArchitecture::Instruction_REV_T1_0000ffc0_0000ba00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("REV<c> <Rd>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Rev);
    rInsn.SetMnemonic("rev");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// REV16<c> <Rd>, <Rm> - ['could_jmp'] - ['1', '0', '1', '1', '1', '0', '1', '0', '0', '1', 'Rm#3', 'Rd#3']
bool ArmArchitecture::Instruction_REV16_T1_0000ffc0_0000ba40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("REV16<c> <Rd>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Rev16);
    rInsn.SetMnemonic("rev16");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// REVSH<c> <Rd>, <Rm> - ['could_jmp'] - ['1', '0', '1', '1', '1', '0', '1', '0', '1', '1', 'Rm#3', 'Rd#3']
bool ArmArchitecture::Instruction_REVSH_T1_0000ffc0_0000bac0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("REVSH<c> <Rd>, <Rm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Revsh);
    rInsn.SetMnemonic("revsh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<3, 5>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// POP<c> <registers> - ['could_ret'] - ['1', '0', '1', '1', '1', '1', '0', 'P#1', 'register_list#8']
bool ArmArchitecture::Instruction_POP_T1_0000fe00_0000bc00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("POP<c> <registers>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Pop);
    rInsn.SetMnemonic("pop");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeVecId(arm::RegisterList(8, (ExtractBits<0, 7>(Opcode)) /* register_list */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BKPT #<imm> - [] - ['1', '0', '1', '1', '1', '1', '1', '0', 'imm#8']
bool ArmArchitecture::Instruction_BKPT_T1_0000ff00_0000be00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BKPT #<imm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Bkpt);
    rInsn.SetMnemonic("bkpt");
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// NOP<c> - [] - ['1', '0', '1', '1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0']
bool ArmArchitecture::Instruction_NOP_T1_0000ffff_0000bf00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("NOP<c>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Nop);
    rInsn.SetMnemonic("nop");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// YIELD<c> - [] - ['1', '0', '1', '1', '1', '1', '1', '1', '0', '0', '0', '1', '0', '0', '0', '0']
bool ArmArchitecture::Instruction_YIELD_T1_0000ffff_0000bf10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("YIELD<c>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Yield);
    rInsn.SetMnemonic("yield");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// WFE<c> - [] - ['1', '0', '1', '1', '1', '1', '1', '1', '0', '0', '1', '0', '0', '0', '0', '0']
bool ArmArchitecture::Instruction_WFE_T1_0000ffff_0000bf20(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("WFE<c>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Wfe);
    rInsn.SetMnemonic("wfe");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// WFI<c> - [] - ['1', '0', '1', '1', '1', '1', '1', '1', '0', '0', '1', '1', '0', '0', '0', '0']
bool ArmArchitecture::Instruction_WFI_T1_0000ffff_0000bf30(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("WFI<c>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Wfi);
    rInsn.SetMnemonic("wfi");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SEV<c> - [] - ['1', '0', '1', '1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '0', '0', '0']
bool ArmArchitecture::Instruction_SEV_T1_0000ffff_0000bf40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SEV<c>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Sev);
    rInsn.SetMnemonic("sev");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// IT{x{y{z}}} <firstcond> - [] - ['1', '0', '1', '1', '1', '1', '1', '1', 'firstcond#4', 'mask#4']
bool ArmArchitecture::Instruction_IT_T1_0000ff00_0000bf00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("IT{x{y{z}}} <firstcond>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_It);
    rInsn.SetMnemonic("it");
    // FIXME: not_implemented: "it-suffix";
    // FIXME: not_implemented: "operand <firstcond>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CB{N}Z <Rn>, <label> - ['cond', 'jmp'] - ['1', '0', '1', '1', 'op#1', '0', 'imm#1', '1', 'imm#5', 'Rn#3']
bool ArmArchitecture::Instruction_CB_T1_0000f500_0000b100(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CB{N}Z <Rn>, <label>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Cb);
    rInsn.SubType() |= Instruction::JumpType;
    rInsn.SetMnemonic("cb");
    if ((ExtractBit<11>(Opcode)) /* op */)
    {
      rInsn.AddMnemonicSuffix("nz");
      rInsn.SetTestedFlags(arm::ConditionFromName("ne"));
    }

    else
    {
      rInsn.AddMnemonicSuffix("z");
      rInsn.SetTestedFlags(arm::ConditionFromName("eq"));
    }

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 2>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo) + (ExtractBits<3, 7>(Opcode) | ExtractBit<9>(Opcode) << 5) /* imm */);
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STM<c> <Rn>!,<registers> - [] - ['1', '1', '0', '0', '0', 'Rn#3', 'register_list#8']
bool ArmArchitecture::Instruction_STM_T1_0000f800_0000c000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STM<c> <Rn>!,<registers>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Stm);
    rInsn.SetMnemonic("stm");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddAttribute(ARM_Attribute_WriteBack);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 10>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeVecId(arm::RegisterList(8, (ExtractBits<0, 7>(Opcode)) /* register_list */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDM<c> <Rn>, <registers> - ['could_jmp'] - ['1', '1', '0', '0', '1', 'Rn#3', 'register_list#8']
bool ArmArchitecture::Instruction_LDM_T1_0000f800_0000c800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDM<c> <Rn>, <registers>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Ldm);
    rInsn.SetMnemonic("ldm");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 10>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeVecId(arm::RegisterList(8, (ExtractBits<0, 7>(Opcode)) /* register_list */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SVC<c> #<imm> - ['syscall'] - ['1', '1', '0', '1', '1', '1', '1', '1', 'imm#8']
bool ArmArchitecture::Instruction_SVC_T1_0000ff00_0000df00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SVC<c> #<imm>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_Svc);
    rInsn.SetMnemonic("svc");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// B<c> <thumb_branch_label> - ['jmp'] - ['1', '1', '0', '1', 'cond#4', 'imm#8']
bool ArmArchitecture::Instruction_B_T1_0000f000_0000d000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("B<c> <thumb_branch_label>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_B);
    rInsn.SubType() |= Instruction::JumpType;
    rInsn.SetMnemonic("b");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo) + (ExtractBits<0, 7>(Opcode)) << 1 | 0);
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// B<c> <thumb_branch_label> - ['jmp'] - ['1', '1', '1', '0', '0', 'imm#11']
bool ArmArchitecture::Instruction_B_T2_0000f800_0000e000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("B<c> <thumb_branch_label>");
    rInsn.Size() = 2;
    rInsn.SetOpcode(ARM_Opcode_B);
    rInsn.SubType() |= Instruction::JumpType;
    rInsn.SetMnemonic("b");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo) + (ExtractBits<0, 10>(Opcode)) << 1 | 0);
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STREX<c> <Rd>, <Rt>, [<Rn>{, #<disp>}] - [] - ['1', '1', '1', '0', '1', '0', '0', '0', '0', '1', '0', '0', 'Rn#4', 'Rt#4', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_STREX_T1_fff00000_e8400000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STREX<c> <Rd>, <Rt>, [<Rn>{, #<disp>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strex);
    rInsn.SetMnemonic("strex");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDREX<c> <Rt>, [<Rn>{, #<disp>}] - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '0', '0', '0', '1', '0', '1', 'Rn#4', 'Rt#4', '(1)', '(1)', '(1)', '(1)', 'imm#8']
bool ArmArchitecture::Instruction_LDREX_T1_fff00f00_e8500f00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDREX<c> <Rt>, [<Rn>{, #<disp>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrex);
    rInsn.SetMnemonic("ldrex");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// PUSH<c>.W <registers> - [] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '0', '1', '0', '1', '1', '0', '1', '(0)', 'M#1', '(0)', 'register_list#13']
bool ArmArchitecture::Instruction_PUSH_T2_ffffa000_e8ad0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("PUSH<c>.W <registers>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Push);
    rInsn.SetMnemonic("push");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeVecId(arm::RegisterList(13, (ExtractBits<0, 12>(Opcode)) /* register_list */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// POP<c>.W <registers> - ['could_ret'] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '0', '1', '1', '1', '1', '0', '1', 'P#1', 'M#1', '(0)', 'register_list#13']
bool ArmArchitecture::Instruction_POP_T2_ffff2000_e8bd0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("POP<c>.W <registers>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Pop);
    rInsn.SetMnemonic("pop");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeVecId(arm::RegisterList(13, (ExtractBits<0, 12>(Opcode)) /* register_list */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STM<c>.W <Rn>{!}, <registers> - [] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '0', 'W#1', '0', 'Rn#4', '(0)', 'M#1', '(0)', 'register_list#13']
bool ArmArchitecture::Instruction_STM_T2_ffd0a000_e8800000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STM<c>.W <Rn>{!}, <registers>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Stm);
    rInsn.SetMnemonic("stm");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeVecId(arm::RegisterList(13, (ExtractBits<0, 12>(Opcode)) /* register_list */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDM<c>.W <Rn>{!}, <registers> - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '0', 'W#1', '1', 'Rn#4', 'P#1', 'M#1', '(0)', 'register_list#13']
bool ArmArchitecture::Instruction_LDM_T2_ffd02000_e8900000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDM<c>.W <Rn>{!}, <registers>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldm);
    rInsn.SetMnemonic("ldm");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeVecId(arm::RegisterList(13, (ExtractBits<0, 12>(Opcode)) /* register_list */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STREXB<c> <Rd>, <Rt>, [<Rn>] - [] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '1', '0', '0', 'Rn#4', 'Rt#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '0', 'Rd#4']
bool ArmArchitecture::Instruction_STREXB_T1_fff00ff0_e8c00f40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STREXB<c> <Rd>, <Rt>, [<Rn>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strexb);
    rInsn.SetMnemonic("strexb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STREXH<c> <Rd>, <Rt>, [<Rn>] - [] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '1', '0', '0', 'Rn#4', 'Rt#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '1', 'Rd#4']
bool ArmArchitecture::Instruction_STREXH_T1_fff00ff0_e8c00f50(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STREXH<c> <Rd>, <Rt>, [<Rn>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strexh);
    rInsn.SetMnemonic("strexh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STREXD<c> <Rd>, <Rt>, <Rt2>, [<Rn>] - [] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '1', '0', '0', 'Rn#4', 'Rt#4', 'Rt2#4', '0', '1', '1', '1', 'Rd#4']
bool ArmArchitecture::Instruction_STREXD_T1_fff000f0_e8c00070(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STREXD<c> <Rd>, <Rt>, <Rt2>, [<Rn>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strexd);
    rInsn.SetMnemonic("strexd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rt2 */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(64, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// TBH<c> [<Rn>, <Rm>,LSL #1] - ['jmp'] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '1', '0', '1', 'Rn#4', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '0', '0', '0', 'H#1', 'Rm#4']
bool ArmArchitecture::Instruction_TBH_T1_fff0ffe0_e8d0f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("TBH<c> [<Rn>, <Rm>,LSL #1]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Tbh);
    rInsn.SubType() |= Instruction::JumpType;
    rInsn.SetMnemonic("tbh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "[<Rn>";
    // FIXME: not_implemented: "operand <Rm>,LSL";
    // FIXME: not_implemented: "operand #1]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDREXB<c> <Rt>, [<Rn>] - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '1', '0', '1', 'Rn#4', 'Rt#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '0', '(1)', '(1)', '(1)', '(1)']
bool ArmArchitecture::Instruction_LDREXB_T1_fff00fff_e8d00f4f(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDREXB<c> <Rt>, [<Rn>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrexb);
    rInsn.SetMnemonic("ldrexb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDREXH<c> <Rt>, [<Rn>] - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '1', '0', '1', 'Rn#4', 'Rt#4', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '1', '(1)', '(1)', '(1)', '(1)']
bool ArmArchitecture::Instruction_LDREXH_T1_fff00fff_e8d00f5f(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDREXH<c> <Rt>, [<Rn>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrexh);
    rInsn.SetMnemonic("ldrexh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDREXD<c> <Rt>, <Rt2>, [<Rn>] - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '0', '0', '1', '1', '0', '1', 'Rn#4', 'Rt#4', 'Rt2#4', '0', '1', '1', '1', '(1)', '(1)', '(1)', '(1)']
bool ArmArchitecture::Instruction_LDREXD_T1_fff000ff_e8d0007f(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDREXD<c> <Rt>, <Rt2>, [<Rn>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrexd);
    rInsn.SetMnemonic("ldrexd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rt2 */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(64, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STMDB<c> <Rn>{!}, <registers> - [] - ['1', '1', '1', '0', '1', '0', '0', '1', '0', '0', 'W#1', '0', 'Rn#4', '(0)', 'M#1', '(0)', 'register_list#13']
bool ArmArchitecture::Instruction_STMDB_T1_ffd0a000_e9000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STMDB<c> <Rn>{!}, <registers>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Stmdb);
    rInsn.SetMnemonic("stmdb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeVecId(arm::RegisterList(13, (ExtractBits<0, 12>(Opcode)) /* register_list */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDMDB<c> <Rn>{!}, <registers> - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '0', '1', '0', '0', 'W#1', '1', 'Rn#4', 'P#1', 'M#1', '(0)', 'register_list#13']
bool ArmArchitecture::Instruction_LDMDB_T1_ffd02000_e9100000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDMDB<c> <Rn>{!}, <registers>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldmdb);
    rInsn.SetMnemonic("ldmdb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeVecId(arm::RegisterList(13, (ExtractBits<0, 12>(Opcode)) /* register_list */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRD<c> <Rt>, <Rt2>, [PC,#-0] - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '0', 'P#1', 'U#1', '1', '(0)', '1', '1', '1', '1', '1', 'Rt#4', 'Rt2#4', 'imm#8']
bool ArmArchitecture::Instruction_LDRD_T1_fe7f0000_e85f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRD<c> <Rt>, <Rt2>, [PC,#-0]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrd);
    rInsn.SetMnemonic("ldrd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rt2 */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(64, nullptr, Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRD<c> <Rt>, <Rt2>, [<Rn>, #+/-<imm>]! - [] - ['1', '1', '1', '0', '1', '0', '0', 'P#1', 'U#1', '1', 'W#1', '0', 'Rn#4', 'Rt#4', 'Rt2#4', 'imm#8']
bool ArmArchitecture::Instruction_STRD_T1_fe500000_e8400000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRD<c> <Rt>, <Rt2>, [<Rn>, #+/-<imm>]!");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strd);
    rInsn.SetMnemonic("strd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddAttribute(ARM_Attribute_WriteBack);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rt2 */), &m_CpuInfo));
    if ((ExtractBit<23>(Opcode)) /* U */)
      rInsn.AddOperand(Expr::MakeMem(64, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) << 2 | 0)));

    else
      rInsn.AddOperand(Expr::MakeMem(64, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) - Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) << 2 | 0)));

  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRD<c> <Rt>, <Rt2>, [<Rn>, #+/-<imm>]! - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '0', 'P#1', 'U#1', '1', 'W#1', '1', 'Rn#4', 'Rt#4', 'Rt2#4', 'imm#8']
bool ArmArchitecture::Instruction_LDRD_T1_fe500000_e8500000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRD<c> <Rt>, <Rt2>, [<Rn>, #+/-<imm>]!");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrd);
    rInsn.SetMnemonic("ldrd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddAttribute(ARM_Attribute_WriteBack);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rt2 */), &m_CpuInfo));
    if ((ExtractBit<23>(Opcode)) /* U */)
      rInsn.AddOperand(Expr::MakeMem(64, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) << 2 | 0)));

    else
      rInsn.AddOperand(Expr::MakeMem(64, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) - Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) << 2 | 0)));

  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// TST<c>.W <Rn>, <Rm>{,<shift>} - [] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '0', '0', '1', 'Rn#4', '(0)', 'imm#3', '1', '1', '1', '1', 'imm#2', 'type#2', 'Rm#4']
bool ArmArchitecture::Instruction_TST_T2_fff08f00_ea100f00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("TST<c>.W <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Tst);
    rInsn.SetMnemonic("tst");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<4, 5>(Opcode)) /* type */, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// AND{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '0', '0', 'S#1', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
bool ArmArchitecture::Instruction_AND_T2_ffe08000_ea000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("AND{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_And);
    rInsn.SetMnemonic("and");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<4, 5>(Opcode)) /* type */, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BIC{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '0', '1', 'S#1', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
bool ArmArchitecture::Instruction_BIC_T2_ffe08000_ea200000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BIC{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Bic);
    rInsn.SetMnemonic("bic");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<4, 5>(Opcode)) /* type */, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MOV{S}<c>.W <Rd>, <Rm> - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '1', '0', 'S#1', '1', '1', '1', '1', '(0)', '0', '0', '0', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_MOV_T3_ffeff0f0_ea4f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MOV{S}<c>.W <Rd>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mov);
    rInsn.SetMnemonic("mov");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// RRX{S}<c> <Rd>, <Rm> - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '1', '0', 'S#1', '1', '1', '1', '1', '(0)', '0', '0', '0', 'Rd#4', '0', '0', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_RRX_T1_ffeff0f0_ea4f0030(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("RRX{S}<c> <Rd>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Rrx);
    rInsn.SetMnemonic("rrx");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LSL{S}<c>.W <Rd>, <Rm>, #<imm5> - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '1', '0', 'S#1', '1', '1', '1', '1', '(0)', 'imm#3', 'Rd#4', 'imm#2', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_LSL_T2_ffef8030_ea4f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LSL{S}<c>.W <Rd>, <Rm>, #<imm5>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Lsl);
    rInsn.SetMnemonic("lsl");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LSR{S}<c>.W <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '1', '0', 'S#1', '1', '1', '1', '1', '(0)', 'imm#3', 'Rd#4', 'imm#2', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_LSR_T2_ffef8030_ea4f0010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LSR{S}<c>.W <Rd>, <Rm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Lsr);
    rInsn.SetMnemonic("lsr");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ASR{S}<c>.W <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '1', '0', 'S#1', '1', '1', '1', '1', '(0)', 'imm#3', 'Rd#4', 'imm#2', '1', '0', 'Rm#4']
bool ArmArchitecture::Instruction_ASR_T2_ffef8030_ea4f0020(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ASR{S}<c>.W <Rd>, <Rm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Asr);
    rInsn.SetMnemonic("asr");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ROR{S}<c> <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '1', '0', 'S#1', '1', '1', '1', '1', '(0)', 'imm#3', 'Rd#4', 'imm#2', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_ROR_T1_ffef8030_ea4f0030(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ROR{S}<c> <Rd>, <Rm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ror);
    rInsn.SetMnemonic("ror");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ORR{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '1', '0', 'S#1', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
bool ArmArchitecture::Instruction_ORR_T2_ffe08000_ea400000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ORR{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Orr);
    rInsn.SetMnemonic("orr");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<4, 5>(Opcode)) /* type */, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MVN{S}<c>.W <Rd>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '1', '1', 'S#1', '1', '1', '1', '1', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
bool ArmArchitecture::Instruction_MVN_T2_ffef8000_ea6f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MVN{S}<c>.W <Rd>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mvn);
    rInsn.SetMnemonic("mvn");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<4, 5>(Opcode)) /* type */, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ORN{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '0', '1', '1', 'S#1', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
bool ArmArchitecture::Instruction_ORN_T1_ffe08000_ea600000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ORN{S}<c> <Rd>, <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Orn);
    rInsn.SetMnemonic("orn");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<4, 5>(Opcode)) /* type */, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// TEQ<c> <Rn>, <Rm>{,<shift>} - [] - ['1', '1', '1', '0', '1', '0', '1', '0', '1', '0', '0', '1', 'Rn#4', '(0)', 'imm#3', '1', '1', '1', '1', 'imm#2', 'type#2', 'Rm#4']
bool ArmArchitecture::Instruction_TEQ_T1_fff08f00_ea900f00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("TEQ<c> <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Teq);
    rInsn.SetMnemonic("teq");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<4, 5>(Opcode)) /* type */, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// EOR{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '1', '0', '0', 'S#1', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
bool ArmArchitecture::Instruction_EOR_T2_ffe08000_ea800000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("EOR{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Eor);
    rInsn.SetMnemonic("eor");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<4, 5>(Opcode)) /* type */, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// PKHTB<c> <Rd>, <Rn>, <Rm>{,ASR #<imm>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '0', '1', '1', '0', '0', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'tb#1', '0', 'Rm#4']
bool ArmArchitecture::Instruction_PKHTB_T1_fff08010_eac00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("PKHTB<c> <Rd>, <Rn>, <Rm>{,ASR #<imm>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Pkhtb);
    rInsn.SetMnemonic("pkhtb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,ASR";
    // FIXME: not_implemented: "operand #<imm>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CMN<c>.W <Rn>, <Rm>{,<shift>} - ['cond'] - ['1', '1', '1', '0', '1', '0', '1', '1', '0', '0', '0', '1', 'Rn#4', '(0)', 'imm#3', '1', '1', '1', '1', 'imm#2', 'type#2', 'Rm#4']
bool ArmArchitecture::Instruction_CMN_T2_fff08f00_eb100f00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CMN<c>.W <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Cmn);
    rInsn.SetMnemonic("cmn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<4, 5>(Opcode)) /* type */, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADD{S}<c>.W <Rd>, SP, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '1', '0', '0', '0', 'S#1', '1', '1', '0', '1', '0', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
bool ArmArchitecture::Instruction_ADD_T3_ffef8000_eb0d0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADD{S}<c>.W <Rd>, SP, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Add);
    rInsn.SetMnemonic("add");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Sp, &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<4, 5>(Opcode)) /* type */, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADD{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '1', '0', '0', '0', 'S#1', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
bool ArmArchitecture::Instruction_ADD_T3_ffe08000_eb000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADD{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Add);
    rInsn.SetMnemonic("add");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<4, 5>(Opcode)) /* type */, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADC{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '1', '0', '1', '0', 'S#1', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
bool ArmArchitecture::Instruction_ADC_T2_ffe08000_eb400000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADC{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Adc);
    rInsn.SetMnemonic("adc");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<4, 5>(Opcode)) /* type */, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SBC{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '1', '0', '1', '1', 'S#1', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
bool ArmArchitecture::Instruction_SBC_T2_ffe08000_eb600000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SBC{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sbc);
    rInsn.SetMnemonic("sbc");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<4, 5>(Opcode)) /* type */, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CMP<c>.W <Rn>, <Rm> {,<shift>} - ['cond'] - ['1', '1', '1', '0', '1', '0', '1', '1', '1', '0', '1', '1', 'Rn#4', '(0)', 'imm#3', '1', '1', '1', '1', 'imm#2', 'type#2', 'Rm#4']
bool ArmArchitecture::Instruction_CMP_T3_fff08f00_ebb00f00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CMP<c>.W <Rn>, <Rm> {,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Cmp);
    rInsn.SetMnemonic("cmp");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    // FIXME: not_implemented: "operand {,<shift>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SUB{S}<c> <Rd>, SP, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '1', '1', '0', '1', 'S#1', '1', '1', '0', '1', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
bool ArmArchitecture::Instruction_SUB_T1_ffef8000_ebad0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SUB{S}<c> <Rd>, SP, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sub);
    rInsn.SetMnemonic("sub");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Sp, &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<4, 5>(Opcode)) /* type */, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SUB{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '1', '1', '0', '1', 'S#1', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
bool ArmArchitecture::Instruction_SUB_T2_ffe08000_eba00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SUB{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sub);
    rInsn.SetMnemonic("sub");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<4, 5>(Opcode)) /* type */, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// RSB{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '0', '1', '0', '1', '1', '1', '1', '0', 'S#1', 'Rn#4', '(0)', 'imm#3', 'Rd#4', 'imm#2', 'type#2', 'Rm#4']
bool ArmArchitecture::Instruction_RSB_T1_ffe08000_ebc00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("RSB{S}<c> <Rd>, <Rn>, <Rm>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Rsb);
    rInsn.SetMnemonic("rsb");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(arm::DecodeImmShiftWithSource(&m_CpuInfo, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo), (ExtractBits<4, 5>(Opcode)) /* type */, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MCRR<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm> - ['support it block', 'could_jmp'] - ['1', '1', '1', '0', '1', '1', '0', '0', '0', '1', '0', '0', 'Rt2#4', 'Rt#4', 'coproc#4', 'opc1#4', 'CRm#4']
bool ArmArchitecture::Instruction_MCRR_T1_fff00000_ec400000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MCRR<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mcrr);
    rInsn.SetMnemonic("mcrr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <opc1>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rt2 */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <CRm>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MRRC<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm> - ['support it block', 'could_jmp'] - ['1', '1', '1', '0', '1', '1', '0', '0', '0', '1', '0', '1', 'Rt2#4', 'Rt#4', 'coproc#4', 'opc1#4', 'CRm#4']
bool ArmArchitecture::Instruction_MRRC_T1_fff00000_ec500000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MRRC<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mrrc);
    rInsn.SetMnemonic("mrrc");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <opc>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rt2 */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <CRm>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMOV<c> <Sm>, <Sm1>, <Rt>, <Rt2> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', '0', '0', '1', '0', 'op#1', 'Rt2#4', 'Rt#4', '1', '0', '1', '0', '0', '0', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VMOV_T1_ffe00fd0_ec400a10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMOV<c> <Sm>, <Sm1>, <Rt>, <Rt2>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmov);
    rInsn.SetMnemonic("vmov");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Sm1>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rt2 */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMOV<c> <Dm>, <Rt>, <Rt2> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', '0', '0', '1', '0', 'op#1', 'Rt2#4', 'Rt#4', '1', '0', '1', '1', '0', '0', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VMOV_T1_ffe00fd0_ec400b10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMOV<c> <Dm>, <Rt>, <Rt2>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmov);
    rInsn.SetMnemonic("vmov");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rt2 */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VPOP <list> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', '0', '1', 'D#1', '1', '1', '1', '1', '0', '1', 'Vd#4', '1', '0', '1', '0', 'imm#8']
bool ArmArchitecture::Instruction_VPOP_T2_ffbf0f00_ecbd0a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VPOP <list>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vpop);
    rInsn.SetMnemonic("vpop");
    // FIXME: not_implemented: "operand <list>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VPOP <list> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', '0', '1', 'D#1', '1', '1', '1', '1', '0', '1', 'Vd#4', '1', '0', '1', '1', 'imm#8']
bool ArmArchitecture::Instruction_VPOP_T1_ffbf0f00_ecbd0b00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VPOP <list>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vpop);
    rInsn.SetMnemonic("vpop");
    // FIXME: not_implemented: "operand <list>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VPUSH<c> <list> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', '1', '0', 'D#1', '1', '0', '1', '1', '0', '1', 'Vd#4', '1', '0', '1', '0', 'imm#8']
bool ArmArchitecture::Instruction_VPUSH_T2_ffbf0f00_ed2d0a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VPUSH<c> <list>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vpush);
    rInsn.SetMnemonic("vpush");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <list>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VPUSH<c> <list> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', '1', '0', 'D#1', '1', '0', '1', '1', '0', '1', 'Vd#4', '1', '0', '1', '1', 'imm#8']
bool ArmArchitecture::Instruction_VPUSH_T1_ffbf0f00_ed2d0b00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VPUSH<c> <list>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vpush);
    rInsn.SetMnemonic("vpush");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <list>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSTR<c> <Sd>, [<Rn>{,#+/-<imm>}] - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', '1', 'U#1', 'D#1', '0', '0', 'Rn#4', 'Vd#4', '1', '0', '1', '0', 'imm#8']
bool ArmArchitecture::Instruction_VSTR_T2_ff300f00_ed000a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSTR<c> <Sd>, [<Rn>{,#+/-<imm>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vstr);
    rInsn.SetMnemonic("vstr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand [<Rn>{,#+/-<imm>}]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSTR<c> <Dd>, [<Rn>{,#+/-<imm>}] - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', '1', 'U#1', 'D#1', '0', '0', 'Rn#4', 'Vd#4', '1', '0', '1', '1', 'imm#8']
bool ArmArchitecture::Instruction_VSTR_T1_ff300f00_ed000b00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSTR<c> <Dd>, [<Rn>{,#+/-<imm>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vstr);
    rInsn.SetMnemonic("vstr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand [<Rn>{,#+/-<imm>}]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VLDR<c> <Sd>, [<Rn>{,#+/-<imm>}] - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', '1', 'U#1', 'D#1', '0', '1', 'Rn#4', 'Vd#4', '1', '0', '1', '0', 'imm#8']
bool ArmArchitecture::Instruction_VLDR_T2_ff300f00_ed100a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VLDR<c> <Sd>, [<Rn>{,#+/-<imm>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vldr);
    rInsn.SetMnemonic("vldr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand [<Rn>{,#+/-<imm>}]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VLDR<c> <Dd>, [<Rn>{,#+/-<imm>}] - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', '1', 'U#1', 'D#1', '0', '1', 'Rn#4', 'Vd#4', '1', '0', '1', '1', 'imm#8']
bool ArmArchitecture::Instruction_VLDR_T1_ff300f00_ed100b00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VLDR<c> <Dd>, [<Rn>{,#+/-<imm>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vldr);
    rInsn.SetMnemonic("vldr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand [<Rn>{,#+/-<imm>}]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STC{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!} - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '0', 'Rn#4', 'CRd#4', 'coproc#4', 'imm#8']
bool ArmArchitecture::Instruction_STC_T1_fe100000_ec000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STC{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Stc);
    rInsn.SetMnemonic("stc");
    if ((ExtractBit<22>(Opcode)) /* D */)
        rInsn.AddMnemonicSuffix("L");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <CRd>";
    if ((ExtractBit<23>(Opcode)) /* U */)
      rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + (ExtractBits<0, 7>(Opcode)) << 2 | 0));

    else
      rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) - (ExtractBits<0, 7>(Opcode)) << 2 | 0));

  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSTM{mode}<c> <Rn>{!},  <list> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '0', 'Rn#4', 'Vd#4', '1', '0', '1', '0', 'imm#8']
bool ArmArchitecture::Instruction_VSTM_T2_fe100f00_ec000a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSTM{mode}<c> <Rn>{!},  <list>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vstm);
    rInsn.SetMnemonic("vstm");
    // FIXME: not_implemented: "field {mode}";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand ";
    // FIXME: not_implemented: "operand <list>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSTM{mode}<c> <Rn>{!},  <list> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '0', 'Rn#4', 'Vd#4', '1', '0', '1', '1', 'imm#8']
bool ArmArchitecture::Instruction_VSTM_T1_fe100f00_ec000b00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSTM{mode}<c> <Rn>{!},  <list>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vstm);
    rInsn.SetMnemonic("vstm");
    // FIXME: not_implemented: "field {mode}";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand ";
    // FIXME: not_implemented: "operand <list>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDC{L}<c> <coproc>, <CRd>, <label> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', '1', '1', '1', '1', 'CRd#4', 'coproc#4', 'imm#8']
bool ArmArchitecture::Instruction_LDC_T1_fe1f0000_ec1f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDC{L}<c> <coproc>, <CRd>, <label>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldc);
    rInsn.SetMnemonic("ldc");
    if ((ExtractBit<22>(Opcode)) /* D */)
        rInsn.AddMnemonicSuffix("L");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <CRd>";
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo) + (ExtractBits<0, 7>(Opcode)) /* imm */);
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDC{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!} - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', 'Rn#4', 'CRd#4', 'coproc#4', 'imm#8']
bool ArmArchitecture::Instruction_LDC_T1_fe100000_ec100000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDC{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldc);
    rInsn.SetMnemonic("ldc");
    if ((ExtractBit<22>(Opcode)) /* D */)
        rInsn.AddMnemonicSuffix("L");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <CRd>";
    if ((ExtractBit<23>(Opcode)) /* U */)
      rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + (ExtractBits<0, 7>(Opcode)) << 2 | 0));

    else
      rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) - (ExtractBits<0, 7>(Opcode)) << 2 | 0));

  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VLDM{mode}<c> <Rn>{!},  <list> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', 'Rn#4', 'Vd#4', '1', '0', '1', '0', 'imm#8']
bool ArmArchitecture::Instruction_VLDM_T2_fe100f00_ec100a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VLDM{mode}<c> <Rn>{!},  <list>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vldm);
    rInsn.SetMnemonic("vldm");
    // FIXME: not_implemented: "field {mode}";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand ";
    // FIXME: not_implemented: "operand <list>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VLDM{mode}<c> <Rn>{!},  <list> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', 'Rn#4', 'Vd#4', '1', '0', '1', '1', 'imm#8']
bool ArmArchitecture::Instruction_VLDM_T1_fe100f00_ec100b00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VLDM{mode}<c> <Rn>{!},  <list>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vldm);
    rInsn.SetMnemonic("vldm");
    // FIXME: not_implemented: "field {mode}";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand ";
    // FIXME: not_implemented: "operand <list>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMOV<c> <Sn>, <Rt> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '0', '0', '0', 'op#1', 'Vn#4', 'Rt#4', '1', '0', '1', '0', 'N#1', '(0)', '(0)', '1', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VMOV_T1_ffe00f7f_ee000a10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMOV<c> <Sn>, <Rt>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmov);
    rInsn.SetMnemonic("vmov");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op><c>.F64 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '0', 'D#1', '0', '0', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', 'op#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_V_T2_ffb00e10_ee000a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op><c>.F64 <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F64");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VNMLA<c>.F64 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '0', 'D#1', '0', '1', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', 'op#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VNMLA_T1_ffb00e10_ee100a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VNMLA<c>.F64 <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vnmla);
    rInsn.SetMnemonic("vnmla");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F64");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMUL<c>.F64 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '0', 'D#1', '1', '0', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VMUL_T2_ffb00e50_ee200a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMUL<c>.F64 <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmul);
    rInsn.SetMnemonic("vmul");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F64");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VNMUL<c>.F64 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '0', 'D#1', '1', '0', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VNMUL_T2_ffb00e50_ee200a40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VNMUL<c>.F64 <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vnmul);
    rInsn.SetMnemonic("vnmul");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F64");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VADD<c>.F64 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '0', 'D#1', '1', '1', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VADD_T2_ffb00e50_ee300a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VADD<c>.F64 <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vadd);
    rInsn.SetMnemonic("vadd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F64");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSUB<c>.F64 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '0', 'D#1', '1', '1', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VSUB_T2_ffb00e50_ee300a40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSUB<c>.F64 <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vsub);
    rInsn.SetMnemonic("vsub");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F64");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMOV<c>.<size> <Dd[x]>, <Rt> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '0', 'opc1#2', '0', 'Vd#4', 'Rt#4', '1', '0', '1', '1', 'D#1', 'opc2#2', '1', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VMOV_T1_ff900f1f_ee000b10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMOV<c>.<size> <Dd[x]>, <Rt>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmov);
    rInsn.SetMnemonic("vmov");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    // FIXME: not_implemented: "operand <Dd[x]>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMSR<c> FPSCR, <Rt> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '0', '0', '0', '0', '1', 'Rt#4', '1', '0', '1', '0', '0', '(0)', '(0)', '1', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VMSR_T1_ffff0fff_eee10a10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMSR<c> FPSCR, <Rt>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmsr);
    rInsn.SetMnemonic("vmsr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand FPSCR";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMRS<c> <Rt>, FPSCR - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', '1', '1', '1', '0', '0', '0', '1', 'Rt#4', '1', '0', '1', '0', '0', '(0)', '(0)', '1', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VMRS_T1_ffff0fff_eef10a10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMRS<c> <Rt>, FPSCR");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmrs);
    rInsn.SetMnemonic("vmr");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    // FIXME: not_implemented: "operand FPSCR";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VDIV<c>.F64 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '0', '0', 'Vn#4', 'Vd#4', '1', '0', '1', 'sz#1', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VDIV_T1_ffb00e50_ee800a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VDIV<c>.F64 <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vdiv);
    rInsn.SetMnemonic("vdiv");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F64");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMOV<c>.F64 <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '0', '0', '0', 'Vd#4', '1', '0', '1', 'sz#1', '0', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VMOV_T2_ffbf0ed0_eeb00a40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMOV<c>.F64 <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmov);
    rInsn.SetMnemonic("vmov");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F64");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VABS<c>.F64 <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '0', '0', '0', 'Vd#4', '1', '0', '1', 'sz#1', '1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VABS_T2_ffbf0ed0_eeb00ac0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VABS<c>.F64 <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vabs);
    rInsn.SetMnemonic("vab");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F64");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VNEG<c>.F64 <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '0', '0', '1', 'Vd#4', '1', '0', '1', 'sz#1', '0', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VNEG_T2_ffbf0ed0_eeb10a40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VNEG<c>.F64 <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vneg);
    rInsn.SetMnemonic("vneg");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F64");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSQRT<c>.F64 <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '0', '0', '1', 'Vd#4', '1', '0', '1', 'sz#1', '1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VSQRT_T1_ffbf0ed0_eeb10ac0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSQRT<c>.F64 <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vsqrt);
    rInsn.SetMnemonic("vsqrt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F64");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCVT<y><c>.F32.F16 <Sd>, <Sm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '0', '1', 'op#1', 'Vd#4', '1', '0', '1', '0', 'T#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCVT_T1_ffbe0f50_eeb20a40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCVT<y><c>.F32.F16 <Sd>, <Sm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcvt);
    rInsn.SetMnemonic("vcvt");
    if ((ExtractBit<5>(Opcode)) /* M */)
      rInsn.AddMnemonicSuffix("t");

    else
      rInsn.AddMnemonicSuffix("b");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddMnemonicSuffix(".F16");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCMP{E}<c>.F64 <Dd>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '1', '0', '0', 'Vd#4', '1', '0', '1', 'sz#1', 'E#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCMP_T1_ffbf0e50_eeb40a40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCMP{E}<c>.F64 <Dd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcmp);
    rInsn.SetMnemonic("vcmp");
    if ((ExtractBit<7>(Opcode)) /* E */)
        rInsn.AddMnemonicSuffix("E");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F64");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCMP{E}<c>.F64 <Dd>, #0.0 - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '1', '0', '1', 'Vd#4', '1', '0', '1', 'sz#1', 'E#1', '1', '(0)', '0', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VCMP_T2_ffbf0e7f_eeb50a40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCMP{E}<c>.F64 <Dd>, #0.0");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcmp);
    rInsn.SetMnemonic("vcmp");
    if ((ExtractBit<7>(Opcode)) /* E */)
        rInsn.AddMnemonicSuffix("E");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F64");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(BitVector(0.0f)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCVT<c>.F64.F32 <Dd>, <Sm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', '0', '1', '1', '1', 'Vd#4', '1', '0', '1', 'sz#1', '1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCVT_T1_ffbf0ed0_eeb70ac0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCVT<c>.F64.F32 <Dd>, <Sm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcvt);
    rInsn.SetMnemonic("vcvt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F64");
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCVT<c>.<Td>.F64 <Dd>, <Dd>, #<fbits> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', '1', 'op#1', '1', 'U#1', 'Vd#4', '1', '0', '1', 'sf#1', 'sx#1', '1', 'imm#1', '0', 'imm#4']
bool ArmArchitecture::Instruction_VCVT_T1_ffba0e50_eeba0a40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCVT<c>.<Td>.F64 <Dd>, <Dd>, #<fbits>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcvt);
    rInsn.SetMnemonic("vcvt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    if ((ExtractBit<7>(Opcode)) /* sx */)
      rInsn.AddMnemonicSuffix("32");

    else
      rInsn.AddMnemonicSuffix("16");

    rInsn.AddMnemonicSuffix(".F64");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand #<fbits>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCVT{R}<c>.S32.F64 <Sd>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', '1', 'opc2#3', 'Vd#4', '1', '0', '1', 'sz#1', 'op#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCVT_T1_ffb80e50_eeb80a40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCVT{R}<c>.S32.F64 <Sd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcvt);
    rInsn.SetMnemonic("vcvt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".S32.F64");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("FPR32", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMOV<c>.F64 <Dd>, #<imm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'D#1', '1', '1', 'imm_h#4', 'Vd#4', '1', '0', '1', 'sz#1', '(0)', '0', '(0)', '0', 'imm_l#4']
bool ArmArchitecture::Instruction_VMOV_T2_ffb00ef0_eeb00a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMOV<c>.F64 <Dd>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmov);
    rInsn.SetMnemonic("vmov");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F64");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 19>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VDUP<c>.<size> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', '1', 'b_size#1', 'Q#1', '0', 'Vd#4', 'Rt#4', '1', '0', '1', '1', 'D#1', '0', 'e_size#1', '1', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VDUP_T1_ff900f5f_ee800b10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VDUP<c>.<size>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vdup);
    rInsn.SetMnemonic("vdup");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMOV<c>.<dt> <Rt>, <Dn[x]> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', 'U#1', 'opc1#2', '1', 'Vn#4', 'Rt#4', '1', '0', '1', '1', 'N#1', 'opc2#2', '1', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VMOV_T1_ff100f1f_ee100b10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMOV<c>.<dt> <Rt>, <Dn[x]>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmov);
    rInsn.SetMnemonic("vmov");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Dn[x]>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MCR<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['support it block', 'could_jmp'] - ['1', '1', '1', '0', '1', '1', '1', '0', 'opc1#3', '0', 'CRn#4', 'Rt#4', 'coproc#4', 'opc2#3', '1', 'CRm#4']
bool ArmArchitecture::Instruction_MCR_T1_ff100010_ee000010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MCR<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mcr);
    rInsn.SetMnemonic("mcr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <opc1>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <CRn>";
    // FIXME: not_implemented: "operand <CRm>{,<opc2>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MRC<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['support it block', 'could_jmp'] - ['1', '1', '1', '0', '1', '1', '1', '0', 'opc1#3', '1', 'CRn#4', 'Rt#4', 'coproc#4', 'opc2#3', '1', 'CRm#4']
bool ArmArchitecture::Instruction_MRC_T1_ff100010_ee100010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MRC<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mrc);
    rInsn.SetMnemonic("mrc");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <opc1>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <CRn>";
    // FIXME: not_implemented: "operand <CRm>{,<opc2>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CDP<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '0', 'opc1#4', 'CRn#4', 'CRd#4', 'coproc#4', 'opc2#3', '0', 'CRm#4']
bool ArmArchitecture::Instruction_CDP_T1_ff000010_ee000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CDP<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Cdp);
    rInsn.SetMnemonic("cdp");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <opc1>";
    // FIXME: not_implemented: "operand <CRd>";
    // FIXME: not_implemented: "operand <CRn>";
    // FIXME: not_implemented: "operand <CRm>";
    // FIXME: not_implemented: "operand <opc2>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VAND<c> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', '0', '0', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VAND_T1_ffb00f10_ef000110(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VAND<c> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vand);
    rInsn.SetMnemonic("vand");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VBIC<c> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', '0', '1', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VBIC_T1_ffb00f10_ef100110(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VBIC<c> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vbic);
    rInsn.SetMnemonic("vbic");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VADD<c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VADD_T1_ffa00f10_ef000d00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VADD<c>.F32 <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vadd);
    rInsn.SetMnemonic("vadd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCEQ<c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCEQ_T2_ffa00f10_ef000e00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCEQ<c>.F32 <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vceq);
    rInsn.SetMnemonic("vceq");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRECPS<c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VRECPS_T1_ffa00f10_ef000f10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRECPS<c>.F32 <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrecps);
    rInsn.SetMnemonic("vrecp");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VORR<c> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', '1', '0', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VORR_T1_ffb00f10_ef200110(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VORR<c> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vorr);
    rInsn.SetMnemonic("vorr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VORN<c> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', '1', '1', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VORN_T1_ffb00f10_ef300110(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VORN<c> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vorn);
    rInsn.SetMnemonic("vorn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSUB<c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', '1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VSUB_T1_ffa00f10_ef200d00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSUB<c>.F32 <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vsub);
    rInsn.SetMnemonic("vsub");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRSQRTS<c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', '1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VRSQRTS_T1_ffa00f10_ef200f10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRSQRTS<c>.F32 <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrsqrts);
    rInsn.SetMnemonic("vrsqrt");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op><c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', 'op#1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_V_T1_ff800f10_ef000d10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op><c>.F32 <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op><c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', 'op#1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_V_T1_ff800f10_ef000f00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op><c>.F32 <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VADD<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VADD_T1_ff800f10_ef000800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VADD<c>.<dt> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vadd);
    rInsn.SetMnemonic("vadd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VTST<c>.<size> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VTST_T1_ff800f10_ef000810(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VTST<c>.<size> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vtst);
    rInsn.SetMnemonic("vtst");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQDMULH<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQDMULH_T1_ff800f10_ef000b00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQDMULH<c>.<dt> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqdmulh);
    rInsn.SetMnemonic("vqdmulh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VPADD<c>.<dt> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VPADD_T1_ff800f10_ef000b10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VPADD<c>.<dt>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vpadd);
    rInsn.SetMnemonic("vpadd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VEXT<c>.8 <Qd>, <Qn>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'Vn#4', 'Vd#4', 'imm#4', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VEXT_T1_ffb00010_efb00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VEXT<c>.8 <Qd>, <Qn>, <Qm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vext);
    rInsn.SetMnemonic("vext");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".8");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<8, 11>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSHL<c>.I<size> <Qd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '1', '0', '1', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VSHL_T1_ff800f10_ef800510(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSHL<c>.I<size> <Qd>, <Qm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vshl);
    rInsn.SetMnemonic("vshl");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".I");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSHRN<c>.I<size> <Dd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '1', '0', '0', '0', '0', '0', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VSHRN_T1_ff800fd0_ef800810(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSHRN<c>.I<size> <Dd>, <Qm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vshrn);
    rInsn.SetMnemonic("vshrn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".I");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRSHRN<c>.I<size> <Dd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '1', '0', '0', '0', '0', '1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VRSHRN_T1_ff800fd0_ef800850(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRSHRN<c>.I<size> <Dd>, <Qm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrshrn);
    rInsn.SetMnemonic("vrshrn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".I");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VADDHN<c>.<dt> <Dd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VADDHN_T1_ff800f50_ef800400(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VADDHN<c>.<dt> <Dd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vaddhn);
    rInsn.SetMnemonic("vaddhn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSUBHN<c>.<dt> <Dd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VSUBHN_T1_ff800f50_ef800600(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSUBHN<c>.<dt> <Dd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vsubhn);
    rInsn.SetMnemonic("vsubhn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQD<op><c>.<dt> <Qd>, <Dn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', 'op#1', '1', '1', 'N#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQD_T2_ff800b50_ef800340(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQD<op><c>.<dt> <Qd>, <Dn>, <Dm[x]>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqd);
    rInsn.SetMnemonic("vqd");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Dm[x]>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '1', 'N#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQDMULL_T2_ff800f50_ef800b40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqdmull);
    rInsn.SetMnemonic("vqdmull");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Dm[x]>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQD<op><c>.<dt> <Qd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', 'op#1', '1', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQD_T1_ff800d50_ef800900(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQD<op><c>.<dt> <Qd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqd);
    rInsn.SetMnemonic("vqd");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '0', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQDMULL_T1_ff800f50_ef800d00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqdmull);
    rInsn.SetMnemonic("vqdmull");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SSAT16<c> <Rd>, #<imm>, <Rn> - ['could_jmp'] - ['1', '1', '1', '1', '0', '(0)', '1', '1', '0', '0', '1', '0', 'Rn#4', '0', '0', '0', '0', 'Rd#4', '0', '0', '(0)', '(0)', 'sat_imm#4']
bool ArmArchitecture::Instruction_SSAT16_T1_fff0f0f0_f3200000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SSAT16<c> <Rd>, #<imm>, <Rn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ssat16);
    rInsn.SetMnemonic("ssat16");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 3>(Opcode)) /* sat_imm */));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SSAT<c> <Rd>, #<imm>, <Rn>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '1', '0', '(0)', '1', '1', '0', '0', 'sh#1', '0', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#2', '(0)', 'sat_imm#5']
bool ArmArchitecture::Instruction_SSAT_T1_ffd08020_f3000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SSAT<c> <Rd>, #<imm>, <Rn>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ssat);
    rInsn.SetMnemonic("ssat");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
    // FIXME: not_implemented: "operand <Rn>{,<shift>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SBFX<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - ['1', '1', '1', '1', '0', '(0)', '1', '1', '0', '1', '0', '0', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#2', '(0)', 'widthm1#5']
bool ArmArchitecture::Instruction_SBFX_T1_fff08020_f3400000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SBFX<c> <Rd>, <Rn>, #<lsb>, #<width>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sbfx);
    rInsn.SetMnemonic("sbfx");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand #<lsb>";
    // FIXME: not_implemented: "operand #<width>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BFC<c> <Rd>, #<lsb>, #<width> - ['could_jmp'] - ['1', '1', '1', '1', '0', '(0)', '1', '1', '0', '1', '1', '0', '1', '1', '1', '1', '0', 'imm#3', 'Rd#4', 'imm#2', '(0)', 'msb#5']
bool ArmArchitecture::Instruction_BFC_T1_ffff8020_f36f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BFC<c> <Rd>, #<lsb>, #<width>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Bfc);
    rInsn.SetMnemonic("bfc");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    // FIXME: not_implemented: "operand #<lsb>";
    // FIXME: not_implemented: "operand #<width>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BFI<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - ['1', '1', '1', '1', '0', '(0)', '1', '1', '0', '1', '1', '0', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#2', '(0)', 'msb#5']
bool ArmArchitecture::Instruction_BFI_T1_fff08020_f3600000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BFI<c> <Rd>, <Rn>, #<lsb>, #<width>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Bfi);
    rInsn.SetMnemonic("bfi");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand #<lsb>";
    // FIXME: not_implemented: "operand #<width>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// USAT16<c> <Rd>, #<imm4>, <Rn> - ['could_jmp'] - ['1', '1', '1', '1', '0', '(0)', '1', '1', '1', '0', '1', '0', 'Rn#4', '0', '0', '0', '0', 'Rd#4', '0', '0', '(0)', '(0)', 'sat_imm#4']
bool ArmArchitecture::Instruction_USAT16_T1_fff0f0f0_f3a00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("USAT16<c> <Rd>, #<imm4>, <Rn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Usat16);
    rInsn.SetMnemonic("usat16");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    // FIXME: not_implemented: "operand #<imm4>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// USAT<c> <Rd>, #<imm5>, <Rn>{,<shift>} - ['could_jmp'] - ['1', '1', '1', '1', '0', '(0)', '1', '1', '1', '0', 'sh#1', '0', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#2', '(0)', 'sat_imm#5']
bool ArmArchitecture::Instruction_USAT_T1_ffd08020_f3800000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("USAT<c> <Rd>, #<imm5>, <Rn>{,<shift>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Usat);
    rInsn.SetMnemonic("usat");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<6, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 2) /* imm */));
    // FIXME: not_implemented: "operand <Rn>{,<shift>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UBFX<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - ['1', '1', '1', '1', '0', '(0)', '1', '1', '1', '1', '0', '0', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#2', '(0)', 'widthm1#5']
bool ArmArchitecture::Instruction_UBFX_T1_fff08020_f3c00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UBFX<c> <Rd>, <Rn>, #<lsb>, #<width>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ubfx);
    rInsn.SetMnemonic("ubfx");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand #<lsb>";
    // FIXME: not_implemented: "operand #<width>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MSR<c> <spec_reg>, <Rn> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '0', '0', 'Rn#4', '1', '0', '(0)', '0', 'mask#2', '0', '0', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_MSR_T1_fff0f3ff_f3808000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MSR<c> <spec_reg>, <Rn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Msr);
    rInsn.SetMnemonic("msr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <spec_reg>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// NOP<c>.W - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '1', '0', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', '(0)', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
bool ArmArchitecture::Instruction_NOP_T2_ffffffff_f3af8000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("NOP<c>.W");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Nop);
    rInsn.SetMnemonic("nop");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// YIELD<c>.W - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '1', '0', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', '(0)', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1']
bool ArmArchitecture::Instruction_YIELD_T2_ffffffff_f3af8001(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("YIELD<c>.W");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Yield);
    rInsn.SetMnemonic("yield");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// WFE<c>.W - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '1', '0', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', '(0)', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '0']
bool ArmArchitecture::Instruction_WFE_T2_ffffffff_f3af8002(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("WFE<c>.W");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Wfe);
    rInsn.SetMnemonic("wfe");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// WFI<c>.W - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '1', '0', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', '(0)', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '1']
bool ArmArchitecture::Instruction_WFI_T2_ffffffff_f3af8003(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("WFI<c>.W");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Wfi);
    rInsn.SetMnemonic("wfi");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SEV<c>.W - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '1', '0', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', '(0)', '0', '0', '0', '0', '0', '0', '0', '0', '1', '0', '0']
bool ArmArchitecture::Instruction_SEV_T2_ffffffff_f3af8004(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SEV<c>.W");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sev);
    rInsn.SetMnemonic("sev");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// DBG<c> #<option> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '1', '0', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', '(0)', '0', '0', '0', '1', '1', '1', '1', 'option#4']
bool ArmArchitecture::Instruction_DBG_T1_fffffff0_f3af80f0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("DBG<c> #<option>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Dbg);
    rInsn.SetMnemonic("dbg");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 3>(Opcode)) /* option */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CLREX<c> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '1', '1', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', '(1)', '(1)', '(1)', '(1)', '0', '0', '1', '0', '(1)', '(1)', '(1)', '(1)']
bool ArmArchitecture::Instruction_CLREX_T1_ffffffff_f3bf8f2f(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CLREX<c>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Clrex);
    rInsn.SetMnemonic("clrex");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// DSB<c> #<option> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '1', '1', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '0', 'option#4']
bool ArmArchitecture::Instruction_DSB_T1_fffffff0_f3bf8f40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("DSB<c> #<option>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Dsb);
    rInsn.SetMnemonic("dsb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 3>(Opcode)) /* option */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// DMB<c> #<option> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '1', '1', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', '(1)', '(1)', '(1)', '(1)', '0', '1', '0', '1', 'option#4']
bool ArmArchitecture::Instruction_DMB_T1_fffffff0_f3bf8f50(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("DMB<c> #<option>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Dmb);
    rInsn.SetMnemonic("dmb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 3>(Opcode)) /* option */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ISB<c> #<option> - [] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '0', '1', '1', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', '(1)', '(1)', '(1)', '(1)', '0', '1', '1', '0', 'option#4']
bool ArmArchitecture::Instruction_ISB_T1_fffffff0_f3bf8f60(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ISB<c> #<option>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Isb);
    rInsn.SetMnemonic("isb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 3>(Opcode)) /* option */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BXJ<c> <Rm> - ['call', 'change_to_jazelle'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '1', '0', '0', 'Rm#4', '1', '0', '(0)', '0', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_BXJ_T1_fff0ffff_f3c08f00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BXJ<c> <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Bxj);
    rInsn.SubType() |= Instruction::CallType;
    rInsn.SetMnemonic("bxj");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MRS<c> <Rd>, <spec_reg> - ['could_jmp'] - ['1', '1', '1', '1', '0', '0', '1', '1', '1', '1', '1', '0', '(1)', '(1)', '(1)', '(1)', '1', '0', '(0)', '0', 'Rd#4', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_MRS_T1_fffff0ff_f3ef8000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MRS<c> <Rd>, <spec_reg>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mrs);
    rInsn.SetMnemonic("mr");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <spec_reg>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// B<c>.W <thumb_branch_label> - ['jmp'] - ['1', '1', '1', '1', '0', 'S#1', 'cond#4', 'imm#6', '1', '0', 'J1#1', '0', 'J2#1', 'imm#11']
bool ArmArchitecture::Instruction_B_T3_f800d000_f0008000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("B<c>.W <thumb_branch_label>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_B);
    rInsn.SubType() |= Instruction::JumpType;
    rInsn.SetMnemonic("b");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo) + (ExtractBits<0, 10>(Opcode) | ExtractBits<16, 21>(Opcode) << 11) << 1 | 0);
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// B<c>.W <thumb_branch_label> - ['jmp'] - ['1', '1', '1', '1', '0', 'S#1', 'imm#10', '1', '0', 'J1#1', '1', 'J2#1', 'imm#11']
bool ArmArchitecture::Instruction_B_T4_f800d000_f0009000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("B<c>.W <thumb_branch_label>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_B);
    rInsn.SubType() |= Instruction::JumpType;
    rInsn.SetMnemonic("b");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo) + (ExtractBits<0, 10>(Opcode) | ExtractBits<16, 25>(Opcode) << 11) << 1 | 0);
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BL<c> <thumb_branch_label> - ['call'] - ['1', '1', '1', '1', '0', 'S#1', 'imm#10', '1', '1', 'J1#1', '1', 'J2#1', 'imm#11']
bool ArmArchitecture::Instruction_BL_T1_f800d000_f000d000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BL<c> <thumb_branch_label>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Bl);
    rInsn.SubType() |= Instruction::CallType;
    rInsn.SetMnemonic("bl");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo) + (ExtractBits<0, 10>(Opcode) | ExtractBits<16, 25>(Opcode) << 11) << 1 | 0);
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BLX<c> <label> - ['thumb_branch_label'] - ['1', '1', '1', '1', '0', 'S#1', 'imm_h#10', '1', '1', 'J1#1', '0', 'J2#1', 'imm_l#10', '0']
bool ArmArchitecture::Instruction_BLX_T2_f800d001_f000c000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BLX<c> <label>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Blx);
    rInsn.SetMnemonic("blx");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo) + (ExtractBits<16, 25>(Opcode)) << 10 | (ExtractBits<1, 10>(Opcode)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// TST<c> <Rn>, #<imm> - [] - ['1', '1', '1', '1', '0', 'imm#1', '0', '0', '0', '0', '0', '1', 'Rn#4', '0', 'imm#3', '1', '1', '1', '1', 'imm#8']
bool ArmArchitecture::Instruction_TST_T1_fbf08f00_f0100f00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("TST<c> <Rn>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Tst);
    rInsn.SetMnemonic("tst");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// AND{S}<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '0', '0', '0', '0', 'S#1', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_AND_T1_fbe08000_f0000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("AND{S}<c> <Rd>, <Rn>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_And);
    rInsn.SetMnemonic("and");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// BIC{S}<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '0', '0', '0', '1', 'S#1', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_BIC_T1_fbe08000_f0200000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("BIC{S}<c> <Rd>, <Rn>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Bic);
    rInsn.SetMnemonic("bic");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MOV{S}<c>.W <Rd>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '0', '0', '1', '0', 'S#1', '1', '1', '1', '1', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_MOV_T2_fbef8000_f04f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MOV{S}<c>.W <Rd>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mov);
    rInsn.SetMnemonic("mov");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ORR{S}<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '0', '0', '1', '0', 'S#1', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_ORR_T1_fbe08000_f0400000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ORR{S}<c> <Rd>, <Rn>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Orr);
    rInsn.SetMnemonic("orr");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MVN{S}<c> <Rd>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '0', '0', '1', '1', 'S#1', '1', '1', '1', '1', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_MVN_T1_fbef8000_f06f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MVN{S}<c> <Rd>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mvn);
    rInsn.SetMnemonic("mvn");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ORN{S}<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '0', '0', '1', '1', 'S#1', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_ORN_T1_fbe08000_f0600000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ORN{S}<c> <Rd>, <Rn>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Orn);
    rInsn.SetMnemonic("orn");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// TEQ<c> <Rn>, #<imm> - [] - ['1', '1', '1', '1', '0', 'imm#1', '0', '0', '1', '0', '0', '1', 'Rn#4', '0', 'imm#3', '1', '1', '1', '1', 'imm#8']
bool ArmArchitecture::Instruction_TEQ_T1_fbf08f00_f0900f00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("TEQ<c> <Rn>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Teq);
    rInsn.SetMnemonic("teq");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// EOR{S}<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '0', '1', '0', '0', 'S#1', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_EOR_T1_fbe08000_f0800000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("EOR{S}<c> <Rd>, <Rn>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Eor);
    rInsn.SetMnemonic("eor");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CMN<c> <Rn>, #<thumb_expand_imm> - ['cond'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '1', '0', '0', '0', '1', 'Rn#4', '0', 'imm#3', '1', '1', '1', '1', 'imm#8']
bool ArmArchitecture::Instruction_CMN_T1_fbf08f00_f1100f00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CMN<c> <Rn>, #<thumb_expand_imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Cmn);
    rInsn.SetMnemonic("cmn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand #<thumb_expand_imm>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADD{S}<c>.W <Rd>, SP, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '1', '0', '0', '0', 'S#1', '1', '1', '0', '1', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_ADD_T3_fbef8000_f10d0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADD{S}<c>.W <Rd>, SP, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Add);
    rInsn.SetMnemonic("add");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Sp, &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADD{S}<c>.W <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '1', '0', '0', '0', 'S#1', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_ADD_T3_fbe08000_f1000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADD{S}<c>.W <Rd>, <Rn>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Add);
    rInsn.SetMnemonic("add");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADC{S}<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '1', '0', '1', '0', 'S#1', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_ADC_T1_fbe08000_f1400000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADC{S}<c> <Rd>, <Rn>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Adc);
    rInsn.SetMnemonic("adc");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SBC{S}<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '1', '0', '1', '1', 'S#1', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_SBC_T1_fbe08000_f1600000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SBC{S}<c> <Rd>, <Rn>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sbc);
    rInsn.SetMnemonic("sbc");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CMP<c>.W <Rn>, #<imm> - ['cond'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '1', '1', '0', '1', '1', 'Rn#4', '0', 'imm#3', '1', '1', '1', '1', 'imm#8']
bool ArmArchitecture::Instruction_CMP_T2_fbf08f00_f1b00f00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CMP<c>.W <Rn>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Cmp);
    rInsn.SetMnemonic("cmp");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SUB{S}<c>.W <Rd>, SP, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '1', '1', '0', '1', 'S#1', '1', '1', '0', '1', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_SUB_T2_fbef8000_f1ad0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SUB{S}<c>.W <Rd>, SP, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sub);
    rInsn.SetMnemonic("sub");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Sp, &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SUB{S}<c>.W <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '1', '1', '0', '1', 'S#1', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_SUB_T3_fbe08000_f1a00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SUB{S}<c>.W <Rd>, <Rn>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sub);
    rInsn.SetMnemonic("sub");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// RSB{S}<c>.W <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '0', '1', '1', '1', '0', 'S#1', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_RSB_T2_fbe08000_f1c00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("RSB{S}<c>.W <Rd>, <Rn>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Rsb);
    rInsn.SetMnemonic("rsb");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADDW<c> <Rd>, SP, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '1', '0', '0', '0', '0', '0', '1', '1', '0', '1', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_ADDW_T4_fbff8000_f20d0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADDW<c> <Rd>, SP, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Addw);
    rInsn.SetMnemonic("addw");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Sp, &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADR<c>.W <Rd>, <label> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '1', '0', '0', '0', '0', '0', '1', '1', '1', '1', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_ADR_T3_fbff8000_f20f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADR<c>.W <Rd>, <label>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Adr);
    rInsn.SetMnemonic("adr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo) + (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */);
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ADDW<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '1', '0', '0', '0', '0', '0', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_ADDW_T4_fbf08000_f2000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ADDW<c> <Rd>, <Rn>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Addw);
    rInsn.SetMnemonic("addw");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MOVW<c> <Rd>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '1', '0', '0', '1', '0', '0', 'imm#4', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_MOVW_T3_fbf08000_f2400000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MOVW<c> <Rd>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Movw);
    rInsn.SetMnemonic("movw");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBits<16, 19>(Opcode) << 11 | ExtractBit<26>(Opcode) << 15) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SUBW<c> <Rd>, SP, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '1', '0', '1', '0', '1', '0', '1', '1', '0', '1', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_SUBW_T3_fbff8000_f2ad0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SUBW<c> <Rd>, SP, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Subw);
    rInsn.SetMnemonic("subw");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Sp, &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SUB <Rd>, PC, #0 - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '1', '0', '1', '0', '1', '0', '1', '1', '1', '1', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_SUB_T2_fbff8000_f2af0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SUB <Rd>, PC, #0");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sub);
    rInsn.SetMnemonic("sub");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, 0x0));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SUBW<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '1', '0', '1', '0', '1', '0', 'Rn#4', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_SUBW_T4_fbf08000_f2a00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SUBW<c> <Rd>, <Rn>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Subw);
    rInsn.SetMnemonic("subw");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBit<26>(Opcode) << 11) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MOVT<c> <Rd>, #<imm> - ['could_jmp'] - ['1', '1', '1', '1', '0', 'imm#1', '1', '0', '1', '1', '0', '0', 'imm#4', '0', 'imm#3', 'Rd#4', 'imm#8']
bool ArmArchitecture::Instruction_MOVT_T1_fbf08000_f2c00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MOVT<c> <Rd>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Movt);
    rInsn.SetMnemonic("movt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode) | ExtractBits<12, 14>(Opcode) << 8 | ExtractBits<16, 19>(Opcode) << 11 | ExtractBit<26>(Opcode) << 15) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRB<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', 'Rn#4', 'Rt#4', '0', '0', '0', '0', '0', '0', 'imm#2', 'Rm#4']
bool ArmArchitecture::Instruction_STRB_T2_fff00fc0_f8000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRB<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strb);
    rInsn.SetMnemonic("strb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    // FIXME: not_implemented: "[<Rn>";
    // FIXME: not_implemented: "operand <Rm>{,LSL";
    // FIXME: not_implemented: "operand #<imm>}]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRBT<c> <Rt>, [<Rn>, #<disp>] - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', 'Rn#4', 'Rt#4', '1', '1', '1', '0', 'imm#8']
bool ArmArchitecture::Instruction_STRBT_T1_fff00f00_f8000e00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRBT<c> <Rt>, [<Rn>, #<disp>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strbt);
    rInsn.SetMnemonic("strbt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRB<c> <Rt>, [<Rn>, #<disp>]! - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', 'Rn#4', 'Rt#4', '1', 'P#1', 'U#1', 'W#1', 'imm#8']
bool ArmArchitecture::Instruction_STRB_T3_fff00800_f8000800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRB<c> <Rt>, [<Rn>, #<disp>]!");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strb);
    rInsn.SetMnemonic("strb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddAttribute(ARM_Attribute_WriteBack);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRB<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '1', 'Rn#4', 'Rt#4', '0', '0', '0', '0', '0', '0', 'imm#2', 'Rm#4']
bool ArmArchitecture::Instruction_LDRB_T2_fff00fc0_f8100000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRB<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrb);
    rInsn.SetMnemonic("ldrb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo) << (ExtractBits<4, 5>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRBT<c> <Rt>, [<Rn>, #<disp>] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '1', 'Rn#4', 'Rt#4', '1', '1', '1', '0', 'imm#8']
bool ArmArchitecture::Instruction_LDRBT_T1_fff00f00_f8100e00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRBT<c> <Rt>, [<Rn>, #<disp>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrbt);
    rInsn.SetMnemonic("ldrbt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRB<c> <Rt>, [<Rn>, #<disp>]! - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '1', 'Rn#4', 'Rt#4', '1', 'P#1', 'U#1', 'W#1', 'imm#8']
bool ArmArchitecture::Instruction_LDRB_T3_fff00800_f8100800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRB<c> <Rt>, [<Rn>, #<disp>]!");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrb);
    rInsn.SetMnemonic("ldrb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddAttribute(ARM_Attribute_WriteBack);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRH<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '1', '0', 'Rn#4', 'Rt#4', '0', '0', '0', '0', '0', '0', 'imm#2', 'Rm#4']
bool ArmArchitecture::Instruction_STRH_T2_fff00fc0_f8200000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRH<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strh);
    rInsn.SetMnemonic("strh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    // FIXME: not_implemented: "[<Rn>";
    // FIXME: not_implemented: "operand <Rm>{,LSL";
    // FIXME: not_implemented: "operand #<imm>}]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRHT<c> <Rt>, [<Rn>, #<disp>] - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '1', '0', 'Rn#4', 'Rt#4', '1', '1', '1', '0', 'imm#8']
bool ArmArchitecture::Instruction_STRHT_T1_fff00f00_f8200e00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRHT<c> <Rt>, [<Rn>, #<disp>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strht);
    rInsn.SetMnemonic("strht");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRH<c> <Rt>, [<Rn>, #<disp>]! - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '1', '0', 'Rn#4', 'Rt#4', '1', 'P#1', 'U#1', 'W#1', 'imm#8']
bool ArmArchitecture::Instruction_STRH_T3_fff00800_f8200800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRH<c> <Rt>, [<Rn>, #<disp>]!");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strh);
    rInsn.SetMnemonic("strh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddAttribute(ARM_Attribute_WriteBack);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRH<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '1', '1', 'Rn#4', 'Rt#4', '0', '0', '0', '0', '0', '0', 'imm#2', 'Rm#4']
bool ArmArchitecture::Instruction_LDRH_T2_fff00fc0_f8300000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRH<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrh);
    rInsn.SetMnemonic("ldrh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    // FIXME: not_implemented: "[<Rn>";
    // FIXME: not_implemented: "operand <Rm>{,LSL";
    // FIXME: not_implemented: "operand #<imm>}]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRHT<c> <Rt>, [<Rn>, #<disp>] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '1', '1', 'Rn#4', 'Rt#4', '1', '1', '1', '0', 'imm#8']
bool ArmArchitecture::Instruction_LDRHT_T1_fff00f00_f8300e00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRHT<c> <Rt>, [<Rn>, #<disp>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrht);
    rInsn.SetMnemonic("ldrht");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRH<c> <Rt>, [<Rn>, #<disp>]! - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '1', '1', 'Rn#4', 'Rt#4', '1', 'P#1', 'U#1', 'W#1', 'imm#8']
bool ArmArchitecture::Instruction_LDRH_T3_fff00800_f8300800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRH<c> <Rt>, [<Rn>, #<disp>]!");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrh);
    rInsn.SetMnemonic("ldrh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddAttribute(ARM_Attribute_WriteBack);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// PUSH<c>.W <Rt> - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '1', '0', '0', '1', '1', '0', '1', 'Rt#4', '1', '1', '0', '1', '0', '0', '0', '0', '0', '1', '0', '0']
bool ArmArchitecture::Instruction_PUSH_T3_ffff0fff_f84d0d04(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("PUSH<c>.W <Rt>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Push);
    rInsn.SetMnemonic("push");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STR<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '1', '0', '0', 'Rn#4', 'Rt#4', '0', '0', '0', '0', '0', '0', 'imm#2', 'Rm#4']
bool ArmArchitecture::Instruction_STR_T2_fff00fc0_f8400000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STR<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Str);
    rInsn.SetMnemonic("str");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    // FIXME: not_implemented: "[<Rn>";
    // FIXME: not_implemented: "operand <Rm>{,LSL";
    // FIXME: not_implemented: "operand #<imm>}]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRT<c> <Rt>, [<Rn>, #<disp>] - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '1', '0', '0', 'Rn#4', 'Rt#4', '1', '1', '1', '0', 'imm#8']
bool ArmArchitecture::Instruction_STRT_T1_fff00f00_f8400e00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRT<c> <Rt>, [<Rn>, #<disp>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strt);
    rInsn.SetMnemonic("strt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STR<c> <Rt>, [<Rn>, #<disp>]! - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '1', '0', '0', 'Rn#4', 'Rt#4', '1', 'P#1', 'U#1', 'W#1', 'imm#8']
bool ArmArchitecture::Instruction_STR_T4_fff00800_f8400800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STR<c> <Rt>, [<Rn>, #<disp>]!");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Str);
    rInsn.SetMnemonic("str");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddAttribute(ARM_Attribute_WriteBack);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// POP<c>.W <Rt> - ['could_ret'] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '1', '0', '1', '1', '1', '0', '1', 'Rt#4', '1', '0', '1', '1', '0', '0', '0', '0', '0', '1', '0', '0']
bool ArmArchitecture::Instruction_POP_T3_ffff0fff_f85d0b04(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("POP<c>.W <Rt>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Pop);
    rInsn.SetMnemonic("pop");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDR<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '1', '0', '1', 'Rn#4', 'Rt#4', '0', '0', '0', '0', '0', '0', 'imm#2', 'Rm#4']
bool ArmArchitecture::Instruction_LDR_T2_fff00fc0_f8500000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDR<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldr);
    rInsn.SetMnemonic("ldr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo) << Expr::MakeBitVector(32, (ExtractBits<4, 5>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRT<c> <Rt>, [<Rn>, #<disp>] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '1', '0', '1', 'Rn#4', 'Rt#4', '1', '1', '1', '0', 'imm#8']
bool ArmArchitecture::Instruction_LDRT_T1_fff00f00_f8500e00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRT<c> <Rt>, [<Rn>, #<disp>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrt);
    rInsn.SetMnemonic("ldrt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDR<c> <Rt>, [<Rn>, #<disp>]! - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '0', '1', '0', '1', 'Rn#4', 'Rt#4', '1', 'P#1', 'U#1', 'W#1', 'imm#8']
bool ArmArchitecture::Instruction_LDR_T4_fff00800_f8500800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDR<c> <Rt>, [<Rn>, #<disp>]!");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldr);
    rInsn.SetMnemonic("ldr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddAttribute(ARM_Attribute_WriteBack);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRB<c>.W <Rt>, [<Rn>, #<disp>] - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '1', '0', '0', '0', 'Rn#4', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_STRB_T2_fff00000_f8800000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRB<c>.W <Rt>, [<Rn>, #<disp>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strb);
    rInsn.SetMnemonic("strb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRB<c>.W <Rt>, [<Rn>{, #<disp>}] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '1', '0', '0', '1', 'Rn#4', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_LDRB_T2_fff00000_f8900000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRB<c>.W <Rt>, [<Rn>{, #<disp>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrb);
    rInsn.SetMnemonic("ldrb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STRH<c>.W <Rt>, [<Rn>{, #<disp>}] - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '1', '0', '1', '0', 'Rn#4', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_STRH_T2_fff00000_f8a00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STRH<c>.W <Rt>, [<Rn>{, #<disp>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Strh);
    rInsn.SetMnemonic("strh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRH<c>.W <Rt>, [<Rn>{, #<disp>}] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '1', '0', '1', '1', 'Rn#4', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_LDRH_T2_fff00000_f8b00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRH<c>.W <Rt>, [<Rn>{, #<disp>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrh);
    rInsn.SetMnemonic("ldrh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STR<c>.W <Rt>, [<Rn>, #<disp>] - [] - ['1', '1', '1', '1', '1', '0', '0', '0', '1', '1', '0', '0', 'Rn#4', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_STR_T3_fff00000_f8c00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STR<c>.W <Rt>, [<Rn>, #<disp>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Str);
    rInsn.SetMnemonic("str");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDR<c>.W <Rt>, [<Rn>{, #<disp>}] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', '1', '1', '0', '1', 'Rn#4', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_LDR_T3_fff00000_f8d00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDR<c>.W <Rt>, [<Rn>{, #<disp>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldr);
    rInsn.SetMnemonic("ldr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// PLD<c> [PC,#-0] - [] - ['1', '1', '1', '1', '1', '0', '0', '0', 'U#1', '0', '(0)', '1', '1', '1', '1', '1', '1', '1', '1', '1', 'imm#12']
bool ArmArchitecture::Instruction_PLD_T1_ff7ff000_f81ff000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("PLD<c> [PC,#-0]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Pld);
    rInsn.SetMnemonic("pld");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeMem(64, nullptr, Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRB<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', 'U#1', '0', '0', '1', '1', '1', '1', '1', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_LDRB_T1_ff7f0000_f81f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRB<c> <Rt>, [PC,#-0]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrb);
    rInsn.SetMnemonic("ldrb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRH<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', 'U#1', '0', '1', '1', '1', '1', '1', '1', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_LDRH_T1_ff7f0000_f83f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRH<c> <Rt>, [PC,#-0]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrh);
    rInsn.SetMnemonic("ldrh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDR<c>.W <Rt>, [PC,#-0] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '0', 'U#1', '1', '0', '1', '1', '1', '1', '1', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_LDR_T2_ff7f0000_f85f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDR<c>.W <Rt>, [PC,#-0]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldr);
    rInsn.SetMnemonic("ldr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// PLI<c> [<Rn>, <Rm>{,LSL #<imm>}] - [] - ['1', '1', '1', '1', '1', '0', '0', '1', '0', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', '0', '0', '0', '0', '0', '0', 'imm#2', 'Rm#4']
bool ArmArchitecture::Instruction_PLI_T1_fff0ffc0_f910f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("PLI<c> [<Rn>, <Rm>{,LSL #<imm>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Pli);
    rInsn.SetMnemonic("pli");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "[<Rn>";
    // FIXME: not_implemented: "operand <Rm>{,LSL";
    // FIXME: not_implemented: "operand #<imm>}]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// PLI<c> [<Rn>,#-<imm>] - [] - ['1', '1', '1', '1', '1', '0', '0', '1', '0', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', '1', '1', '0', '0', 'imm#8']
bool ArmArchitecture::Instruction_PLI_T2_fff0ff00_f910fc00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("PLI<c> [<Rn>,#-<imm>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Pli);
    rInsn.SetMnemonic("pli");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand [<Rn>,#-<imm>]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSB<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '1', '0', '0', '0', '1', 'Rn#4', 'Rt#4', '0', '0', '0', '0', '0', '0', 'imm#2', 'Rm#4']
bool ArmArchitecture::Instruction_LDRSB_T2_fff00fc0_f9100000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSB<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrsb);
    rInsn.SetMnemonic("ldrsb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    // FIXME: not_implemented: "[<Rn>";
    // FIXME: not_implemented: "operand <Rm>{,LSL";
    // FIXME: not_implemented: "operand #<imm>}]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSBT<c> <Rt>, [<Rn>, #<disp>] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '1', '0', '0', '0', '1', 'Rn#4', 'Rt#4', '1', '1', '1', '0', 'imm#8']
bool ArmArchitecture::Instruction_LDRSBT_T1_fff00f00_f9100e00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSBT<c> <Rt>, [<Rn>, #<disp>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrsbt);
    rInsn.SetMnemonic("ldrsbt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSB<c> <Rt>, [<Rn>, #<disp>]! - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '1', '0', '0', '0', '1', 'Rn#4', 'Rt#4', '1', 'P#1', 'U#1', 'W#1', 'imm#8']
bool ArmArchitecture::Instruction_LDRSB_T2_fff00800_f9100800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSB<c> <Rt>, [<Rn>, #<disp>]!");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrsb);
    rInsn.SetMnemonic("ldrsb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddAttribute(ARM_Attribute_WriteBack);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSH<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '1', '0', '0', '1', '1', 'Rn#4', 'Rt#4', '0', '0', '0', '0', '0', '0', 'imm#2', 'Rm#4']
bool ArmArchitecture::Instruction_LDRSH_T2_fff00fc0_f9300000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSH<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrsh);
    rInsn.SetMnemonic("ldrsh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    // FIXME: not_implemented: "[<Rn>";
    // FIXME: not_implemented: "operand <Rm>{,LSL";
    // FIXME: not_implemented: "operand #<imm>}]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSHT<c> <Rt>, [<Rn>, #<disp>] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '1', '0', '0', '1', '1', 'Rn#4', 'Rt#4', '1', '1', '1', '0', 'imm#8']
bool ArmArchitecture::Instruction_LDRSHT_T1_fff00f00_f9300e00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSHT<c> <Rt>, [<Rn>, #<disp>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrsht);
    rInsn.SetMnemonic("ldrsht");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSH<c> <Rt>, [<Rn>, #<disp>]! - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '1', '0', '0', '1', '1', 'Rn#4', 'Rt#4', '1', 'P#1', 'U#1', 'W#1', 'imm#8']
bool ArmArchitecture::Instruction_LDRSH_T2_fff00800_f9300800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSH<c> <Rt>, [<Rn>, #<disp>]!");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrsh);
    rInsn.SetMnemonic("ldrsh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddAttribute(ARM_Attribute_WriteBack);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 7>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VST1<c>.<size> <list>, [<Rn>{@<align>}]{!} - ['support it block'] - ['1', '1', '1', '1', '1', '0', '0', '1', '0', 'D#1', '0', '0', 'Rn#4', 'Vd#4', 'type#4', 'size#2', 'align#2', 'Rm#4']
bool ArmArchitecture::Instruction_VST1_T1_ffb00000_f9000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VST1<c>.<size> <list>, [<Rn>{@<align>}]{!}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vst1);
    rInsn.SetMnemonic("vst1");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    // FIXME: not_implemented: "operand <list>";
    // FIXME: not_implemented: "operand [<Rn>{@<align>}]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VLD1<c>.<size> <list>, [<Rn>{@<align>}]{!} - ['support it block'] - ['1', '1', '1', '1', '1', '0', '0', '1', '0', 'D#1', '1', '0', 'Rn#4', 'Vd#4', 'type#4', 'size#2', 'align#2', 'Rm#4']
bool ArmArchitecture::Instruction_VLD1_T1_ffb00000_f9200000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VLD1<c>.<size> <list>, [<Rn>{@<align>}]{!}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vld1);
    rInsn.SetMnemonic("vld1");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    // FIXME: not_implemented: "operand <list>";
    // FIXME: not_implemented: "operand [<Rn>{@<align>}]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// PLI<c> [<Rn>, #<disp>] - [] - ['1', '1', '1', '1', '1', '0', '0', '1', '1', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', 'imm#12']
bool ArmArchitecture::Instruction_PLI_T1_fff0f000_f990f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("PLI<c> [<Rn>, #<disp>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Pli);
    rInsn.SetMnemonic("pli");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSB<c> <Rt>, [<Rn>, #<disp>] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '1', '1', '0', '0', '1', 'Rn#4', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_LDRSB_T1_fff00000_f9900000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSB<c> <Rt>, [<Rn>, #<disp>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrsb);
    rInsn.SetMnemonic("ldrsb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSH<c> <Rt>, [<Rn>, #<disp>] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '1', '1', '0', '1', '1', 'Rn#4', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_LDRSH_T1_fff00000_f9b00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSH<c> <Rt>, [<Rn>, #<disp>]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrsh);
    rInsn.SetMnemonic("ldrsh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + Expr::MakeBitVector(32, (ExtractBits<0, 11>(Opcode)) /* imm */)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VST1<c>.<size> <list>, [<Rn>{@<align>}]{!} - ['support it block'] - ['1', '1', '1', '1', '1', '0', '0', '1', '1', 'D#1', '0', '0', 'Rn#4', 'Vd#4', 'size#2', '0', '0', 'index_align#4', 'Rm#4']
bool ArmArchitecture::Instruction_VST1_T1_ffb00300_f9800000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VST1<c>.<size> <list>, [<Rn>{@<align>}]{!}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vst1);
    rInsn.SetMnemonic("vst1");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    // FIXME: not_implemented: "operand <list>";
    // FIXME: not_implemented: "operand [<Rn>{@<align>}]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VLD1<c>.<size> <list>, [<Rn>{@<align>}]{!} - ['support it block'] - ['1', '1', '1', '1', '1', '0', '0', '1', '1', 'D#1', '1', '0', 'Rn#4', 'Vd#4', '1', '1', '0', '0', 'size#2', 'T#1', 'a#1', 'Rm#4']
bool ArmArchitecture::Instruction_VLD1_T1_ffb00f00_f9a00c00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VLD1<c>.<size> <list>, [<Rn>{@<align>}]{!}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vld1);
    rInsn.SetMnemonic("vld1");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    // FIXME: not_implemented: "operand <list>";
    // FIXME: not_implemented: "operand [<Rn>{@<align>}]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VLD1<c>.<size> <list>, [<Rn>{@<align>}]{!} - ['support it block'] - ['1', '1', '1', '1', '1', '0', '0', '1', '1', 'D#1', '1', '0', 'Rn#4', 'Vd#4', 'size#2', '0', '0', 'index_align#4', 'Rm#4']
bool ArmArchitecture::Instruction_VLD1_T1_ffb00300_f9a00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VLD1<c>.<size> <list>, [<Rn>{@<align>}]{!}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vld1);
    rInsn.SetMnemonic("vld1");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    // FIXME: not_implemented: "operand <list>";
    // FIXME: not_implemented: "operand [<Rn>{@<align>}]";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// PLI<c> [PC,#-0] - [] - ['1', '1', '1', '1', '1', '0', '0', '1', 'U#1', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', 'imm#12']
bool ArmArchitecture::Instruction_PLI_T3_ff7ff000_f91ff000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("PLI<c> [PC,#-0]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Pli);
    rInsn.SetMnemonic("pli");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSB<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '1', 'U#1', '0', '0', '1', '1', '1', '1', '1', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_LDRSB_T1_ff7f0000_f91f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSB<c> <Rt>, [PC,#-0]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrsb);
    rInsn.SetMnemonic("ldrsb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(8, nullptr, Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDRSH<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '0', '1', 'U#1', '0', '1', '1', '1', '1', '1', '1', 'Rt#4', 'imm#12']
bool ArmArchitecture::Instruction_LDRSH_T1_ff7f0000_f93f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDRSH<c> <Rt>, [PC,#-0]");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldrsh);
    rInsn.SetMnemonic("ldrsh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeMem(16, nullptr, Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo)));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SXTH<c>.W <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
bool ArmArchitecture::Instruction_SXTH_T2_fffff0c0_fa0ff080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SXTH<c>.W <Rd>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sxth);
    rInsn.SetMnemonic("sxth");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SXTAH<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
bool ArmArchitecture::Instruction_SXTAH_T1_fff0f0c0_fa00f080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SXTAH<c> <Rd>, <Rn>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sxtah);
    rInsn.SetMnemonic("sxtah");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UXTH<c>.W <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
bool ArmArchitecture::Instruction_UXTH_T2_fffff0c0_fa1ff080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UXTH<c>.W <Rd>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uxth);
    rInsn.SetMnemonic("uxth");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UXTAH<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
bool ArmArchitecture::Instruction_UXTAH_T1_fff0f0c0_fa10f080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UXTAH<c> <Rd>, <Rn>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uxtah);
    rInsn.SetMnemonic("uxtah");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LSL{S}<c>.W <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '0', 'S#1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_LSL_T2_ffe0f0f0_fa00f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LSL{S}<c>.W <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Lsl);
    rInsn.SetMnemonic("lsl");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SXTB16<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
bool ArmArchitecture::Instruction_SXTB16_T1_fffff0c0_fa2ff080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SXTB16<c> <Rd>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sxtb16);
    rInsn.SetMnemonic("sxtb16");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SXTAB16<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
bool ArmArchitecture::Instruction_SXTAB16_T1_fff0f0c0_fa20f080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SXTAB16<c> <Rd>, <Rn>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sxtab16);
    rInsn.SetMnemonic("sxtab16");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UXTB16<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
bool ArmArchitecture::Instruction_UXTB16_T1_fffff0c0_fa3ff080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UXTB16<c> <Rd>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uxtb16);
    rInsn.SetMnemonic("uxtb16");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UXTAB16<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '1', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
bool ArmArchitecture::Instruction_UXTAB16_T1_fff0f0c0_fa30f080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UXTAB16<c> <Rd>, <Rn>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uxtab16);
    rInsn.SetMnemonic("uxtab16");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LSR{S}<c>.W <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '0', '1', 'S#1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_LSR_T2_ffe0f0f0_fa20f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LSR{S}<c>.W <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Lsr);
    rInsn.SetMnemonic("lsr");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SXTB<c>.W <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '1', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
bool ArmArchitecture::Instruction_SXTB_T2_fffff0c0_fa4ff080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SXTB<c>.W <Rd>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sxtb);
    rInsn.SetMnemonic("sxtb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SXTAB<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '1', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
bool ArmArchitecture::Instruction_SXTAB_T1_fff0f0c0_fa40f080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SXTAB<c> <Rd>, <Rn>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sxtab);
    rInsn.SetMnemonic("sxtab");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UXTB<c>.W <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
bool ArmArchitecture::Instruction_UXTB_T2_fffff0c0_fa5ff080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UXTB<c>.W <Rd>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uxtb);
    rInsn.SetMnemonic("uxtb");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UXTAB<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '1', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '(0)', 'rotate#2', 'Rm#4']
bool ArmArchitecture::Instruction_UXTAB_T1_fff0f0c0_fa50f080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UXTAB<c> <Rd>, <Rn>, <Rm>{,<rotation>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uxtab);
    rInsn.SetMnemonic("uxtab");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Rm>{,<rotation>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ASR{S}<c>.W <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '1', '0', 'S#1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_ASR_T2_ffe0f0f0_fa40f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ASR{S}<c>.W <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Asr);
    rInsn.SetMnemonic("asr");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// ROR{S}<c>.W <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '0', '1', '1', 'S#1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_ROR_T2_ffe0f0f0_fa60f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("ROR{S}<c>.W <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ror);
    rInsn.SetMnemonic("ror");
    if ((ExtractBit<20>(Opcode)) /* S */)
        rInsn.AddMnemonicSuffix("s");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_SADD8_T1_fff0f0f0_fa80f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SADD8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sadd8);
    rInsn.SetMnemonic("sadd8");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// QADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_QADD8_T1_fff0f0f0_fa80f010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("QADD8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Qadd8);
    rInsn.SetMnemonic("qadd8");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SHADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '1', '0', 'Rm#4']
bool ArmArchitecture::Instruction_SHADD8_T1_fff0f0f0_fa80f020(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SHADD8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Shadd8);
    rInsn.SetMnemonic("shadd8");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_UADD8_T1_fff0f0f0_fa80f040(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UADD8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uadd8);
    rInsn.SetMnemonic("uadd8");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UQADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UQADD8_T1_fff0f0f0_fa80f050(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UQADD8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uqadd8);
    rInsn.SetMnemonic("uqadd8");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UHADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '1', '0', 'Rm#4']
bool ArmArchitecture::Instruction_UHADD8_T1_fff0f0f0_fa80f060(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UHADD8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uhadd8);
    rInsn.SetMnemonic("uhadd8");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// QADD<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_QADD_T1_fff0f0f0_fa80f080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("QADD<c> <Rd>, <Rm>, <Rn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Qadd);
    rInsn.SetMnemonic("qadd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// QDADD<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_QDADD_T1_fff0f0f0_fa80f090(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("QDADD<c> <Rd>, <Rm>, <Rn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Qdadd);
    rInsn.SetMnemonic("qdadd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// QSUB<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '0', '1', '0', 'Rm#4']
bool ArmArchitecture::Instruction_QSUB_T1_fff0f0f0_fa80f0a0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("QSUB<c> <Rd>, <Rm>, <Rn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Qsub);
    rInsn.SetMnemonic("qsub");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// QDSUB<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '0', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_QDSUB_T1_fff0f0f0_fa80f0b0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("QDSUB<c> <Rd>, <Rm>, <Rn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Qdsub);
    rInsn.SetMnemonic("qdsub");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// REV<c>.W <Rd>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '1', 'RmDup#4', '1', '1', '1', '1', 'Rd#4', '1', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_REV_T2_fff0f0f0_fa90f080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("REV<c>.W <Rd>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Rev);
    rInsn.SetMnemonic("rev");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// REV16<c>.W <Rd>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '1', 'RmDup#4', '1', '1', '1', '1', 'Rd#4', '1', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_REV16_T2_fff0f0f0_fa90f090(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("REV16<c>.W <Rd>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Rev16);
    rInsn.SetMnemonic("rev16");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// RBIT<c> <Rd>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '1', 'RmDup#4', '1', '1', '1', '1', 'Rd#4', '1', '0', '1', '0', 'Rm#4']
bool ArmArchitecture::Instruction_RBIT_T1_fff0f0f0_fa90f0a0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("RBIT<c> <Rd>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Rbit);
    rInsn.SetMnemonic("rbit");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// REVSH<c>.W <Rd>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '1', 'RmDup#4', '1', '1', '1', '1', 'Rd#4', '1', '0', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_REVSH_T2_fff0f0f0_fa90f0b0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("REVSH<c>.W <Rd>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Revsh);
    rInsn.SetMnemonic("revsh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".w");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_SADD16_T1_fff0f0f0_fa90f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SADD16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sadd16);
    rInsn.SetMnemonic("sadd16");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// QADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_QADD16_T1_fff0f0f0_fa90f010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("QADD16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Qadd16);
    rInsn.SetMnemonic("qadd16");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SHADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '1', '0', 'Rm#4']
bool ArmArchitecture::Instruction_SHADD16_T1_fff0f0f0_fa90f020(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SHADD16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Shadd16);
    rInsn.SetMnemonic("shadd16");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UADD16<c> <Rd>, <Rn>, <Rm> - [] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_UADD16_T1_fff0f0f0_fa90f040(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UADD16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uadd16);
    rInsn.SetMnemonic("uadd16");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UQADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UQADD16_T1_fff0f0f0_fa90f050(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UQADD16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uqadd16);
    rInsn.SetMnemonic("uqadd16");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UHADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '1', '0', 'Rm#4']
bool ArmArchitecture::Instruction_UHADD16_T1_fff0f0f0_fa90f060(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UHADD16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uhadd16);
    rInsn.SetMnemonic("uhadd16");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_SASX_T1_fff0f0f0_faa0f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SASX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sasx);
    rInsn.SetMnemonic("sasx");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// QASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_QASX_T1_fff0f0f0_faa0f010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("QASX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Qasx);
    rInsn.SetMnemonic("qasx");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SHASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '1', '0', 'Rm#4']
bool ArmArchitecture::Instruction_SHASX_T1_fff0f0f0_faa0f020(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SHASX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Shasx);
    rInsn.SetMnemonic("shasx");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_UASX_T1_fff0f0f0_faa0f040(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UASX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uasx);
    rInsn.SetMnemonic("uasx");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UQASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UQASX_T1_fff0f0f0_faa0f050(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UQASX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uqasx);
    rInsn.SetMnemonic("uqasx");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UHASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '1', '0', 'Rm#4']
bool ArmArchitecture::Instruction_UHASX_T1_fff0f0f0_faa0f060(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UHASX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uhasx);
    rInsn.SetMnemonic("uhasx");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SEL<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '1', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_SEL_T1_fff0f0f0_faa0f080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SEL<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sel);
    rInsn.SetMnemonic("sel");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CLZ<c> <Rd>, <Rm> - [] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '1', 'RmDup#4', '1', '1', '1', '1', 'Rd#4', '1', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_CLZ_T1_fff0f0f0_fab0f080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CLZ<c> <Rd>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Clz);
    rInsn.SetMnemonic("clz");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_SSUB8_T1_fff0f0f0_fac0f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SSUB8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ssub8);
    rInsn.SetMnemonic("ssub8");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// QSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_QSUB8_T1_fff0f0f0_fac0f010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("QSUB8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Qsub8);
    rInsn.SetMnemonic("qsub8");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SHSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '1', '0', 'Rm#4']
bool ArmArchitecture::Instruction_SHSUB8_T1_fff0f0f0_fac0f020(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SHSUB8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Shsub8);
    rInsn.SetMnemonic("shsub8");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// USUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_USUB8_T1_fff0f0f0_fac0f040(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("USUB8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Usub8);
    rInsn.SetMnemonic("usub8");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UQSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UQSUB8_T1_fff0f0f0_fac0f050(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UQSUB8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uqsub8);
    rInsn.SetMnemonic("uqsub8");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UHSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '1', '0', 'Rm#4']
bool ArmArchitecture::Instruction_UHSUB8_T1_fff0f0f0_fac0f060(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UHSUB8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uhsub8);
    rInsn.SetMnemonic("uhsub8");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_SSUB16_T1_fff0f0f0_fad0f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SSUB16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ssub16);
    rInsn.SetMnemonic("ssub16");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// QSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_QSUB16_T1_fff0f0f0_fad0f010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("QSUB16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Qsub16);
    rInsn.SetMnemonic("qsub16");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SHSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '1', '0', 'Rm#4']
bool ArmArchitecture::Instruction_SHSUB16_T1_fff0f0f0_fad0f020(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SHSUB16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Shsub16);
    rInsn.SetMnemonic("shsub16");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// USUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_USUB16_T1_fff0f0f0_fad0f040(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("USUB16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Usub16);
    rInsn.SetMnemonic("usub16");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UQSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UQSUB16_T1_fff0f0f0_fad0f050(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UQSUB16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uqsub16);
    rInsn.SetMnemonic("uqsub16");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UHSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '1', '0', 'Rm#4']
bool ArmArchitecture::Instruction_UHSUB16_T1_fff0f0f0_fad0f060(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UHSUB16<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uhsub16);
    rInsn.SetMnemonic("uhsub16");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_SSAX_T1_fff0f0f0_fae0f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SSAX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ssax);
    rInsn.SetMnemonic("ssax");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// QSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_QSAX_T1_fff0f0f0_fae0f010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("QSAX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Qsax);
    rInsn.SetMnemonic("qsax");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SHSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '1', '0', 'Rm#4']
bool ArmArchitecture::Instruction_SHSAX_T1_fff0f0f0_fae0f020(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SHSAX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Shsax);
    rInsn.SetMnemonic("shsax");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// USAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_USAX_T1_fff0f0f0_fae0f040(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("USAX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Usax);
    rInsn.SetMnemonic("usax");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UQSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UQSAX_T1_fff0f0f0_fae0f050(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UQSAX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uqsax);
    rInsn.SetMnemonic("uqsax");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UHSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '1', '1', '0', 'Rm#4']
bool ArmArchitecture::Instruction_UHSAX_T1_fff0f0f0_fae0f060(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UHSAX<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Uhsax);
    rInsn.SetMnemonic("uhsax");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MUL<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '0', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_MUL_T2_fff0f0f0_fb00f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MUL<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mul);
    rInsn.SetMnemonic("mul");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MLA<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '0', '0', '0', 'Rn#4', 'Ra#4', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_MLA_T1_fff000f0_fb000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MLA<c> <Rd>, <Rn>, <Rm>, <Ra>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mla);
    rInsn.SetMnemonic("mla");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Ra */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MLS<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '0', '0', '0', 'Rn#4', 'Ra#4', 'Rd#4', '0', '0', '0', '1', 'Rm#4']
bool ArmArchitecture::Instruction_MLS_T1_fff000f0_fb000010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MLS<c> <Rd>, <Rn>, <Rm>, <Ra>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mls);
    rInsn.SetMnemonic("ml");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Ra */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMUL<x><y><c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '0', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', 'N#1', 'M#1', 'Rm#4']
bool ArmArchitecture::Instruction_SMUL_T1_fff0f0c0_fb10f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMUL<x><y><c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smul);
    rInsn.SetMnemonic("smul");
    if ((ExtractBit<5>(Opcode)) /* N */)
      rInsn.AddMnemonicSuffix("t");

    else
      rInsn.AddMnemonicSuffix("b");

    if ((ExtractBit<4>(Opcode)) /* M */)
      rInsn.AddMnemonicSuffix("t");

    else
      rInsn.AddMnemonicSuffix("b");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMLA<x><y><c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '0', '0', '1', 'Rn#4', 'Ra#4', 'Rd#4', '0', '0', 'N#1', 'M#1', 'Rm#4']
bool ArmArchitecture::Instruction_SMLA_T1_fff000c0_fb100000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMLA<x><y><c> <Rd>, <Rn>, <Rm>, <Ra>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smla);
    rInsn.SetMnemonic("smla");
    if ((ExtractBit<5>(Opcode)) /* N */)
      rInsn.AddMnemonicSuffix("t");

    else
      rInsn.AddMnemonicSuffix("b");

    if ((ExtractBit<4>(Opcode)) /* M */)
      rInsn.AddMnemonicSuffix("t");

    else
      rInsn.AddMnemonicSuffix("b");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Ra */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMUAD{X}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '0', '1', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', 'M#1', 'Rm#4']
bool ArmArchitecture::Instruction_SMUAD_T1_fff0f0e0_fb20f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMUAD{X}<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smuad);
    rInsn.SetMnemonic("smuad");
    if ((ExtractBit<4>(Opcode)) /* M */)
        rInsn.AddMnemonicSuffix("X");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMLAD{X}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '0', '1', '0', 'Rn#4', 'Ra#4', 'Rd#4', '0', '0', '0', 'M#1', 'Rm#4']
bool ArmArchitecture::Instruction_SMLAD_T1_fff000e0_fb200000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMLAD{X}<c> <Rd>, <Rn>, <Rm>, <Ra>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smlad);
    rInsn.SetMnemonic("smlad");
    if ((ExtractBit<4>(Opcode)) /* M */)
        rInsn.AddMnemonicSuffix("X");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Ra */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMULW<y><c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '0', '1', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', 'M#1', 'Rm#4']
bool ArmArchitecture::Instruction_SMULW_T1_fff0f0e0_fb30f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMULW<y><c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smulw);
    rInsn.SetMnemonic("smulw");
    if ((ExtractBit<4>(Opcode)) /* M */)
      rInsn.AddMnemonicSuffix("t");

    else
      rInsn.AddMnemonicSuffix("b");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMLAW<y><c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '0', '1', '1', 'Rn#4', 'Ra#4', 'Rd#4', '0', '0', '0', 'M#1', 'Rm#4']
bool ArmArchitecture::Instruction_SMLAW_T1_fff000e0_fb300000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMLAW<y><c> <Rd>, <Rn>, <Rm>, <Ra>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smlaw);
    rInsn.SetMnemonic("smlaw");
    if ((ExtractBit<4>(Opcode)) /* M */)
      rInsn.AddMnemonicSuffix("t");

    else
      rInsn.AddMnemonicSuffix("b");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Ra */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMUSD{X}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '0', '0', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', 'M#1', 'Rm#4']
bool ArmArchitecture::Instruction_SMUSD_T1_fff0f0e0_fb40f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMUSD{X}<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smusd);
    rInsn.SetMnemonic("smusd");
    if ((ExtractBit<4>(Opcode)) /* M */)
        rInsn.AddMnemonicSuffix("X");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMLSD{X}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '0', '0', 'Rn#4', 'Ra#4', 'Rd#4', '0', '0', '0', 'M#1', 'Rm#4']
bool ArmArchitecture::Instruction_SMLSD_T1_fff000e0_fb400000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMLSD{X}<c> <Rd>, <Rn>, <Rm>, <Ra>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smlsd);
    rInsn.SetMnemonic("smlsd");
    if ((ExtractBit<4>(Opcode)) /* M */)
        rInsn.AddMnemonicSuffix("X");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Ra */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMMUL{R}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '0', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', 'R#1', 'Rm#4']
bool ArmArchitecture::Instruction_SMMUL_T1_fff0f0e0_fb50f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMMUL{R}<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smmul);
    rInsn.SetMnemonic("smmul");
    if ((ExtractBit<4>(Opcode)) /* R */)
        rInsn.AddMnemonicSuffix("R");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMMLA{R}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '0', '1', 'Rn#4', 'Ra#4', 'Rd#4', '0', '0', '0', 'R#1', 'Rm#4']
bool ArmArchitecture::Instruction_SMMLA_T1_fff000e0_fb500000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMMLA{R}<c> <Rd>, <Rn>, <Rm>, <Ra>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smmla);
    rInsn.SetMnemonic("smmla");
    if ((ExtractBit<4>(Opcode)) /* R */)
        rInsn.AddMnemonicSuffix("R");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Ra */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMMLS{R}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '1', '0', 'Rn#4', 'Ra#4', 'Rd#4', '0', '0', '0', 'R#1', 'Rm#4']
bool ArmArchitecture::Instruction_SMMLS_T1_fff000e0_fb600000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMMLS{R}<c> <Rd>, <Rn>, <Rm>, <Ra>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smmls);
    rInsn.SetMnemonic("smml");
    rInsn.AddMnemonicSuffix("s");
    if ((ExtractBit<4>(Opcode)) /* R */)
        rInsn.AddMnemonicSuffix("R");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Ra */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// USAD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '1', '1', 'Rn#4', '1', '1', '1', '1', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_USAD8_T1_fff0f0f0_fb70f000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("USAD8<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Usad8);
    rInsn.SetMnemonic("usad8");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// USADA8<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '1', '1', 'Rn#4', 'Ra#4', 'Rd#4', '0', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_USADA8_T1_fff000f0_fb700000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("USADA8<c> <Rd>, <Rn>, <Rm>, <Ra>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Usada8);
    rInsn.SetMnemonic("usada8");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Ra */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMULL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '0', '0', 'Rn#4', 'RdLo#4', 'RdHi#4', '0', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_SMULL_T1_fff000f0_fb800000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMULL<c> <RdLo>, <RdHi>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smull);
    rInsn.SetMnemonic("smull");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <RdLo>";
    // FIXME: not_implemented: "operand <RdHi>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SDIV<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '0', '1', 'Rn#4', '(1)', '(1)', '(1)', '(1)', 'Rd#4', '1', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_SDIV_T1_fff0f0f0_fb90f0f0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SDIV<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Sdiv);
    rInsn.SetMnemonic("sdiv");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UMULL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1', '0', 'Rn#4', 'RdLo#4', 'RdHi#4', '0', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_UMULL_T1_fff000f0_fba00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UMULL<c> <RdLo>, <RdHi>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Umull);
    rInsn.SetMnemonic("umull");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <RdLo>";
    // FIXME: not_implemented: "operand <RdHi>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UDIV<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1', '1', 'Rn#4', '(1)', '(1)', '(1)', '(1)', 'Rd#4', '1', '1', '1', '1', 'Rm#4']
bool ArmArchitecture::Instruction_UDIV_T1_fff0f0f0_fbb0f0f0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UDIV<c> <Rd>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Udiv);
    rInsn.SetMnemonic("udiv");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<8, 11>(Opcode)) /* Rd */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMLAL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '0', 'Rn#4', 'RdLo#4', 'RdHi#4', '0', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_SMLAL_T1_fff000f0_fbc00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMLAL<c> <RdLo>, <RdHi>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smlal);
    rInsn.SetMnemonic("smlal");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <RdLo>";
    // FIXME: not_implemented: "operand <RdHi>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMLAL<x><y><c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '0', 'Rn#4', 'RdLo#4', 'RdHi#4', '1', '0', 'N#1', 'M#1', 'Rm#4']
bool ArmArchitecture::Instruction_SMLAL_T1_fff000c0_fbc00080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMLAL<x><y><c> <RdLo>, <RdHi>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smlal);
    rInsn.SetMnemonic("smlal");
    if ((ExtractBit<5>(Opcode)) /* N */)
      rInsn.AddMnemonicSuffix("t");

    else
      rInsn.AddMnemonicSuffix("b");

    if ((ExtractBit<4>(Opcode)) /* M */)
      rInsn.AddMnemonicSuffix("t");

    else
      rInsn.AddMnemonicSuffix("b");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <RdLo>";
    // FIXME: not_implemented: "operand <RdHi>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMLALD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '0', 'Rn#4', 'RdLo#4', 'RdHi#4', '1', '1', '0', 'M#1', 'Rm#4']
bool ArmArchitecture::Instruction_SMLALD_T1_fff000e0_fbc000c0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMLALD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smlald);
    rInsn.SetMnemonic("smlald");
    if ((ExtractBit<4>(Opcode)) /* M */)
        rInsn.AddMnemonicSuffix("X");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <RdLo>";
    // FIXME: not_implemented: "operand <RdHi>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// SMLSLD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '1', 'Rn#4', 'RdLo#4', 'RdHi#4', '1', '1', '0', 'M#1', 'Rm#4']
bool ArmArchitecture::Instruction_SMLSLD_T1_fff000e0_fbd000c0(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("SMLSLD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Smlsld);
    rInsn.SetMnemonic("smlsld");
    if ((ExtractBit<4>(Opcode)) /* M */)
        rInsn.AddMnemonicSuffix("X");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <RdLo>";
    // FIXME: not_implemented: "operand <RdHi>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UMLAL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '0', 'Rn#4', 'RdLo#4', 'RdHi#4', '0', '0', '0', '0', 'Rm#4']
bool ArmArchitecture::Instruction_UMLAL_T1_fff000f0_fbe00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UMLAL<c> <RdLo>, <RdHi>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Umlal);
    rInsn.SetMnemonic("umlal");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <RdLo>";
    // FIXME: not_implemented: "operand <RdHi>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// UMAAL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '0', 'Rn#4', 'RdLo#4', 'RdHi#4', '0', '1', '1', '0', 'Rm#4']
bool ArmArchitecture::Instruction_UMAAL_T1_fff000f0_fbe00060(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("UMAAL<c> <RdLo>, <RdHi>, <Rn>, <Rm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Umaal);
    rInsn.SetMnemonic("umaal");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <RdLo>";
    // FIXME: not_implemented: "operand <RdHi>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<0, 3>(Opcode)) /* Rm */), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MCRR2<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm> - ['support it block', 'could_jmp'] - ['1', '1', '1', '1', '1', '1', '0', '0', '0', '1', '0', '0', 'Rt2#4', 'Rt#4', 'coproc#4', 'opc1#4', 'CRm#4']
bool ArmArchitecture::Instruction_MCRR2_T2_fff00000_fc400000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MCRR2<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mcrr2);
    rInsn.SetMnemonic("mcrr2");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <opc1>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rt2 */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <CRm>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MRRC2<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm> - ['support it block', 'could_jmp'] - ['1', '1', '1', '1', '1', '1', '0', '0', '0', '1', '0', '1', 'Rt2#4', 'Rt#4', 'coproc#4', 'opc1#4', 'CRm#4']
bool ArmArchitecture::Instruction_MRRC2_T2_fff00000_fc500000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MRRC2<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mrrc2);
    rInsn.SetMnemonic("mrrc2");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <opc>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rt2 */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <CRm>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// STC2{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!} - ['support it block'] - ['1', '1', '1', '1', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '0', 'Rn#4', 'CRd#4', 'coproc#4', 'imm#8']
bool ArmArchitecture::Instruction_STC2_T2_fe100000_fc000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("STC2{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Stc2);
    rInsn.SetMnemonic("stc2");
    if ((ExtractBit<22>(Opcode)) /* D */)
        rInsn.AddMnemonicSuffix("L");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <CRd>";
    if ((ExtractBit<23>(Opcode)) /* U */)
      rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + (ExtractBits<0, 7>(Opcode)) << 2 | 0));

    else
      rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) - (ExtractBits<0, 7>(Opcode)) << 2 | 0));

  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDC2{L}<c> <coproc>, <CRd>, <label> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', '1', '1', '1', '1', 'CRd#4', 'coproc#4', 'imm#8']
bool ArmArchitecture::Instruction_LDC2_T2_fe1f0000_fc1f0000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDC2{L}<c> <coproc>, <CRd>, <label>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldc2);
    rInsn.SetMnemonic("ldc2");
    if ((ExtractBit<22>(Opcode)) /* D */)
        rInsn.AddMnemonicSuffix("L");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <CRd>";
    rInsn.AddOperand(Expr::MakeId(ARM_Reg_Pc, &m_CpuInfo) + (ExtractBits<0, 7>(Opcode)) /* imm */);
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// LDC2{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!} - ['support it block'] - ['1', '1', '1', '1', '1', '1', '0', 'P#1', 'U#1', 'D#1', 'W#1', '1', 'Rn#4', 'CRd#4', 'coproc#4', 'imm#8']
bool ArmArchitecture::Instruction_LDC2_T2_fe100000_fc100000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("LDC2{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Ldc2);
    rInsn.SetMnemonic("ldc2");
    if ((ExtractBit<22>(Opcode)) /* D */)
        rInsn.AddMnemonicSuffix("L");

    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    if ((ExtractBit<21>(Opcode)) /* W */)
        rInsn.AddAttribute(ARM_Attribute_WriteBack);

    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <CRd>";
    if ((ExtractBit<23>(Opcode)) /* U */)
      rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) + (ExtractBits<0, 7>(Opcode)) << 2 | 0));

    else
      rInsn.AddOperand(Expr::MakeMem(32, nullptr, Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<16, 19>(Opcode)) /* Rn */), &m_CpuInfo) - (ExtractBits<0, 7>(Opcode)) << 2 | 0));

  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MCR2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['support it block', 'could_jmp'] - ['1', '1', '1', '1', '1', '1', '1', '0', 'opc1#3', '0', 'CRn#4', 'Rt#4', 'coproc#4', 'opc2#3', '1', 'CRm#4']
bool ArmArchitecture::Instruction_MCR2_T2_ff100010_fe000010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MCR2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mcr2);
    rInsn.SetMnemonic("mcr2");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <opc1>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <CRn>";
    // FIXME: not_implemented: "operand <CRm>{,<opc2>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// MRC2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['support it block', 'could_jmp'] - ['1', '1', '1', '1', '1', '1', '1', '0', 'opc1#3', '1', 'CRn#4', 'Rt#4', 'coproc#4', 'opc2#3', '1', 'CRm#4']
bool ArmArchitecture::Instruction_MRC2_T2_ff100010_fe100010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("MRC2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>}");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Mrc2);
    rInsn.SetMnemonic("mrc2");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <opc1>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("GPR32", (ExtractBits<12, 15>(Opcode)) /* Rt */), &m_CpuInfo));
    // FIXME: not_implemented: "operand <CRn>";
    // FIXME: not_implemented: "operand <CRm>{,<opc2>}";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// CDP2<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '0', 'opc1#4', 'CRn#4', 'CRd#4', 'coproc#4', 'opc2#3', '0', 'CRm#4']
bool ArmArchitecture::Instruction_CDP2_T2_ff000010_fe000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("CDP2<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Cdp2);
    rInsn.SetMnemonic("cdp2");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    // FIXME: not_implemented: "operand <coproc>";
    // FIXME: not_implemented: "operand <opc1>";
    // FIXME: not_implemented: "operand <CRd>";
    // FIXME: not_implemented: "operand <CRn>";
    // FIXME: not_implemented: "operand <CRm>";
    // FIXME: not_implemented: "operand <opc2>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VEOR<c> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', '0', '0', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VEOR_T1_ffb00f10_ff000110(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VEOR<c> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Veor);
    rInsn.SetMnemonic("veor");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VPADD<c>.F32 - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VPADD_T1_ffa00f10_ff000d00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VPADD<c>.F32");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vpadd);
    rInsn.SetMnemonic("vpadd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMUL<c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VMUL_T1_ffa00f10_ff000d10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMUL<c>.F32 <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmul);
    rInsn.SetMnemonic("vmul");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCGE<c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', '0', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCGE_T2_ffa00f10_ff000e00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCGE<c>.F32 <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcge);
    rInsn.SetMnemonic("vcge");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VABD<c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', '1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VABD_T1_ffa00f10_ff200d00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VABD<c>.F32 <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vabd);
    rInsn.SetMnemonic("vabd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCGT<c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', '1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCGT_T2_ffa00f10_ff200e00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCGT<c>.F32 <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcgt);
    rInsn.SetMnemonic("vcgt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op><c>.F32 <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', 'op#1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_V_T1_ff800f10_ff000e10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op><c>.F32 <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VP<op><c>.F32 <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', 'op#1', 'sz#1', 'Vn#4', 'Vd#4', '1', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VP_T1_ff800f10_ff000f00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VP<op><c>.F32 <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vp);
    rInsn.SetMnemonic("vp");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op><c> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', 'op#2', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_V_T1_ff800f10_ff000110(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op><c> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSUB<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VSUB_T1_ff800f10_ff000800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSUB<c>.<dt> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vsub);
    rInsn.SetMnemonic("vsub");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCEQ<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VCEQ_T1_ff800f10_ff000810(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCEQ<c>.<dt> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vceq);
    rInsn.SetMnemonic("vceq");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQRDMULH<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQRDMULH_T1_ff800f10_ff000b00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQRDMULH<c>.<dt> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqrdmulh);
    rInsn.SetMnemonic("vqrdmulh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op><c>.8 <Dd>, <list>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'Vn#4', 'Vd#4', '1', '0', 'len#2', 'N#1', 'op#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_V_T1_ffb00c10_ffb00800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op><c>.8 <Dd>, <list>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".8");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <list>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VDUP<c>.<size> <Qd>, <Dm[x]> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'imm#4', 'Vd#4', '1', '1', '0', '0', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VDUP_T1_ffb00f90_ffb00c00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VDUP<c>.<size> <Qd>, <Dm[x]>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vdup);
    rInsn.SetMnemonic("vdup");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Dm[x]>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VREV<n><c>.<size> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '0', '0', 'op2#2', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VREV_T1_ffb30e10_ffb00000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VREV<n><c>.<size> <Qd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrev);
    rInsn.SetMnemonic("vrev");
    // FIXME: not_implemented: "field <n>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VPADDL<c>.<dt> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '0', '1', '0', 'op#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VPADDL_T1_ffb30f10_ffb00200(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VPADDL<c>.<dt> <Qd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vpaddl);
    rInsn.SetMnemonic("vpaddl");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCLS<c>.<dt> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '0', '0', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCLS_T1_ffb30f90_ffb00400(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCLS<c>.<dt> <Qd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcls);
    rInsn.SetMnemonic("vcl");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCLZ<c>.<dt> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '0', '0', '1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCLZ_T1_ffb30f90_ffb00480(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCLZ<c>.<dt> <Qd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vclz);
    rInsn.SetMnemonic("vclz");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCNT<c>.8 <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '0', '1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCNT_T1_ffb30f90_ffb00500(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCNT<c>.8 <Qd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcnt);
    rInsn.SetMnemonic("vcnt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".8");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMVN<c> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '0', '1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VMVN_T1_ffb30f90_ffb00580(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMVN<c> <Qd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmvn);
    rInsn.SetMnemonic("vmvn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VPADAL<c>.<dt> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '1', '0', 'op#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VPADAL_T1_ffb30f10_ffb00600(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VPADAL<c>.<dt> <Qd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vpadal);
    rInsn.SetMnemonic("vpadal");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQABS<c>.<dt> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '1', '1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQABS_T1_ffb30f90_ffb00700(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQABS<c>.<dt> <Qd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqabs);
    rInsn.SetMnemonic("vqab");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQNEG<c>.<dt> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '0', 'Vd#4', '0', '1', '1', '1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQNEG_T1_ffb30f90_ffb00780(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQNEG<c>.<dt> <Qd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqneg);
    rInsn.SetMnemonic("vqneg");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCGT<c>.<dt> <Qd>, <Qm>, #0 - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '0', '0', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCGT_T1_ffb30b90_ffb10000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCGT<c>.<dt> <Qd>, <Qm>, #0");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcgt);
    rInsn.SetMnemonic("vcgt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, 0x0));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCGE<c>.<dt> <Qd>, <Qm>, #0 - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '0', '0', '1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCGE_T1_ffb30b90_ffb10080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCGE<c>.<dt> <Qd>, <Qm>, #0");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcge);
    rInsn.SetMnemonic("vcge");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, 0x0));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCEQ<c>.<dt> <Qd>, <Qm>, #0 - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '0', '1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCEQ_T1_ffb30b90_ffb10100(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCEQ<c>.<dt> <Qd>, <Qm>, #0");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vceq);
    rInsn.SetMnemonic("vceq");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, 0x0));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCLE<c>.<dt> <Qd>, <Qm>, #0 - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '0', '1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCLE_T1_ffb30b90_ffb10180(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCLE<c>.<dt> <Qd>, <Qm>, #0");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcle);
    rInsn.SetMnemonic("vcle");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, 0x0));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCLT<c>.<dt> <Qd>, <Qm>, #0 - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '1', '0', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCLT_T1_ffb30b90_ffb10200(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCLT<c>.<dt> <Qd>, <Qm>, #0");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vclt);
    rInsn.SetMnemonic("vclt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, 0x0));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VABS<c>.<dt> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '1', '1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VABS_T1_ffb30b90_ffb10300(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VABS<c>.<dt> <Qd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vabs);
    rInsn.SetMnemonic("vab");
    rInsn.AddMnemonicSuffix("s");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VNEG<c>.<dt> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '0', '1', 'Vd#4', '0', 'F#1', '1', '1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VNEG_T1_ffb30b90_ffb10380(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VNEG<c>.<dt> <Qd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vneg);
    rInsn.SetMnemonic("vneg");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSWP<c> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '0', '0', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VSWP_T1_ffb30f90_ffb20000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSWP<c> <Qd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vswp);
    rInsn.SetMnemonic("vswp");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VTRN<c>.<size> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '0', '0', '1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VTRN_T1_ffb30f90_ffb20080(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VTRN<c>.<size> <Qd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vtrn);
    rInsn.SetMnemonic("vtrn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VUZP<c>.<size> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '0', '1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VUZP_T1_ffb30f90_ffb20100(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VUZP<c>.<size> <Qd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vuzp);
    rInsn.SetMnemonic("vuzp");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VZIP<c>.<size> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '0', '1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VZIP_T1_ffb30f90_ffb20180(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VZIP<c>.<size> <Qd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vzip);
    rInsn.SetMnemonic("vzip");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMOVN<c>.<dt> <Dd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '1', '0', '0', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VMOVN_T1_ffb30fd0_ffb20200(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMOVN<c>.<dt> <Dd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmovn);
    rInsn.SetMnemonic("vmovn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQMOV{op}N<c>.<type><size> <Dd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '1', '0', 'op2#2', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQMOV_T1_ffb30f10_ffb20200(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQMOV{op}N<c>.<type><size> <Dd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqmov);
    rInsn.SetMnemonic("vqmov");
    // FIXME: not_implemented: "field {op}";
    rInsn.AddMnemonicSuffix("N");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSHLL<c>.<type><size> <Qd>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '0', '1', '1', '0', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VSHLL_T2_ffb30fd0_ffb20300(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSHLL<c>.<type><size> <Qd>, <Dm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vshll);
    rInsn.SetMnemonic("vshll");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "field: <esize>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCVT<c>.F32.F16 <Qd>, <Dm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '0', 'Vd#4', '0', '1', '1', 'op#1', '0', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCVT_T1_ffb30ed0_ffb20600(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCVT<c>.F32.F16 <Qd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcvt);
    rInsn.SetMnemonic("vcvt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".F32");
    rInsn.AddMnemonicSuffix(".F16");
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRECPE<c>.<dt> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '1', 'Vd#4', '0', '1', '0', 'F#1', '0', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VRECPE_T1_ffb30e90_ffb30400(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRECPE<c>.<dt> <Qd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrecpe);
    rInsn.SetMnemonic("vrecpe");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRSQRTE<c>.<dt> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '1', 'Vd#4', '0', '1', '0', 'F#1', '1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VRSQRTE_T1_ffb30e90_ffb30480(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRSQRTE<c>.<dt> <Qd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrsqrte);
    rInsn.SetMnemonic("vrsqrte");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<18, 19>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCVT<c>.<Td>.<Tm> <Qd>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', '1', '1', 'size#2', '1', '1', 'Vd#4', '0', '1', '1', 'op#2', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCVT_T1_ffb30e10_ffb30600(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCVT<c>.<Td>.<Tm> <Qd>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcvt);
    rInsn.SetMnemonic("vcvt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<7, 8>(Opcode)) /* op */)
    {
    case 0x00000002:
        rInsn.AddMnemonicSuffix(".S32.F32");
      break;

    case 0x00000003:
        rInsn.AddMnemonicSuffix(".U32.F32");
      break;

    case 0x00000000:
        rInsn.AddMnemonicSuffix(".F32.S32");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix(".F32.U32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSRI<c>.<size> <Qd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '1', '0', '0', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VSRI_T1_ff800f10_ff800410(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSRI<c>.<size> <Qd>, <Qm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vsri);
    rInsn.SetMnemonic("vsri");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSLI<c>.<size> <Qd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '1', '0', '1', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VSLI_T1_ff800f10_ff800510(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSLI<c>.<size> <Qd>, <Qm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vsli);
    rInsn.SetMnemonic("vsli");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRADDHN<c>.<dt> <Dd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VRADDHN_T1_ff800f50_ff800400(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRADDHN<c>.<dt> <Dd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vraddhn);
    rInsn.SetMnemonic("vraddhn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRSUBHN<c>.<dt> <Dd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', '1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VRSUBHN_T1_ff800f50_ff800600(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRSUBHN<c>.<dt> <Dd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrsubhn);
    rInsn.SetMnemonic("vrsubhn");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op><c>.<dt> <Qd>, <Qn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', 'Q#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', 'op#1', '0', 'F#1', 'N#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_V_T1_ef800a50_ef800040(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op><c>.<dt> <Qd>, <Qn>, <Dm[x]>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Dm[x]>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMUL<c>.<dt> <Qd>, <Qn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', 'Q#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', 'F#1', 'N#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VMUL_T1_ef800e50_ef800840(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMUL<c>.<dt> <Qd>, <Qn>, <Dm[x]>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmul);
    rInsn.SetMnemonic("vmul");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Dm[x]>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQDMULH<c>.<dt> <Qd>, <Qn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', 'Q#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '1', '0', '0', 'N#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQDMULH_T2_ef800f50_ef800c40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQDMULH<c>.<dt> <Qd>, <Qn>, <Dm[x]>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqdmulh);
    rInsn.SetMnemonic("vqdmulh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Dm[x]>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQRDMULH<c>.<dt> <Qd>, <Qn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', 'Q#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '1', '0', '1', 'N#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VQRDMULH_T2_ef800f50_ef800d40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQRDMULH<c>.<dt> <Qd>, <Qn>, <Dm[x]>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqrdmulh);
    rInsn.SetMnemonic("vqrdmulh");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Dm[x]>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQADD<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '0', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VQADD_T1_ef800f10_ef000010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQADD<c>.<dt> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqadd);
    rInsn.SetMnemonic("vqadd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRHADD<c> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VRHADD_T1_ef800f10_ef000100(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRHADD<c> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrhadd);
    rInsn.SetMnemonic("vrhadd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQSUB<c>.<type><size> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '1', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VQSUB_T1_ef800f10_ef000210(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQSUB<c>.<type><size> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqsub);
    rInsn.SetMnemonic("vqsub");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCGT<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VCGT_T1_ef800f10_ef000300(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCGT<c>.<dt> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcgt);
    rInsn.SetMnemonic("vcgt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCGE<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '1', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VCGE_T1_ef800f10_ef000310(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCGE<c>.<dt> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcge);
    rInsn.SetMnemonic("vcge");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VH<op><c> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', 'op#1', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VH_T1_ef800d10_ef000000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VH<op><c> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vh);
    rInsn.SetMnemonic("vh");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSHL<c>.I<size> <Qd>, <Qm>, <Qn> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '0', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VSHL_T1_ef800f10_ef000400(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSHL<c>.I<size> <Qd>, <Qm>, <Qn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vshl);
    rInsn.SetMnemonic("vshl");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".I");
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQSHL<c>.<type><size> <Qd>, <Qm>, <Qn> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '0', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VQSHL_T1_ef800f10_ef000410(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQSHL<c>.<type><size> <Qd>, <Qm>, <Qn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqshl);
    rInsn.SetMnemonic("vqshl");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRSHL<c>.<type><size> <Qd>, <Qm>, <Qn> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VRSHL_T1_ef800f10_ef000500(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRSHL<c>.<type><size> <Qd>, <Qm>, <Qn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrshl);
    rInsn.SetMnemonic("vrshl");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQRSHL<c>.<type><size> <Qd>, <Qm>, <Qn> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VQRSHL_T1_ef800f10_ef000510(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQRSHL<c>.<type><size> <Qd>, <Qm>, <Qn>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqrshl);
    rInsn.SetMnemonic("vqrshl");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op><c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '0', 'N#1', 'Q#1', 'M#1', 'op#1', 'Vm#4']
bool ArmArchitecture::Instruction_V_T1_ef800f00_ef000600(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op><c>.<dt> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VABD<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VABD_T1_ef800f10_ef000700(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VABD<c>.<dt> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vabd);
    rInsn.SetMnemonic("vabd");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VABA<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VABA_T1_ef800f10_ef000710(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VABA<c>.<dt> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vaba);
    rInsn.SetMnemonic("vaba");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VP<op><c>.<dt> <Dd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '0', 'N#1', 'Q#1', 'M#1', 'op#1', 'Vm#4']
bool ArmArchitecture::Instruction_VP_T1_ef800f00_ef000a00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VP<op><c>.<dt> <Dd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vp);
    rInsn.SetMnemonic("vp");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMOVL<c>.<dt> <Qd>, <Dm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'imm#3', '0', '0', '0', 'Vd#4', '1', '0', '1', '0', '0', '0', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VMOVL_T1_ef870fd0_ef800a10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMOVL<c>.<dt> <Qd>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmovl);
    rInsn.SetMnemonic("vmovl");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field: <imm>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSHR<c>.<type><size> <Qd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '0', '0', '0', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VSHR_T1_ef800f10_ef800010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSHR<c>.<type><size> <Qd>, <Qm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vshr);
    rInsn.SetMnemonic("vshr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSRA<c>.<type><size> <Qd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '0', '0', '1', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VSRA_T1_ef800f10_ef800110(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSRA<c>.<type><size> <Qd>, <Qm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vsra);
    rInsn.SetMnemonic("vsra");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRSHR<c>.<type><size> <Qd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '0', '1', '0', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VRSHR_T1_ef800f10_ef800210(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRSHR<c>.<type><size> <Qd>, <Qm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrshr);
    rInsn.SetMnemonic("vrshr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VRSRA<c>.<type><size> <Qd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '0', '1', '1', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VRSRA_T1_ef800f10_ef800310(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VRSRA<c>.<type><size> <Qd>, <Qm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vrsra);
    rInsn.SetMnemonic("vrsra");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQSHL{op}<c>.<type><size> <Qd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '0', '1', '1', 'op#1', 'L#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VQSHL_T1_ef800e10_ef800610(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQSHL{op}<c>.<type><size> <Qd>, <Qm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqshl);
    rInsn.SetMnemonic("vqshl");
    // FIXME: not_implemented: "field {op}";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQSHR{op}N<c>.<type><size> <Dd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '1', '0', '0', 'op#1', '0', '0', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VQSHR_T1_ef800ed0_ef800810(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQSHR{op}N<c>.<type><size> <Dd>, <Qm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqshr);
    rInsn.SetMnemonic("vqshr");
    // FIXME: not_implemented: "field {op}";
    rInsn.AddMnemonicSuffix("N");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VQRSHR{op}N<c>.<type><size> <Dd>, <Qm>, #<imm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '1', '0', '0', 'op#1', '0', '1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VQRSHR_T1_ef800ed0_ef800850(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VQRSHR{op}N<c>.<type><size> <Dd>, <Qm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vqrshr);
    rInsn.SetMnemonic("vqrshr");
    // FIXME: not_implemented: "field {op}";
    rInsn.AddMnemonicSuffix("N");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSHLL<c>.<type><size> <Qd>, <Dm>, #<imm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '1', '0', '1', '0', '0', '0', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VSHLL_T1_ef800fd0_ef800a10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSHLL<c>.<type><size> <Qd>, <Dm>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vshll);
    rInsn.SetMnemonic("vshll");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field <type>";
    // FIXME: not_implemented: "field <size>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<16, 21>(Opcode)) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VCVT<c>.<Td>.<Tm> <Qd>, <Qm>, #<fbits> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'imm#6', 'Vd#4', '1', '1', '1', 'op#1', '0', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VCVT_T1_ef800e90_ef800e10(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VCVT<c>.<Td>.<Tm> <Qd>, <Qm>, #<fbits>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vcvt);
    rInsn.SetMnemonic("vcvt");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBit<8>(Opcode)) /* op */)
    {
    case 0x00000002:
        rInsn.AddMnemonicSuffix(".S32.F32");
      break;

    case 0x00000003:
        rInsn.AddMnemonicSuffix(".U32.F32");
      break;

    case 0x00000000:
        rInsn.AddMnemonicSuffix(".F32.S32");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix(".F32.U32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand #<fbits>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VADDL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '0', 'op#1', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VADDL_T1_ef800e50_ef800000(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VADDL<c>.<dt> <Qd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vaddl);
    rInsn.SetMnemonic("vaddl");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VSUBL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '0', '1', 'op#1', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VSUBL_T1_ef800e50_ef800200(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VSUBL<c>.<dt> <Qd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vsubl);
    rInsn.SetMnemonic("vsubl");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VABAL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '0', '1', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VABAL_T2_ef800f50_ef800500(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VABAL<c>.<dt> <Qd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vabal);
    rInsn.SetMnemonic("vabal");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VABDL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', '1', '1', '1', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VABDL_T2_ef800f50_ef800700(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VABDL<c>.<dt> <Qd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vabdl);
    rInsn.SetMnemonic("vabdl");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op>L<c>.<dt> <Qd>, <Dn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '0', 'op#1', '1', '0', 'N#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_V_T2_ef800b50_ef800240(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op>L<c>.<dt> <Qd>, <Dn>, <Dm[x]>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddMnemonicSuffix("L");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Dm[x]>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '1', '0', 'N#1', '1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VMULL_T2_ef800f50_ef800a40(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmull);
    rInsn.SetMnemonic("vmull");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    // FIXME: not_implemented: "operand <Dm[x]>";
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op>L<c>.<dt> <Qd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', 'op#1', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_V_T2_ef800d50_ef800800(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op>L<c>.<dt> <Qd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddMnemonicSuffix("L");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMULL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support it block'] - ['1', '1', '1', 'U#1', '1', '1', '1', '1', '1', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '1', 'op#1', '0', 'N#1', '0', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_VMULL_T2_ef800d50_ef800c00(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMULL<c>.<dt> <Qd>, <Dn>, <Dm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmull);
    rInsn.SetMnemonic("vmull");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR64", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VORR<c>.<dt> <Qd>, #<imm> - ['support it block'] - ['1', '1', '1', 'imm#1', '1', '1', '1', '1', '1', 'D#1', '0', '0', '0', 'imm#3', 'Vd#4', 'cmode#4', '0', 'Q#1', '0', '1', 'imm#4']
bool ArmArchitecture::Instruction_VORR_T1_efb800b0_ef800010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VORR<c>.<dt> <Qd>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vorr);
    rInsn.SetMnemonic("vorr");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field: <imm>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 3>(Opcode) | ExtractBits<16, 18>(Opcode) << 4 | ExtractBit<28>(Opcode) << 7) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VBIC<c>.<dt> <Qd>, #<imm> - ['support it block'] - ['1', '1', '1', 'imm#1', '1', '1', '1', '1', '1', 'D#1', '0', '0', '0', 'imm#3', 'Vd#4', 'cmode#4', '0', 'Q#1', '1', '1', 'imm#4']
bool ArmArchitecture::Instruction_VBIC_T1_efb800b0_ef800030(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VBIC<c>.<dt> <Qd>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vbic);
    rInsn.SetMnemonic("vbic");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field: <imm>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 3>(Opcode) | ExtractBits<16, 18>(Opcode) << 4 | ExtractBit<28>(Opcode) << 7) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMOV<c>.<dt> <Qd>, #<imm> - ['support it block'] - ['1', '1', '1', 'imm#1', '1', '1', '1', '1', '1', 'D#1', '0', '0', '0', 'imm#3', 'Vd#4', 'cmode#4', '0', 'Q#1', 'op#1', '1', 'imm#4']
bool ArmArchitecture::Instruction_VMOV_T1_efb80090_ef800010(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMOV<c>.<dt> <Qd>, #<imm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmov);
    rInsn.SetMnemonic("vmov");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    // FIXME: not_implemented: "field: <imm>";
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeBitVector(32, (ExtractBits<0, 3>(Opcode) | ExtractBits<16, 18>(Opcode) << 4 | ExtractBit<28>(Opcode) << 7) /* imm */));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// V<op><c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'op#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '0', 'Vm#4']
bool ArmArchitecture::Instruction_V_T1_ef800f10_ef000900(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("V<op><c>.<dt> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_V);
    rInsn.SetMnemonic("v");
    // FIXME: not_implemented: "field <op>";
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
// VMUL<c>.<dt> <Qd>, <Qn>, <Qm> - ['support it block'] - ['1', '1', '1', 'op#1', '1', '1', '1', '1', '0', 'D#1', 'size#2', 'Vn#4', 'Vd#4', '1', '0', '0', '1', 'N#1', 'Q#1', 'M#1', '1', 'Vm#4']
bool ArmArchitecture::Instruction_VMUL_T1_ef800f10_ef000910(BinaryStream const& rBinStrm, OffsetType Offset, u32 Opcode, Instruction& rInsn)
{
  {
    // decoder
    rInsn.SetFormat("VMUL<c>.<dt> <Qd>, <Qn>, <Qm>");
    rInsn.Size() = 4;
    rInsn.SetOpcode(ARM_Opcode_Vmul);
    rInsn.SetMnemonic("vmul");
    rInsn.AddAttribute(ARM_Attribute_SupportItBlock);
    rInsn.AddMnemonicSuffix(".");
    switch ((ExtractBits<20, 21>(Opcode)) /* size */)
    {
    case 0x00000000:
        rInsn.AddMnemonicSuffix("8");
      break;

    case 0x00000001:
        rInsn.AddMnemonicSuffix("16");
      break;

    case 0x00000002:
        rInsn.AddMnemonicSuffix("32");
      break;

    }
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<22>(Opcode)) << 4 | (ExtractBits<12, 15>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<7>(Opcode)) << 4 | (ExtractBits<16, 19>(Opcode))), &m_CpuInfo));
    rInsn.AddOperand(Expr::MakeId(arm::RegisterFromValue("SIMDR128", (ExtractBit<5>(Opcode)) << 4 | (ExtractBits<0, 3>(Opcode))), &m_CpuInfo));
  }
  {
    // semantic
    // FIXME: not_implemented: "";
  }
  return true;
}
