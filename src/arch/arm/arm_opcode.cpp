/* This file has been automatically generated, you must _NOT_ edit it directly. (Tue Dec  9 23:12:03 2014) */
#include "arm_architecture.hpp"
const char *ArmArchitecture::m_Mnemonic[0x29c] =
{
  "unknown",
  "abs",
  "adc",
  "adcs",
  "add",
  "addhn",
  "addhn2",
  "addp",
  "adds",
  "addv",
  "addw",
  "adr",
  "adrp",
  "aesd",
  "aese",
  "aesimc",
  "aesmc",
  "and",
  "ands",
  "asr",
  "asrs",
  "asrv",
  "b",
  "bfc",
  "bfi",
  "bfm",
  "bic",
  "bics",
  "bif",
  "bit",
  "bkpt",
  "bl",
  "blr",
  "blx",
  "br",
  "brk",
  "bsl",
  "bx",
  "bxj",
  "cb",
  "cbnz",
  "cbz",
  "ccmn",
  "ccmp",
  "cdp",
  "cdp2",
  "chka",
  "clrex",
  "cls",
  "clz",
  "cmeq",
  "cmge",
  "cmgt",
  "cmhi",
  "cmhs",
  "cmle",
  "cmlt",
  "cmn",
  "cmp",
  "cmtst",
  "cnt",
  "csel",
  "csinc",
  "csinv",
  "csneg",
  "dbg",
  "dcps1",
  "dcps2",
  "dcps3",
  "dmb",
  "drps",
  "dsb",
  "dup",
  "eon",
  "eor",
  "eors",
  "eret",
  "ext",
  "extr",
  "fabd",
  "fabs",
  "facge",
  "facgt",
  "fadd",
  "faddp",
  "fccmp",
  "fccmpe",
  "fcmeq",
  "fcmge",
  "fcmgt",
  "fcmle",
  "fcmlt",
  "fcmp",
  "fcmpe",
  "fcsel",
  "fcvt",
  "fcvtas",
  "fcvtau",
  "fcvtl",
  "fcvtl2",
  "fcvtms",
  "fcvtmu",
  "fcvtn",
  "fcvtn2",
  "fcvtns",
  "fcvtnu",
  "fcvtps",
  "fcvtpu",
  "fcvtxn",
  "fcvtxn2",
  "fcvtzs",
  "fcvtzu",
  "fdiv",
  "fldmx",
  "fmadd",
  "fmax",
  "fmaxnm",
  "fmaxnmp",
  "fmaxnmv",
  "fmaxp",
  "fmaxv",
  "fmin",
  "fminnm",
  "fminnmp",
  "fminnmv",
  "fminp",
  "fminv",
  "fmla",
  "fmls",
  "fmov",
  "fmsub",
  "fmul",
  "fmulx",
  "fneg",
  "fnmadd",
  "fnmsub",
  "fnmul",
  "frecpe",
  "frecps",
  "frecpx",
  "frinta",
  "frinti",
  "frintm",
  "frintn",
  "frintp",
  "frintx",
  "frintz",
  "frsqrte",
  "frsqrts",
  "fsqrt",
  "fstmx",
  "fsub",
  "hb",
  "hblp",
  "hbp",
  "hint",
  "hlt",
  "hvc",
  "ins",
  "isb",
  "it",
  "ld1",
  "ld2",
  "ld3",
  "ld4",
  "ldar",
  "ldarb",
  "ldarh",
  "ldaxp",
  "ldaxr",
  "ldaxrb",
  "ldaxrh",
  "ldc",
  "ldc2",
  "ldm",
  "ldmda",
  "ldmdb",
  "ldmib",
  "ldnp",
  "ldp",
  "ldpsw",
  "ldr",
  "ldrb",
  "ldrbt",
  "ldrd",
  "ldrex",
  "ldrexb",
  "ldrexd",
  "ldrexh",
  "ldrh",
  "ldrht",
  "ldrsb",
  "ldrsbt",
  "ldrsh",
  "ldrsht",
  "ldrsw",
  "ldrt",
  "ldtr",
  "ldtrb",
  "ldtrh",
  "ldtrsb",
  "ldtrsh",
  "ldtrsw",
  "ldur",
  "ldurb",
  "ldurh",
  "ldursb",
  "ldursh",
  "ldursw",
  "ldxp",
  "ldxr",
  "ldxrb",
  "ldxrh",
  "leavex",
  "lsl",
  "lsls",
  "lslv",
  "lsr",
  "lsrs",
  "lsrv",
  "madd",
  "mcr",
  "mcr2",
  "mcrr",
  "mcrr2",
  "mla",
  "mls",
  "mov",
  "movi",
  "movk",
  "movn",
  "movs",
  "movt",
  "movw",
  "movz",
  "mrc",
  "mrc2",
  "mrrc",
  "mrrc2",
  "mrs",
  "msr",
  "msub",
  "mul",
  "muls",
  "mvn",
  "mvni",
  "mvns",
  "neg",
  "nop",
  "not",
  "orn",
  "orr",
  "orrs",
  "pkhtb",
  "pld",
  "pli",
  "pmul",
  "pmull",
  "pmull2",
  "pop",
  "prfm",
  "prfum",
  "push",
  "qadd",
  "qadd16",
  "qadd8",
  "qasx",
  "qdadd",
  "qdsub",
  "qsax",
  "qsub",
  "qsub16",
  "qsub8",
  "raddhn",
  "raddhn2",
  "rbit",
  "ret",
  "rev",
  "rev16",
  "rev32",
  "rev64",
  "revsh",
  "ror",
  "rors",
  "rorv",
  "rrx",
  "rsb",
  "rsbs",
  "rsc",
  "rshrn",
  "rshrn2",
  "rsubhn",
  "rsubhn2",
  "saba",
  "sabal",
  "sabal2",
  "sabd",
  "sabdl",
  "sabdl2",
  "sadalp",
  "sadd16",
  "sadd8",
  "saddl",
  "saddl2",
  "saddlp",
  "saddlv",
  "saddw",
  "saddw2",
  "sasx",
  "sbc",
  "sbcs",
  "sbfm",
  "sbfx",
  "scvtf",
  "sdiv",
  "sel",
  "setend",
  "sev",
  "sha1c",
  "sha1h",
  "sha1m",
  "sha1p",
  "sha1su0",
  "sha1su1",
  "sha256h",
  "sha256h2",
  "sha256su0",
  "sha256su1",
  "shadd",
  "shadd16",
  "shadd8",
  "shasx",
  "shl",
  "shll",
  "shll2",
  "shsax",
  "shsub",
  "shsub16",
  "shsub8",
  "sli",
  "smaddl",
  "smax",
  "smaxp",
  "smaxv",
  "smc",
  "smin",
  "sminp",
  "sminv",
  "smla",
  "smlad",
  "smlal",
  "smlal2",
  "smlald",
  "smlaw",
  "smlsd",
  "smlsl",
  "smlsl2",
  "smlsld",
  "smmla",
  "smmls",
  "smmul",
  "smov",
  "smsubl",
  "smuad",
  "smul",
  "smulh",
  "smull",
  "smull2",
  "smulw",
  "smusd",
  "sqabs",
  "sqadd",
  "sqdmlal",
  "sqdmlal2",
  "sqdmlsl",
  "sqdmlsl2",
  "sqdmulh",
  "sqdmull",
  "sqdmull2",
  "sqneg",
  "sqrdmulh",
  "sqrshl",
  "sqrshrn",
  "sqrshrn2",
  "sqrshrun",
  "sqrshrun2",
  "sqshl",
  "sqshlu",
  "sqshrn",
  "sqshrun",
  "sqsub",
  "sqxtn",
  "sqxtn2",
  "sqxtun",
  "sqxtun2",
  "srhadd",
  "sri",
  "srshl",
  "srshr",
  "srsra",
  "ssat",
  "ssat16",
  "ssax",
  "sshl",
  "sshr",
  "ssra",
  "ssub16",
  "ssub8",
  "ssubl",
  "ssubl2",
  "ssubw",
  "ssubw2",
  "st1",
  "st2",
  "st3",
  "st4",
  "stc",
  "stc2",
  "stlr",
  "stlrb",
  "stlrh",
  "stlxp",
  "stlxr",
  "stlxrb",
  "stlxrh",
  "stm",
  "stmda",
  "stmdb",
  "stmib",
  "stnp",
  "stp",
  "str",
  "strb",
  "strbt",
  "strd",
  "strex",
  "strexb",
  "strexd",
  "strexh",
  "strh",
  "strht",
  "strt",
  "sttr",
  "sttrb",
  "sttrh",
  "stur",
  "sturb",
  "sturh",
  "stxp",
  "stxr",
  "stxrb",
  "stxrh",
  "sub",
  "subhn",
  "subhn2",
  "subs",
  "subw",
  "suqadd",
  "svc",
  "swp",
  "sxtab",
  "sxtab16",
  "sxtah",
  "sxtb",
  "sxtb16",
  "sxth",
  "sys",
  "sysl",
  "tbh",
  "tbl",
  "tbnz",
  "tbx",
  "tbz",
  "teq",
  "trn1",
  "trn2",
  "tst",
  "uaba",
  "uabal",
  "uabal2",
  "uabd",
  "uabdl",
  "uabdl2",
  "uadalp",
  "uadd16",
  "uadd8",
  "uaddl",
  "uaddl2",
  "uaddlp",
  "uaddlv",
  "uaddw",
  "uaddw2",
  "uasx",
  "ubfm",
  "ubfx",
  "ucvtf",
  "udiv",
  "uhadd",
  "uhadd16",
  "uhadd8",
  "uhasx",
  "uhsax",
  "uhsub",
  "uhsub16",
  "uhsub8",
  "umaal",
  "umaddl",
  "umax",
  "umaxp",
  "umaxv",
  "umin",
  "uminp",
  "uminv",
  "umlal",
  "umlal2",
  "umlsl",
  "umlsl2",
  "umov",
  "umsubl",
  "umulh",
  "umull",
  "umull2",
  "uqadd",
  "uqadd16",
  "uqadd8",
  "uqasx",
  "uqrshl",
  "uqrshrn",
  "uqrshrn2",
  "uqsax",
  "uqshl",
  "uqshrn",
  "uqsub",
  "uqsub16",
  "uqsub8",
  "uqxtn",
  "uqxtn2",
  "urecpe",
  "urhadd",
  "urshl",
  "urshr",
  "ursqrte",
  "ursra",
  "usad8",
  "usada8",
  "usat",
  "usat16",
  "usax",
  "ushl",
  "ushr",
  "usqadd",
  "usra",
  "usub16",
  "usub8",
  "usubl",
  "usubl2",
  "usubw",
  "usubw2",
  "uxtab",
  "uxtab16",
  "uxtah",
  "uxtb",
  "uxtb16",
  "uxth",
  "uzp1",
  "uzp2",
  "v",
  "vaba",
  "vabal",
  "vabd",
  "vabdl",
  "vabs",
  "vadd",
  "vaddhn",
  "vaddl",
  "vaddw",
  "vand",
  "vbic",
  "vceq",
  "vcge",
  "vcgt",
  "vcle",
  "vcls",
  "vclt",
  "vclz",
  "vcmp",
  "vcnt",
  "vcvt",
  "vdiv",
  "vdup",
  "veor",
  "vext",
  "vh",
  "vld1",
  "vldm",
  "vldr",
  "vmov",
  "vmovl",
  "vmovn",
  "vmrs",
  "vmsr",
  "vmul",
  "vmull",
  "vmvn",
  "vneg",
  "vnmla",
  "vnmls",
  "vnmul",
  "vorn",
  "vorr",
  "vp",
  "vpadal",
  "vpadd",
  "vpaddl",
  "vpop",
  "vpush",
  "vqabs",
  "vqadd",
  "vqd",
  "vqdmulh",
  "vqdmull",
  "vqmov",
  "vqneg",
  "vqrdmulh",
  "vqrshl",
  "vqrshr",
  "vqshl",
  "vqshr",
  "vqsub",
  "vraddhn",
  "vrecpe",
  "vrecps",
  "vrev",
  "vrhadd",
  "vrshl",
  "vrshr",
  "vrshrn",
  "vrsqrte",
  "vrsqrts",
  "vrsra",
  "vrsubhn",
  "vshl",
  "vshll",
  "vshr",
  "vshrn",
  "vsli",
  "vsqrt",
  "vsra",
  "vsri",
  "vst1",
  "vstm",
  "vstr",
  "vsub",
  "vsubhn",
  "vsubl",
  "vsubw",
  "vswp",
  "vtrn",
  "vtst",
  "vuzp",
  "vzip",
  "wfe",
  "wfi",
  "xtn",
  "xtn2",
  "yield",
  "zip1",
  "zip2"
};
bool ArmArchitecture::Disassemble(BinaryStream const& rBinStrm, TOffset Offset, Instruction& rInsn, u8 Mode)
{
  rInsn.GetData()->ArchitectureTag() = GetTag();
  rInsn.Mode() = Mode;

  switch (Mode)
  {
  case ARM_ModeArm:
    return DisassembleArm(rBinStrm, Offset, rInsn);
  case ARM_ModeThumb:
    return DisassembleThumb(rBinStrm, Offset, rInsn);
  default:
    return false;
  }
}
bool ArmArchitecture::DisassembleArm(BinaryStream const& rBinStrm, TOffset Offset, Instruction& rInsn)
{
  u32 Opcode32;
  if (!rBinStrm.Read(Offset, Opcode32))
    return false;

  if ((Opcode32 & 0xffffffff) == 0xf57ff01f)
    // CLREX - [] - [1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 0, 0, 1, '(1)', '(1)', '(1)', '(1)']
    return Instruction_CLREX_A1_ffffffff_f57ff01f(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xfffffdff) == 0xf1010000)
    // SETEND <endian_specifier> - [] - [1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, '(0)', '(0)', '(0)', 1, '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', 'E', '(0)', 0, 0, 0, 0, '(0)', '(0)', '(0)', '(0)']
    return Instruction_SETEND_A1_fffffdff_f1010000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfffffff0)
  {
  case 0xf57ff040:
    // DSB #<option> - [] - [1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 1, 0, 0, 'option', 'option', 'option', 'option']
    return Instruction_DSB_A1_fffffff0_f57ff040(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf57ff050:
    // DMB #<option> - [] - [1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 1, 0, 1, 'option', 'option', 'option', 'option']
    return Instruction_DMB_A1_fffffff0_f57ff050(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf57ff060:
    // ISB #<option> - [] - [1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 1, 1, 0, 'option', 'option', 'option', 'option']
    return Instruction_ISB_A1_fffffff0_f57ff060(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fffffff)
  {
  case 0x0320f000:
    // NOP<c> - [] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 0, 0, 0, 0, 0, 0, 0]
    return Instruction_NOP_A1_0fffffff_0320f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0320f001:
    // YIELD<c> - [] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 0, 0, 0, 0, 0, 0, 1]
    return Instruction_YIELD_A1_0fffffff_0320f001(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0320f002:
    // WFE<c> - [] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 0, 0, 0, 0, 0, 1, 0]
    return Instruction_WFE_A1_0fffffff_0320f002(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0320f003:
    // WFI<c> - [] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 0, 0, 0, 0, 0, 1, 1]
    return Instruction_WFI_A1_0fffffff_0320f003(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0320f004:
    // SEV<c> - [] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 0, 0, 0, 0, 1, 0, 0]
    return Instruction_SEV_A1_0fffffff_0320f004(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0ffffff0)
  {
  case 0x012fff10:
    // BX<c> Rm - ['call'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 1, 0, '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_BX_A1_0ffffff0_012fff10(rBinStrm, Offset, Opcode32, rInsn);
  case 0x012fff20:
    // BXJ<c> <Rm> - ['call'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 1, 0, '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 0, 'm', 'm', 'm', 'm']
    return Instruction_BXJ_A1_0ffffff0_012fff20(rBinStrm, Offset, Opcode32, rInsn);
  case 0x012fff30:
    // BLX<c> <Rm> - ['call'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 1, 0, '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_BLX_A1_0ffffff0_012fff30(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0320f0f0:
    // DBG<c> #<option> - [] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 1, 1, 1, 1, 'option', 'option', 'option', 'option']
    return Instruction_DBG_A1_0ffffff0_0320f0f0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fff0fff)
  {
  case 0x010f0000:
    // MRS<c> <Rd>, <spec_reg> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 0, 0, '(1)', '(1)', '(1)', '(1)', 'd', 'd', 'd', 'd', '(0)', '(0)', '(0)', '(0)', 0, 0, 0, 0, '(0)', '(0)', '(0)', '(0)']
    return Instruction_MRS_A1_0fff0fff_010f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x049d0004:
    // POP<c> <Rt> - ['could_ret'] - ['c', 'c', 'c', 'c', 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 't', 't', 't', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]
    return Instruction_POP_A2_0fff0fff_049d0004(rBinStrm, Offset, Opcode32, rInsn);
  case 0x052d0004:
    // PUSH<c> <Rt> - [] - ['c', 'c', 'c', 'c', 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 't', 't', 't', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]
    return Instruction_PUSH_A2_0fff0fff_052d0004(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0ee10a10:
    // VMSR<c> FPSCR, <Rt> - [] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 't', 't', 't', 't', 1, 0, 1, 0, 0, '(0)', '(0)', 1, '(0)', '(0)', '(0)', '(0)']
    return Instruction_VMSR_A1_0fff0fff_0ee10a10(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0ef10a10:
    // VMRS<c> <Rt>, FPSCR - [] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 't', 't', 't', 't', 1, 0, 1, 0, 0, '(0)', '(0)', 1, '(0)', '(0)', '(0)', '(0)']
    return Instruction_VMRS_A1_0fff0fff_0ef10a10(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0ff3fff0) == 0x0120f000)
    // MSR<c> <spec_reg>, <Rn> - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 1, 0, 'mask_4', 'mask_4', 0, 0, '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 0, 0, 0, 'n', 'n', 'n', 'n']
    return Instruction_MSR_A1_0ff3fff0_0120f000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0x0fbf0e7f) == 0x0eb50a40)
    // VCMP{E}<c>.F32 <Sd>, #0.0 - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 0, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'E', 1, '(0)', 0, '(0)', '(0)', '(0)', '(0)']
    return Instruction_VCMP_A2_0fbf0e7f_0eb50a40(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffb30fd0)
  {
  case 0xf3b20200:
    // VMOVN<c>.<dt> <Dd>, <Qm> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 0, 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VMOVN_A1_ffb30fd0_f3b20200(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b20300:
    // VSHLL<c>.<type_4><size> <Qd>, <Dm>, #<imm> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 1, 1, 0, 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VSHLL_A2_ffb30fd0_f3b20300(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fff0ff0)
  {
  case 0x016f0f10:
    // CLZ<c> <Rd>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 1, 1, 0, '(1)', '(1)', '(1)', '(1)', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_CLZ_A1_0fff0ff0_016f0f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06bf0f30:
    // REV<c> <Rd>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 1, 1, '(1)', '(1)', '(1)', '(1)', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_REV_A1_0fff0ff0_06bf0f30(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06bf0fb0:
    // REV16<c> <Rd>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 1, 1, '(1)', '(1)', '(1)', '(1)', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_REV16_A1_0fff0ff0_06bf0fb0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06ff0f30:
    // RBIT<c> <Rd>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 1, 1, 1, '(1)', '(1)', '(1)', '(1)', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_RBIT_A1_0fff0ff0_06ff0f30(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06ff0fb0:
    // REVSH<c> <Rd>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 1, 1, 1, '(1)', '(1)', '(1)', '(1)', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_REVSH_A1_0fff0ff0_06ff0fb0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0ff00fff)
  {
  case 0x01900f9f:
    // LDREX<c> <Rt>, [<Rn>] - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, '(1)', '(1)', '(1)', '(1)']
    return Instruction_LDREX_A1_0ff00fff_01900f9f(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01b00f9f:
    // LDREXD<c> <Rt>, <Rt2>, [<Rn>] - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, '(1)', '(1)', '(1)', '(1)']
    return Instruction_LDREXD_A1_0ff00fff_01b00f9f(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01d00f9f:
    // LDREXB<c> <Rt>, [<Rn>] - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, '(1)', '(1)', '(1)', '(1)']
    return Instruction_LDREXB_A1_0ff00fff_01d00f9f(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01f00f9f:
    // LDREXH<c> <Rt>, [<Rn>] - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 1, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, '(1)', '(1)', '(1)', '(1)']
    return Instruction_LDREXH_A1_0ff00fff_01f00f9f(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffb30ed0) == 0xf3b20600)
    // VCVT<c>.F16.F32 <Dd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 1, 1, 'op', 0, 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCVT_A1_ffb30ed0_f3b20600(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffb30f90)
  {
  case 0xf3b00400:
    // VCLS<c>.<dt> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 0, 0, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCLS_A1_ffb30f90_f3b00400(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b00480:
    // VCLZ<c>.<dt> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 0, 0, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCLZ_A1_ffb30f90_f3b00480(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b00500:
    // VCNT<c>.8 <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 0, 1, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCNT_A1_ffb30f90_f3b00500(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b00580:
    // VMVN<c> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 0, 1, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VMVN_A1_ffb30f90_f3b00580(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b00700:
    // VQABS<c>.<dt> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 1, 1, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQABS_A1_ffb30f90_f3b00700(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b00780:
    // VQNEG<c>.<dt> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 1, 1, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQNEG_A1_ffb30f90_f3b00780(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b20000:
    // VSWP<c> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VSWP_A1_ffb30f90_f3b20000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b20080:
    // VTRN<c>.<size> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VTRN_A1_ffb30f90_f3b20080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b20100:
    // VUZP<c>.<size> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 1, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VUZP_A1_ffb30f90_f3b20100(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b20180:
    // VZIP<c>.<size> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 1, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VZIP_A1_ffb30f90_f3b20180(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xff7ff000) == 0xf55ff000)
    // PLD [PC,#-0] - [] - [1, 1, 1, 1, 0, 1, 0, 1, 'U', '(1)', 0, 1, 1, 1, 1, 1, '(1)', '(1)', '(1)', '(1)', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_PLD_A1_ff7ff000_f55ff000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0fef0ff0)
  {
  case 0x01a00000:
    // MOV{S}<c> <Rd>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 0, 0, 0, 0, 0, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_MOV_A1_0fef0ff0_01a00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01a00060:
    // RRX{S}<c> <Rd>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 0, 0, 0, 0, 0, 1, 1, 0, 'm', 'm', 'm', 'm']
    return Instruction_RRX_A1_0fef0ff0_01a00060(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fff03f0)
  {
  case 0x068f0070:
    // SXTB16<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_SXTB16_A1_0fff03f0_068f0070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06af0070:
    // SXTB<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_SXTB_A1_0fff03f0_06af0070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06bf0070:
    // SXTH<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_SXTH_A1_0fff03f0_06bf0070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06cf0070:
    // UXTB16<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_UXTB16_A1_0fff03f0_06cf0070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06ef0070:
    // UXTB<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_UXTB_A1_0fff03f0_06ef0070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06ff0070:
    // UXTH<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_UXTH_A1_0fff03f0_06ff0070(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffb30f10)
  {
  case 0xf3b00200:
    // VPADDL<c>.<dt> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'op', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VPADDL_A1_ffb30f10_f3b00200(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b00600:
    // VPADAL<c>.<dt> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'op', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VPADAL_A1_ffb30f10_f3b00600(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b20200:
    // VQMOV{op}N<c>.<type><size> <Dd>, <Qm> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'op', 'op', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQMOV_A1_ffb30f10_f3b20200(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0fe00f7f) == 0x0e000a10)
    // VMOV<c> <Rt>, <Sn> - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 0, 0, 0, 'op', 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 0, 1, 0, 'N', '(0)', '(0)', 1, '(0)', '(0)', '(0)', '(0)']
    return Instruction_VMOV_A1_0fe00f7f_0e000a10(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffb30e90)
  {
  case 0xf3b30400:
    // VRECPE<c>.<dt> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 'F', 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VRECPE_A1_ffb30e90_f3b30400(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b30480:
    // VRSQRTE<c>.<dt> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 'F', 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VRSQRTE_A1_ffb30e90_f3b30480(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffb30b90)
  {
  case 0xf3b10000:
    // VCGT<c>.<dt> <Dd>, <Dm>, #0 - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 0, 0, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCGT_A1_ffb30b90_f3b10000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b10080:
    // VCGE<c>.<dt> <Dd>, <Dm>, #0 - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 0, 0, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCGE_A1_ffb30b90_f3b10080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b10100:
    // VCEQ<c>.<dt> <Dd>, <Dm>, #0 - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 0, 1, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCEQ_A1_ffb30b90_f3b10100(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b10180:
    // VCLE<c>.<dt> <Dd>, <Dm>, #0 - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 0, 1, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCLE_A1_ffb30b90_f3b10180(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b10200:
    // VCLT<c>.<dt> <Dd>, <Dm>, #0 - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 1, 0, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCLT_A1_ffb30b90_f3b10200(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b10300:
    // VABS<c>.<dt> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 1, 1, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VABS_A1_ffb30b90_f3b10300(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b10380:
    // VNEG<c>.<dt> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 1, 1, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VNEG_A1_ffb30b90_f3b10380(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfe870fd0) == 0xf2800a10)
    // VMOVL<c>.<dt> <Qd>, <Dm> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'i', 0, 0, 0, 'd', 'd', 'd', 'd', 1, 0, 1, 0, 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VMOVL_A1_fe870fd0_f2800a10(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffb30e10)
  {
  case 0xf3b00000:
    // VREV<n><c>.<size> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 'op', 'op', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VREV_A1_ffb30e10_f3b00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3b30600:
    // VCVT<c>.<Td>.<Tm> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 1, 'd', 'd', 'd', 'd', 0, 1, 1, 'op', 'op', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCVT_A1_ffb30e10_f3b30600(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffb00f90) == 0xf3b00c00)
    // VDUP<c>.<size> <Dd>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 1, 0, 0, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VDUP_A1_ffb00f90_f3b00c00(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0fbf0ed0)
  {
  case 0x0eb00a40:
    // VMOV<c>.F32 <Sd>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 0, 0, 0, 0, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 0, 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VMOV_A2_0fbf0ed0_0eb00a40(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0eb00ac0:
    // VABS<c>.F32 <Sd>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 0, 0, 0, 0, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 1, 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VABS_A2_0fbf0ed0_0eb00ac0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0eb10a40:
    // VNEG<c>.F32 <Sd>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 0, 0, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 0, 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VNEG_A2_0fbf0ed0_0eb10a40(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0eb10ac0:
    // VSQRT<c>.F32 <Sd>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 0, 0, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 1, 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VSQRT_A1_0fbf0ed0_0eb10ac0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0eb70ac0:
    // VCVT<c>.F32.F64 <Sd>, <Dm> - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 0, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 1, 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCVT_A1_0fbf0ed0_0eb70ac0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0ff00ff0)
  {
  case 0x01000050:
    // QADD<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(0)', '(0)', '(0)', '(0)', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_QADD_A1_0ff00ff0_01000050(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01200050:
    // QSUB<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(0)', '(0)', '(0)', '(0)', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_QSUB_A1_0ff00ff0_01200050(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01400050:
    // QDADD<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 1, 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(0)', '(0)', '(0)', '(0)', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_QDADD_A1_0ff00ff0_01400050(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01600050:
    // QDSUB<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 1, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(0)', '(0)', '(0)', '(0)', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_QDSUB_A1_0ff00ff0_01600050(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01800f90:
    // STREX<c> <Rd>, <Rt>, [<Rn>] - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, 't', 't', 't', 't']
    return Instruction_STREX_A1_0ff00ff0_01800f90(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01a00f90:
    // STREXD<c> <Rd>, <Rt>, <Rt2>, [<Rn>] - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, 't', 't', 't', 't']
    return Instruction_STREXD_A1_0ff00ff0_01a00f90(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01c00f90:
    // STREXB<c> <Rd>, <Rt>, [<Rn>] - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, 't', 't', 't', 't']
    return Instruction_STREXB_A1_0ff00ff0_01c00f90(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01e00f90:
    // STREXH<c> <Rd>, <Rt>, [<Rn>] - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 1, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, 't', 't', 't', 't']
    return Instruction_STREXH_A1_0ff00ff0_01e00f90(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06100f10:
    // SADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_SADD16_A1_0ff00ff0_06100f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06100f30:
    // SASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_SASX_A1_0ff00ff0_06100f30(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06100f50:
    // SSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_SSAX_A1_0ff00ff0_06100f50(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06100f70:
    // SSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_SSUB16_A1_0ff00ff0_06100f70(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06100f90:
    // SADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_SADD8_A1_0ff00ff0_06100f90(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06100ff0:
    // SSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_SSUB8_A1_0ff00ff0_06100ff0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06200f10:
    // QADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_QADD16_A1_0ff00ff0_06200f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06200f30:
    // QASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_QASX_A1_0ff00ff0_06200f30(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06200f50:
    // QSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_QSAX_A1_0ff00ff0_06200f50(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06200f70:
    // QSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_QSUB16_A1_0ff00ff0_06200f70(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06200f90:
    // QADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_QADD8_A1_0ff00ff0_06200f90(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06200ff0:
    // QSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_QSUB8_A1_0ff00ff0_06200ff0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06300f10:
    // SHADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_SHADD16_A1_0ff00ff0_06300f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06300f30:
    // SHASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_SHASX_A1_0ff00ff0_06300f30(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06300f50:
    // SHSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_SHSAX_A1_0ff00ff0_06300f50(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06300f70:
    // SHSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_SHSUB16_A1_0ff00ff0_06300f70(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06300f90:
    // SHADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_SHADD8_A1_0ff00ff0_06300f90(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06300ff0:
    // SHSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_SHSUB8_A1_0ff00ff0_06300ff0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06500f10:
    // UADD16<c> <Rd>, <Rn>, <Rm> - [] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_UADD16_A1_0ff00ff0_06500f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06500f30:
    // UASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_UASX_A1_0ff00ff0_06500f30(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06500f50:
    // USAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_USAX_A1_0ff00ff0_06500f50(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06500f70:
    // USUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_USUB16_A1_0ff00ff0_06500f70(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06500f90:
    // UADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_UADD8_A1_0ff00ff0_06500f90(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06500ff0:
    // USUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_USUB8_A1_0ff00ff0_06500ff0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06600f10:
    // UQADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_UQADD16_A1_0ff00ff0_06600f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06600f30:
    // UQASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_UQASX_A1_0ff00ff0_06600f30(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06600f50:
    // UQSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_UQSAX_A1_0ff00ff0_06600f50(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06600f70:
    // UQSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_UQSUB16_A1_0ff00ff0_06600f70(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06600f90:
    // UQADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_UQADD8_A1_0ff00ff0_06600f90(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06600ff0:
    // UQSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_UQSUB8_A1_0ff00ff0_06600ff0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06700f10:
    // UHADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_UHADD16_A1_0ff00ff0_06700f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06700f30:
    // UHASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_UHASX_A1_0ff00ff0_06700f30(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06700f50:
    // UHSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_UHSAX_A1_0ff00ff0_06700f50(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06700f70:
    // UHSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_UHSUB16_A1_0ff00ff0_06700f70(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06700f90:
    // UHADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_UHADD8_A1_0ff00ff0_06700f90(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06700ff0:
    // UHSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_UHSUB8_A1_0ff00ff0_06700ff0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06800fb0:
    // SEL<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_SEL_A1_0ff00ff0_06800fb0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06a00f30:
    // SSAT16<c> <Rd>, #<imm>, <Rn> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'n', 'n', 'n', 'n']
    return Instruction_SSAT16_A1_0ff00ff0_06a00f30(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06e00f30:
    // USAT16<c> <Rd>, #<imm4>, <Rn> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'n', 'n', 'n', 'n']
    return Instruction_USAT16_A1_0ff00ff0_06e00f30(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0ff0f0f0) == 0x0780f010)
    // USAD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 1, 0, 0, 0, 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'm', 'm', 'm', 'm', 0, 0, 0, 1, 'n', 'n', 'n', 'n']
    return Instruction_USAD8_A1_0ff0f0f0_0780f010(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffb00f10)
  {
  case 0xf2000110:
    // VAND<c> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VAND_A1_ffb00f10_f2000110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2100110:
    // VBIC<c> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VBIC_A1_ffb00f10_f2100110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2200110:
    // VORR<c> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VORR_A1_ffb00f10_f2200110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2300110:
    // VORN<c> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VORN_A1_ffb00f10_f2300110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3000110:
    // VEOR<c> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VEOR_A1_ffb00f10_f3000110(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xff800fd0)
  {
  case 0xf2800810:
    // VSHRN<c>.I<size> <Dd>, <Qm>, #<imm> - [] - [1, 1, 1, 1, 0, 0, 1, 0, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VSHRN_A1_ff800fd0_f2800810(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800850:
    // VRSHRN<c>.I<size> <Dd>, <Qm>, #<imm> - [] - [1, 1, 1, 1, 0, 0, 1, 0, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 0, 1, 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VRSHRN_A1_ff800fd0_f2800850(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0fbf0e50) == 0x0eb40a40)
    // VCMP{E}<c>.F32 <Sd>, <Sm> - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 0, 1, 0, 0, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'E', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCMP_A1_0fbf0e50_0eb40a40(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0x0f900f5f) == 0x0e800b10)
    // VDUP<c>.<size> - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'B', 'Q', 0, 'd', 'd', 'd', 'd', 't', 't', 't', 't', 1, 0, 1, 1, 'D', 0, 'E', 1, '(0)', '(0)', '(0)', '(0)']
    return Instruction_VDUP_A1_0f900f5f_0e800b10(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xff70f010) == 0xf650f000)
    // PLI [<Rn>,+/-<Rm>{,<shift>}] - [] - [1, 1, 1, 1, 0, 1, 1, 0, 'U', 1, 0, 1, 'n', 'n', 'n', 'n', '(1)', '(1)', '(1)', '(1)', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_PLI_A1_ff70f010_f650f000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0x0fbe0f50) == 0x0eb20a40)
    // VCVT<y><c>.F16.F32 <Sd>, <Sm> - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 0, 0, 1, 'op', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'T', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCVT_A1_0fbe0f50_0eb20a40(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xff30f010) == 0xf710f000)
    // PLD{R}<c> [<Rn>,+/-<Rm>{,<shift>}] - [] - [1, 1, 1, 1, 0, 1, 1, 1, 'U', 'R', 0, 1, 'n', 'n', 'n', 'n', '(1)', '(1)', '(1)', '(1)', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_PLD_A1_ff30f010_f710f000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0fef00f0)
  {
  case 0x01a00010:
    // LSL{S}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'm', 'm', 'm', 'm', 0, 0, 0, 1, 'n', 'n', 'n', 'n']
    return Instruction_LSL_A1_0fef00f0_01a00010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01a00030:
    // LSR{S}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'm', 'm', 'm', 'm', 0, 0, 1, 1, 'n', 'n', 'n', 'n']
    return Instruction_LSR_A1_0fef00f0_01a00030(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01a00050:
    // ASR{S}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'm', 'm', 'm', 'm', 0, 1, 0, 1, 'n', 'n', 'n', 'n']
    return Instruction_ASR_A1_0fef00f0_01a00050(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01a00070:
    // ROR{S}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'm', 'm', 'm', 'm', 0, 1, 1, 1, 'n', 'n', 'n', 'n']
    return Instruction_ROR_A1_0fef00f0_01a00070(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fbf0f00)
  {
  case 0x0cbd0a00:
    // FLDMX - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 0, 1, 'D', 1, 1, 1, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_FLDMX_A2_0fbf0f00_0cbd0a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0cbd0b00:
    // VPOP <list> - [] - ['c', 'c', 'c', 'c', 1, 1, 0, 0, 1, 'D', 1, 1, 1, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_VPOP_A1_0fbf0f00_0cbd0b00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0d2d0a00:
    // FSTMX - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 1, 0, 'D', 1, 0, 1, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_FSTMX_A2_0fbf0f00_0d2d0a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0d2d0b00:
    // VPUSH<c> <list> - [] - ['c', 'c', 'c', 'c', 1, 1, 0, 1, 0, 'D', 1, 0, 1, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_VPUSH_A1_0fbf0f00_0d2d0b00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfe800fd0) == 0xf2800a10)
    // VSHLL<c>.<type_4><size> <Qd>, <Dm>, #<imm> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VSHLL_A1_fe800fd0_f2800a10(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xffb00f00) == 0xf4a00c00)
    // VLD1<c>.<size> <list>, [<Rn>{@<align>}], <Rm> - ['support_it_block'] - [1, 1, 1, 1, 0, 1, 0, 0, 1, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 0, 'i', 'i', 'T', 'A', 'm', 'm', 'm', 'm']
    return Instruction_VLD1_A1_ffb00f00_f4a00c00(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0f7f00f0)
  {
  case 0x014f00d0:
    // LDRD<c> <Rt>, <Rt2>, [PC,#-0] - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, '(1)', 'U', 1, '(0)', 0, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 1, 0, 1, 'i', 'i', 'i', 'i']
    return Instruction_LDRD_A1_0f7f00f0_014f00d0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x015f00b0:
    // LDRH<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, '(1)', 'U', 1, '(0)', 1, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 0, 1, 1, 'i', 'i', 'i', 'i']
    return Instruction_LDRH_A1_0f7f00f0_015f00b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x015f00d0:
    // LDRSB<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, '(1)', 'U', 1, '(0)', 1, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 1, 0, 1, 'i', 'i', 'i', 'i']
    return Instruction_LDRSB_A1_0f7f00f0_015f00d0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x015f00f0:
    // LDRSH<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, '(1)', 'U', 1, '(0)', 1, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'i', 'i']
    return Instruction_LDRSH_A1_0f7f00f0_015f00f0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0fb00ff0) == 0x01000090)
    // SWP{B}<c> <Rt>, <Rt2>, [<Rn>] - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 'B', 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 0, 0, 1, 't2', 't2', 't2', 't2']
    return Instruction_SWP_A1_0fb00ff0_01000090(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffa00f10)
  {
  case 0xf2000d00:
    // VADD<c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VADD_A1_ffa00f10_f2000d00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000e00:
    // VCEQ<c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCEQ_A2_ffa00f10_f2000e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000f10:
    // VRECPS<c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VRECPS_A1_ffa00f10_f2000f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2200d00:
    // VSUB<c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 1, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VSUB_A1_ffa00f10_f2200d00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2200f10:
    // VRSQRTS<c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 1, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VRSQRTS_A1_ffa00f10_f2200f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3000d00:
    // VPADD<c>.F32 - [] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VPADD_A1_ffa00f10_f3000d00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3000d10:
    // VMUL<c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VMUL_A1_ffa00f10_f3000d10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3000e00:
    // VCGE<c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCGE_A2_ffa00f10_f3000e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3200d00:
    // VABD<c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 1, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VABD_A1_ffa00f10_f3200d00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3200e00:
    // VCGT<c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 1, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCGT_A2_ffa00f10_f3200e00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0f900f1f) == 0x0e000b10)
    // VMOV<c>.<size> <Dd[x]>, <Rt> - [] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 0, 'opc1', 'opc1', 0, 'd', 'd', 'd', 'd', 't', 't', 't', 't', 1, 0, 1, 1, 'D', 'opc2', 'opc2', 1, '(0)', '(0)', '(0)', '(0)']
    return Instruction_VMOV_A1_0f900f1f_0e000b10(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0f700ff0)
  {
  case 0x002000b0:
    // STRHT<c> <Rt>, [<Rn>], +/-<Rm> - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 'U', 0, 1, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 0, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_STRHT_A2_0f700ff0_002000b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x003000b0:
    // LDRHT<c> <Rt>, [<Rn>], +/-<Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 'U', 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 0, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_LDRHT_A2_0f700ff0_003000b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x003000d0:
    // LDRSBT<c> <Rt>, [<Rn>], +/-<Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 'U', 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 1, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_LDRSBT_A2_0f700ff0_003000d0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x003000f0:
    // LDRSHT<c> <Rt>, [<Rn>], +/-<Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 'U', 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_LDRSHT_A2_0f700ff0_003000f0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xff70f000) == 0xf450f000)
    // PLI [PC,#-0] - [] - [1, 1, 1, 1, 0, 1, 0, 0, 'U', 1, 0, 1, 'n', 'n', 'n', 'n', '(1)', '(1)', '(1)', '(1)', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_PLI_A1_ff70f000_f450f000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0x0fe0f0f0) == 0x00000090)
    // MUL{S}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 0, 0, 'S', 'd', 'd', 'd', 'd', '(0)', '(0)', '(0)', '(0)', 'm', 'm', 'm', 'm', 1, 0, 0, 1, 'n', 'n', 'n', 'n']
    return Instruction_MUL_A1_0fe0f0f0_00000090(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0ff0f0d0)
  {
  case 0x0700f010:
    // SMUAD{X}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 0, 0, 0, 0, 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'm', 'm', 'm', 'm', 0, 0, 'M', 1, 'n', 'n', 'n', 'n']
    return Instruction_SMUAD_A1_0ff0f0d0_0700f010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0700f050:
    // SMUSD{X}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 0, 0, 0, 0, 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'm', 'm', 'm', 'm', 0, 1, 'M', 1, 'n', 'n', 'n', 'n']
    return Instruction_SMUSD_A1_0ff0f0d0_0700f050(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0750f010:
    // SMMUL{R}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 0, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'm', 'm', 'm', 'm', 0, 0, 'R', 1, 'n', 'n', 'n', 'n']
    return Instruction_SMMUL_A1_0ff0f0d0_0750f010(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xff800f50)
  {
  case 0xf2800400:
    // VADDHN<c>.<dt> <Dd>, <Qn>, <Qm> - [] - [1, 1, 1, 1, 0, 0, 1, 0, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VADDHN_A1_ff800f50_f2800400(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800600:
    // VSUBHN<c>.<dt> <Dd>, <Qn>, <Qm> - [] - [1, 1, 1, 1, 0, 0, 1, 0, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VSUBHN_A1_ff800f50_f2800600(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800b40:
    // VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]> - [] - [1, 1, 1, 1, 0, 0, 1, 0, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQDMULL_A2_ff800f50_f2800b40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800d00:
    // VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm> - [] - [1, 1, 1, 1, 0, 0, 1, 0, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQDMULL_A1_ff800f50_f2800d00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3800400:
    // VRADDHN<c>.<dt> <Dd>, <Qn>, <Qm> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VRADDHN_A1_ff800f50_f3800400(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3800600:
    // VRSUBHN<c>.<dt> <Dd>, <Qn>, <Qm> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VRSUBHN_A1_ff800f50_f3800600(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0ff3f000) == 0x0320f000)
    // MSR<c> <spec_reg>, #<arm_expand_imm> - [] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 0, 1, 0, 'mask_4', 'mask_4', 0, 0, '(1)', '(1)', '(1)', '(1)', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_MSR_A1_0ff3f000_0320f000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0fe00fd0)
  {
  case 0x0c400a10:
    // VMOV<c> <Rt>, <Rt2>, <Sm>, <Sm1> - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 0, 0, 1, 0, 'op', 't2', 't2', 't2', 't2', 't', 't', 't', 't', 1, 0, 1, 0, 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VMOV_A1_0fe00fd0_0c400a10(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0c400b10:
    // VMOV<c> <Rt>, <Rt2>, <Dm> - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 0, 0, 1, 0, 'op', 't2', 't2', 't2', 't2', 't', 't', 't', 't', 1, 0, 1, 1, 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VMOV_A1_0fe00fd0_0c400b10(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfeb800b0)
  {
  case 0xf2800010:
    // VORR<c>.<dt> <Dd>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'i', 1, 'D', 0, 0, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'cmode', 'cmode', 'cmode', 'cmode', 0, 'Q', 0, 1, 'i', 'i', 'i', 'i']
    return Instruction_VORR_A1_feb800b0_f2800010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800030:
    // VBIC<c>.<dt> <Dd>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'i', 1, 'D', 0, 0, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'cmode', 'cmode', 'cmode', 'cmode', 0, 'Q', 1, 1, 'i', 'i', 'i', 'i']
    return Instruction_VBIC_A1_feb800b0_f2800030(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0ff003f0)
  {
  case 0x06800070:
    // SXTAB16<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_SXTAB16_A1_0ff003f0_06800070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06a00070:
    // SXTAB<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_SXTAB_A1_0ff003f0_06a00070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06b00070:
    // SXTAH<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_SXTAH_A1_0ff003f0_06b00070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06c00070:
    // UXTAB16<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_UXTAB16_A1_0ff003f0_06c00070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06e00070:
    // UXTAB<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 1, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_UXTAB_A1_0ff003f0_06e00070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06f00070:
    // UXTAH<c> <Rd>, <Rn>, <Rm>{,<rotation>} - [] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 1, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_UXTAH_A1_0ff003f0_06f00070(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xff800f10)
  {
  case 0xf2000800:
    // VADD<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VADD_A1_ff800f10_f2000800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000810:
    // VTST<c>.<size> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VTST_A1_ff800f10_f2000810(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000b00:
    // VQDMULH<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQDMULH_A1_ff800f10_f2000b00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000b10:
    // VPADD<c>.<dt> - [] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VPADD_A1_ff800f10_f2000b10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000d10:
    // V<op><c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 'op', 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_V_A1_ff800f10_f2000d10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000f00:
    // V<op><c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 'op', 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_V_A1_ff800f10_f2000f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800510:
    // VSHL<c>.I<size> <Dd>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VSHL_A1_ff800f10_f2800510(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3000800:
    // VSUB<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VSUB_A1_ff800f10_f3000800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3000810:
    // VCEQ<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VCEQ_A1_ff800f10_f3000810(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3000b00:
    // VQRDMULH<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQRDMULH_A1_ff800f10_f3000b00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3000110:
    // V<op><c> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 'op', 'op', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_V_A1_ff800f10_f3000110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3000e10:
    // V<op><c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 'op', 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_V_A1_ff800f10_f3000e10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3000f00:
    // VP<op><c>.F32 <Dd>, <Dn>, <Dm> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 'op', 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VP_A1_ff800f10_f3000f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3800410:
    // VSRI<c>.<size> <Dd>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VSRI_A1_ff800f10_f3800410(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3800510:
    // VSLI<c>.<size> <Dd>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VSLI_A1_ff800f10_f3800510(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffb00c10) == 0xf3b00800)
    // V<op><c>.8 <Dd>, <list>, <Dm> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 'len', 'len', 'N', 'op', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_V_A1_ffb00c10_f3b00800(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0fef0070)
  {
  case 0x01a00000:
    // LSL{S}<c> <Rd>, <Rm>, #<imm5> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_LSL_A1_0fef0070_01a00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01a00020:
    // LSR{S}<c> <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 0, 1, 0, 'm', 'm', 'm', 'm']
    return Instruction_LSR_A1_0fef0070_01a00020(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01a00040:
    // ASR{S}<c> <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 1, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_ASR_A1_0fef0070_01a00040(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01a00060:
    // ROR{S}<c> <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 1, 1, 0, 'm', 'm', 'm', 'm']
    return Instruction_ROR_A1_0fef0070_01a00060(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0fe0007f) == 0x07c0001f)
    // BFC<c> <Rd>, #<lsb>, #<width> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 1, 1, 0, 'msb', 'msb', 'msb', 'msb', 'msb', 'd', 'd', 'd', 'd', 'lsb', 'lsb', 'lsb', 'lsb', 'lsb', 0, 0, 1, 1, 1, 1, 1]
    return Instruction_BFC_A1_0fe0007f_07c0001f(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0x0fb00ef0) == 0x0eb00a00)
    // VMOV<c>.F32 <Sd>, #<imm> - ['support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', '(0)', 0, '(0)', 0, 'i', 'i', 'i', 'i']
    return Instruction_VMOV_A2_0fb00ef0_0eb00a00(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0x0f100f1f) == 0x0e100b10)
    // VMOV<c>.<dt> <Rt>, <Dn[x]> - [] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 'U', 'opc1', 'opc1', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 0, 1, 1, 'N', 'opc2', 'opc2', 1, '(0)', '(0)', '(0)', '(0)']
    return Instruction_VMOV_A1_0f100f1f_0e100b10(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfe800ed0)
  {
  case 0xf2800810:
    // VQSHR{op}N<c>.<type_4><size> <Dd>, <Qm>, #<imm> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 0, 'op', 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VQSHR_A1_fe800ed0_f2800810(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800850:
    // VQRSHR{op}N<c>.<type_4><size> <Dd>, <Qm>, #<imm> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 0, 'op', 0, 1, 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VQRSHR_A1_fe800ed0_f2800850(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xff800d50) == 0xf2800900)
    // VQD<op><c>.<dt> <Qd>, <Dn>, <Dm> - [] - [1, 1, 1, 1, 0, 0, 1, 0, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 'op', 1, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQD_A1_ff800d50_f2800900(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0ff0f090)
  {
  case 0x01100010:
    // TST<c> <Rn>, <Rm>, <type> <Rs> - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
    return Instruction_TST_A1_0ff0f090_01100010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01300010:
    // TEQ<c> <Rn>, <Rm>, <type> <Rs> - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 1, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
    return Instruction_TEQ_A1_0ff0f090_01300010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01500010:
    // CMP<c> <Rn>, <Rm>, <type> <Rs> - ['cond'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 1, 0, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
    return Instruction_CMP_A1_0ff0f090_01500010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01700010:
    // CMN<c> <Rn>, <Rm>, <type> <Rs> - ['cond'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 1, 1, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
    return Instruction_CMN_A1_0ff0f090_01700010(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfe800f50)
  {
  case 0xf2800c40:
    // VQDMULH<c>.<dt> <Dd>, <Dn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'Q', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 0, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQDMULH_A2_fe800f50_f2800c40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800d40:
    // VQRDMULH<c>.<dt> <Dd>, <Dn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'Q', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQRDMULH_A2_fe800f50_f2800d40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800500:
    // VABAL<c>.<dt> <Qd>, <Dn>, <Dm> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VABAL_A2_fe800f50_f2800500(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800700:
    // VABDL<c>.<dt> <Qd>, <Dn>, <Dm> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 1, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VABDL_A2_fe800f50_f2800700(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800a40:
    // VMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VMULL_A2_fe800f50_f2800a40(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xff30f000) == 0xf510f000)
    // PLD{R} [<Rn>, #<imm>] - [] - [1, 1, 1, 1, 0, 1, 0, 1, 'U', 'R', 0, 1, 'n', 'n', 'n', 'n', '(1)', '(1)', '(1)', '(1)', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_PLD_A1_ff30f000_f510f000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0x0fba0e50) == 0x0eba0a40)
    // VCVT<c>.F32.<Td> <Sd>, <Sd>, #<fbits> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 1, 'op', 1, 'U', 'd', 'd', 'd', 'd', 1, 0, 1, 'sf', 'sx', 1, 'i', 0, 'i', 'i', 'i', 'i']
    return Instruction_VCVT_A1_0fba0e50_0eba0a40(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xff800b50) == 0xf2800340)
    // VQD<op><c>.<dt> <Qd>, <Dn>, <Dm[x]> - [] - [1, 1, 1, 1, 0, 0, 1, 0, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 'op', 1, 1, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQD_A2_ff800b50_f2800340(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffb00300)
  {
  case 0xf4800000:
    // VST1<c>.<size> <list>, [<Rn>{@<align>}], <Rm> - ['support_it_block'] - [1, 1, 1, 1, 0, 1, 0, 0, 1, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 0, 0, 'index_align', 'index_align', 'index_align', 'index_align', 'm', 'm', 'm', 'm']
    return Instruction_VST1_A1_ffb00300_f4800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf4a00000:
    // VLD1<c>.<size> <list>, [<Rn>{@<align>}], <Rm> - ['support_it_block'] - [1, 1, 1, 1, 0, 1, 0, 0, 1, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 0, 0, 'index_align', 'index_align', 'index_align', 'index_align', 'm', 'm', 'm', 'm']
    return Instruction_VLD1_A1_ffb00300_f4a00000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0ff0f010)
  {
  case 0x01100000:
    // TST<c> <Rn>, <Rm>{,<shift>} - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_TST_A1_0ff0f010_01100000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01300000:
    // TEQ<c> <Rn>, <Rm>{,<shift>} - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 1, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_TEQ_A1_0ff0f010_01300000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01500000:
    // CMP<c> <Rn>, <Rm>{,<shift>} - ['cond'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 1, 0, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_CMP_A1_0ff0f010_01500000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01700000:
    // CMN<c> <Rn>, <Rm>{,<shift>} - ['cond'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 1, 1, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_CMN_A1_0ff0f010_01700000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfe800e90) == 0xf2800e10)
    // VCVT<c>.<Td>.<Tm> <Dd>, <Dm>, #<fbits> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 1, 1, 'op', 0, 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VCVT_A1_fe800e90_f2800e10(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0e500ff0)
  {
  case 0x000000b0:
    // STRH<c> <Rt>, [<Rn>],+/-<Rm> - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 0, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 0, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_STRH_A1_0e500ff0_000000b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x000000d0:
    // LDRD<c> <Rt>, <Rt2>, [<Rn>],+/-<Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 0, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 1, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_LDRD_A1_0e500ff0_000000d0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x000000f0:
    // STRD<c> <Rt>, <Rt2>, [<Rn>],+/-<Rm> - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 0, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_STRD_A1_0e500ff0_000000f0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x001000b0:
    // LDRH<c> <Rt>, [<Rn>],+/-<Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 0, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 0, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_LDRH_A1_0e500ff0_001000b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x001000d0:
    // LDRSB<c> <Rt>, [<Rn>],+/-<Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 0, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 1, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_LDRSB_A1_0e500ff0_001000d0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x001000f0:
    // LDRSH<c> <Rt>, [<Rn>],+/-<Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 0, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_LDRSH_A1_0e500ff0_001000f0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0fef0090) == 0x01e00010)
    // MVN{S}<c> <Rd>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 1, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
    return Instruction_MVN_A1_0fef0090_01e00010(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfe800d50)
  {
  case 0xf2800800:
    // V<op>L<c>.<dt> <Qd>, <Dn>, <Dm> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 'op', 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_V_A2_fe800d50_f2800800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800c00:
    // VMULL<c>.<dt> <Qd>, <Dn>, <Dm> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 'op', 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VMULL_A2_fe800d50_f2800c00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0fb80e50) == 0x0eb80a40)
    // VCVT<c>.F32.<Tm> <Sd>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 1, 'opc2', 'opc2', 'opc2', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'op', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCVT_A1_0fb80e50_0eb80a40(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xfe800b50) == 0xf2800240)
    // V<op>L<c>.<dt> <Qd>, <Dn>, <Dm[x]> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 'op', 1, 0, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_V_A2_fe800b50_f2800240(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfe800e50)
  {
  case 0xf2800840:
    // VMUL<c>.<dt> <Dd>, <Dn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'Q', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 'F', 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VMUL_A1_fe800e50_f2800840(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800000:
    // VADDW<c>.<dt> <Qd>, <Qn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 'op', 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VADDW_A1_fe800e50_f2800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800200:
    // VSUBW<c>.<dt> {<Qd>,} <Qn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 1, 'op', 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VSUBW_A1_fe800e50_f2800200(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfe800f10)
  {
  case 0xf2000010:
    // VQADD<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VQADD_A1_fe800f10_f2000010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000100:
    // VRHADD<c> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VRHADD_A1_fe800f10_f2000100(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000210:
    // VQSUB<c>.<type_4><size> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VQSUB_A1_fe800f10_f2000210(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000300:
    // VCGT<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCGT_A1_fe800f10_f2000300(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000310:
    // VCGE<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 1, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VCGE_A1_fe800f10_f2000310(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000400:
    // VSHL<c>.I<size> <Dd>, <Dm>, <Dn> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VSHL_A1_fe800f10_f2000400(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000410:
    // VQSHL<c>.<type_4><size> <Dd>, <Dm>, <Dn> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VQSHL_A1_fe800f10_f2000410(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000500:
    // VRSHL<c>.<type_4><size> <Dd>, <Dm>, <Dn> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VRSHL_A1_fe800f10_f2000500(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000510:
    // VQRSHL<c>.<type_4><size> <Dd>, <Dm>, <Dn> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VQRSHL_A1_fe800f10_f2000510(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000700:
    // VABD<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VABD_A1_fe800f10_f2000700(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000710:
    // VABA<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VABA_A1_fe800f10_f2000710(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800010:
    // VSHR<c>.<type_4><size> <Dd>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VSHR_A1_fe800f10_f2800010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800110:
    // VSRA<c>.<type_4><size> <Dd>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VSRA_A1_fe800f10_f2800110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800210:
    // VRSHR<c>.<type_4><size> <Dd>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VRSHR_A1_fe800f10_f2800210(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2800310:
    // VRSRA<c>.<type_4><size> <Dd>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 0, 1, 1, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VRSRA_A1_fe800f10_f2800310(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000900:
    // V<op><c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'op', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_V_A1_fe800f10_f2000900(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000910:
    // VMUL<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'op', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VMUL_A1_fe800f10_f2000910(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfeb80090) == 0xf2800010)
    // VMOV<c>.<dt> <Dd>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'i', 1, 'D', 0, 0, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'cmode', 'cmode', 'cmode', 'cmode', 0, 'Q', 'op', 1, 'i', 'i', 'i', 'i']
    return Instruction_VMOV_A1_feb80090_f2800010(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0fff0000)
  {
  case 0x024f0000:
    // SUB <Rd>, PC, #0 - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_SUB_A2_0fff0000_024f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x028f0000:
    // ADR<c> <Rd>, <arm_expand_label> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_ADR_A1_0fff0000_028f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x08bd0000:
    // POP<c> <registers> - ['could_ret'] - ['c', 'c', 'c', 'c', 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
    return Instruction_POP_A1_0fff0000_08bd0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x092d0000:
    // PUSH<c> <registers> - [] - ['c', 'c', 'c', 'c', 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
    return Instruction_PUSH_A1_0fff0000_092d0000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffb00010) == 0xf2b00000)
    // VEXT<c>.8 <Dd>, <Dn>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 1, 'D', 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VEXT_A1_ffb00010_f2b00000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0ff000f0)
  {
  case 0x00400090:
    // UMAAL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 1, 0, 0, 'dhi', 'dhi', 'dhi', 'dhi', 'dlo', 'dlo', 'dlo', 'dlo', 'm', 'm', 'm', 'm', 1, 0, 0, 1, 'n', 'n', 'n', 'n']
    return Instruction_UMAAL_A1_0ff000f0_00400090(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00600090:
    // MLS<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 1, 1, 0, 'd', 'd', 'd', 'd', 'a', 'a', 'a', 'a', 'm', 'm', 'm', 'm', 1, 0, 0, 1, 'n', 'n', 'n', 'n']
    return Instruction_MLS_A1_0ff000f0_00600090(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01200070:
    // BKPT #<imm> - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 0, 1, 1, 1, 'i', 'i', 'i', 'i']
    return Instruction_BKPT_A1_0ff000f0_01200070(rBinStrm, Offset, Opcode32, rInsn);
  case 0x07800010:
    // USADA8<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 1, 0, 0, 0, 'd', 'd', 'd', 'd', 'a', 'a', 'a', 'a', 'm', 'm', 'm', 'm', 0, 0, 0, 1, 'n', 'n', 'n', 'n']
    return Instruction_USADA8_A1_0ff000f0_07800010(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfe800d10) == 0xf2000000)
    // VH<op><c> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 'op', 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VH_A1_fe800d10_f2000000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xfe800a50) == 0xf2800040)
    // V<op><c>.<dt> <Dd>, <Dn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'Q', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 'op', 0, 'F', 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_V_A1_fe800a50_f2800040(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xfe800e10) == 0xf2800610)
    // VQSHL{op}<c>.<type_4><size> <Dd>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 1, 1, 'op', 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VQSHL_A1_fe800e10_f2800610(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfff00000)
  {
  case 0xfc400000:
    // MCRR2<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm> - ['could_jmp'] - [1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 't2', 't2', 't2', 't2', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc1', 'opc1', 'opc1', 'opc1', 'm', 'm', 'm', 'm']
    return Instruction_MCRR2_A2_fff00000_fc400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfc500000:
    // MRRC2<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm> - ['could_jmp'] - [1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 't2', 't2', 't2', 't2', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc1', 'opc1', 'opc1', 'opc1', 'm', 'm', 'm', 'm']
    return Instruction_MRRC2_A2_fff00000_fc500000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfe800f00)
  {
  case 0xf2000600:
    // V<op><c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'N', 'Q', 'M', 'op', 'm', 'm', 'm', 'm']
    return Instruction_V_A1_fe800f00_f2000600(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2000a00:
    // VP<op><c>.<dt> <Dd>, <Dn>, <Dm> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'N', 'Q', 'M', 'op', 'm', 'm', 'm', 'm']
    return Instruction_VP_A1_fe800f00_f2000a00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fef0010)
  {
  case 0x004d0000:
    // SUB{S}<c> <Rd>, SP, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 1, 0, 'S', 1, 1, 0, 1, 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_SUB_A1_0fef0010_004d0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x008d0000:
    // ADD{S}<c> <Rd>, SP, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 0, 0, 'S', 1, 1, 0, 1, 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_ADD_A1_0fef0010_008d0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01e00000:
    // MVN{S}<c> <Rd>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 1, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_MVN_A1_0fef0010_01e00000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fb00e50)
  {
  case 0x0e200a00:
    // VMUL<c>.F32 <Sd>, <Sn>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 0, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VMUL_A2_0fb00e50_0e200a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0e200a40:
    // VNMUL<c>.F32 <Sd>, <Sn>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 0, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VNMUL_A2_0fb00e50_0e200a40(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0e300a00:
    // VADD<c>.F32 <Sd>, <Sn>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 0, 'D', 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VADD_A2_0fb00e50_0e300a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0e300a40:
    // VSUB<c>.F32 <Sd>, <Sn>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 0, 'D', 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VSUB_A2_0fb00e50_0e300a40(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0e800a00:
    // VDIV<c>.F32 <Sd>, <Sn>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VDIV_A1_0fb00e50_0e800a00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfe1f0000) == 0xfc1f0000)
    // LDC2{L}<c> <coproc>, <CRd>, [PC],<option> - ['support_it_block', 'support_it_block'] - [1, 1, 1, 1, 1, 1, 0, 'P', 'U', 'D', 'W', 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDC2_A2_fe1f0000_fc1f0000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0ff0f000)
  {
  case 0x03100000:
    // TST<c> <Rn>, #<arm_expand_imm_c> - [] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_TST_A1_0ff0f000_03100000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x03300000:
    // TEQ<c> <Rn>, #<arm_expand_imm_c> - [] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 0, 1, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_TEQ_A1_0ff0f000_03300000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x03500000:
    // CMP<c> <Rn>, #<arm_expand_imm> - ['cond'] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 1, 0, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_CMP_A1_0ff0f000_03500000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x03700000:
    // CMN<c> <Rn>, #<arm_expand_imm> - ['cond'] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 1, 1, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_CMN_A1_0ff0f000_03700000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffb00000)
  {
  case 0xf4000000:
    // VST1<c>.<size> <list>, [<Rn>{@<align>}], <Rm> - ['support_it_block', 'support_it_block'] - [1, 1, 1, 1, 0, 1, 0, 0, 0, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'tp', 'tp', 'tp', 'tp', 'i', 'i', 'align', 'align', 'm', 'm', 'm', 'm']
    return Instruction_VST1_A1_ffb00000_f4000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf4200000:
    // VLD1<c>.<size> <list>, [<Rn>{@<align>}], <Rm> - ['support_it_block', 'support_it_block'] - [1, 1, 1, 1, 0, 1, 0, 0, 0, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'tp', 'tp', 'tp', 'tp', 'i', 'i', 'align', 'align', 'm', 'm', 'm', 'm']
    return Instruction_VLD1_A1_ffb00000_f4200000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0ff000d0)
  {
  case 0x07000010:
    // SMLAD{X}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 0, 0, 0, 0, 'd', 'd', 'd', 'd', 'a', 'a', 'a', 'a', 'm', 'm', 'm', 'm', 0, 0, 'M', 1, 'n', 'n', 'n', 'n']
    return Instruction_SMLAD_A1_0ff000d0_07000010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x07000050:
    // SMLSD{X}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 0, 0, 0, 0, 'd', 'd', 'd', 'd', 'a', 'a', 'a', 'a', 'm', 'm', 'm', 'm', 0, 1, 'M', 1, 'n', 'n', 'n', 'n']
    return Instruction_SMLSD_A1_0ff000d0_07000050(rBinStrm, Offset, Opcode32, rInsn);
  case 0x07400010:
    // SMLALD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 0, 1, 0, 0, 'dhi', 'dhi', 'dhi', 'dhi', 'dlo', 'dlo', 'dlo', 'dlo', 'm', 'm', 'm', 'm', 0, 0, 'M', 1, 'n', 'n', 'n', 'n']
    return Instruction_SMLALD_A1_0ff000d0_07400010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x07400050:
    // SMLSLD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 0, 1, 0, 0, 'dhi', 'dhi', 'dhi', 'dhi', 'dlo', 'dlo', 'dlo', 'dlo', 'm', 'm', 'm', 'm', 0, 1, 'M', 1, 'n', 'n', 'n', 'n']
    return Instruction_SMLSLD_A1_0ff000d0_07400050(rBinStrm, Offset, Opcode32, rInsn);
  case 0x07500010:
    // SMMLA{R}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 0, 1, 0, 1, 'd', 'd', 'd', 'd', 'a', 'a', 'a', 'a', 'm', 'm', 'm', 'm', 0, 0, 'R', 1, 'n', 'n', 'n', 'n']
    return Instruction_SMMLA_A1_0ff000d0_07500010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x075000d0:
    // SMMLS{R}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 0, 1, 0, 1, 'd', 'd', 'd', 'd', 'a', 'a', 'a', 'a', 'm', 'm', 'm', 'm', 1, 1, 'R', 1, 'n', 'n', 'n', 'n']
    return Instruction_SMMLS_A1_0ff000d0_075000d0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0ff000b0)
  {
  case 0x01200080:
    // SMLAW<y><c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 1, 0, 'd', 'd', 'd', 'd', 'a', 'a', 'a', 'a', 'm', 'm', 'm', 'm', 1, 'M', 0, 0, 'n', 'n', 'n', 'n']
    return Instruction_SMLAW_A1_0ff000b0_01200080(rBinStrm, Offset, Opcode32, rInsn);
  case 0x012000a0:
    // SMULW<y><c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 1, 0, 'd', 'd', 'd', 'd', 'sbz', 'sbz', 'sbz', 'sbz', 'm', 'm', 'm', 'm', 1, 'M', 1, 0, 'n', 'n', 'n', 'n']
    return Instruction_SMULW_A1_0ff000b0_012000a0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fe000f0)
  {
  case 0x00200090:
    // MLA{S}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 0, 1, 'S', 'd', 'd', 'd', 'd', 'a', 'a', 'a', 'a', 'm', 'm', 'm', 'm', 1, 0, 0, 1, 'n', 'n', 'n', 'n']
    return Instruction_MLA_A1_0fe000f0_00200090(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00800090:
    // UMULL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 0, 0, 'S', 'dhi', 'dhi', 'dhi', 'dhi', 'dlo', 'dlo', 'dlo', 'dlo', 'm', 'm', 'm', 'm', 1, 0, 0, 1, 'n', 'n', 'n', 'n']
    return Instruction_UMULL_A1_0fe000f0_00800090(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00a00090:
    // UMLAL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 0, 1, 'S', 'dhi', 'dhi', 'dhi', 'dhi', 'dlo', 'dlo', 'dlo', 'dlo', 'm', 'm', 'm', 'm', 1, 0, 0, 1, 'n', 'n', 'n', 'n']
    return Instruction_UMLAL_A1_0fe000f0_00a00090(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00c00090:
    // SMULL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 1, 0, 'S', 'dhi', 'dhi', 'dhi', 'dhi', 'dlo', 'dlo', 'dlo', 'dlo', 'm', 'm', 'm', 'm', 1, 0, 0, 1, 'n', 'n', 'n', 'n']
    return Instruction_SMULL_A1_0fe000f0_00c00090(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00e00090:
    // SMLAL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 1, 1, 'S', 'dhi', 'dhi', 'dhi', 'dhi', 'dlo', 'dlo', 'dlo', 'dlo', 'm', 'm', 'm', 'm', 1, 0, 0, 1, 'n', 'n', 'n', 'n']
    return Instruction_SMLAL_A1_0fe000f0_00e00090(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fef0000)
  {
  case 0x024d0000:
    // SUB{S}<c> <Rd>, SP, #<arm_expand_imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 0, 1, 0, 'S', 1, 1, 0, 1, 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_SUB_A1_0fef0000_024d0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x028d0000:
    // ADD{S}<c> <Rd>, SP, #<arm_expand_imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 1, 0, 0, 'S', 1, 1, 0, 1, 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_ADD_A1_0fef0000_028d0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x03a00000:
    // MOV{S}<c> <Rd>, #<arm_expand_imm_c> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_MOV_A1_0fef0000_03a00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x03e00000:
    // MVN{S}<c> <Rd>, #<arm_expand_imm_c> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 1, 1, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_MVN_A1_0fef0000_03e00000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0f7000f0)
  {
  case 0x006000b0:
    // STRHT<c> <Rt>, [<Rn>] {,#<imm>} - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 'U', 1, 1, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 0, 1, 1, 'i', 'i', 'i', 'i']
    return Instruction_STRHT_A1_0f7000f0_006000b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x007000b0:
    // LDRHT<c> <Rt>, [<Rn>] {,#<imm>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 'U', 1, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 0, 1, 1, 'i', 'i', 'i', 'i']
    return Instruction_LDRHT_A1_0f7000f0_007000b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x007000d0:
    // LDRSBT<c> <Rt>, [<Rn>] {,#<imm>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 'U', 1, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 1, 0, 1, 'i', 'i', 'i', 'i']
    return Instruction_LDRSBT_A1_0f7000f0_007000d0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x007000f0:
    // LDRSHT<c> <Rt>, [<Rn>] {,#<imm>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 'U', 1, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'i', 'i']
    return Instruction_LDRSHT_A1_0f7000f0_007000f0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fb00e10)
  {
  case 0x0e000a00:
    // V<op><c>.F32 <Sd>, <Sn>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 0, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 'op', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_V_A2_0fb00e10_0e000a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0e100a00:
    // VNMLS<c>.F32 <Sd>, <Sn>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 0, 'D', 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 'op', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VNMLS_A1_0fb00e10_0e100a00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0f7f0000)
  {
  case 0x051f0000:
    // LDR<c> <Rt>, <u_label> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 0, '(1)', 'U', 0, '(0)', 1, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDR_A1_0f7f0000_051f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x055f0000:
    // LDRB<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 0, '(1)', 'U', 1, '(0)', 1, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRB_A1_0f7f0000_055f0000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0ff00030) == 0x06800010)
    // PKHTB<c> <Rd>, <Rn>, <Rm>{,ASR #<imm>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tb', 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_PKHTB_A1_0ff00030_06800010(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0f300f00)
  {
  case 0x0d000a00:
    // VSTR<c> <Sd>, [<Rn>{,#+/-<imm>}] - [] - ['c', 'c', 'c', 'c', 1, 1, 0, 1, 'U', 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_VSTR_A2_0f300f00_0d000a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0d000b00:
    // VSTR<c> <Dd>, [<Rn>{,#+/-<imm>}] - [] - ['c', 'c', 'c', 'c', 1, 1, 0, 1, 'U', 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_VSTR_A1_0f300f00_0d000b00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0d100a00:
    // VLDR<c> <Sd>, [PC,#-0] - ['support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 1, 'U', 'D', 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_VLDR_A2_0f300f00_0d100a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0d100b00:
    // VLDR<c> <Dd>, [PC,#-0] - ['support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 1, 'U', 'D', 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_VLDR_A1_0f300f00_0d100b00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0ff00090)
  {
  case 0x01000080:
    // SMLA<x><y><c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 0, 0, 'd', 'd', 'd', 'd', 'a', 'a', 'a', 'a', 'm', 'm', 'm', 'm', 1, 'M', 'N', 0, 'n', 'n', 'n', 'n']
    return Instruction_SMLA_A1_0ff00090_01000080(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01400080:
    // SMLAL<x><y><c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 1, 0, 0, 'dhi', 'dhi', 'dhi', 'dhi', 'dlo', 'dlo', 'dlo', 'dlo', 'm', 'm', 'm', 'm', 1, 'M', 'N', 0, 'n', 'n', 'n', 'n']
    return Instruction_SMLAL_A1_0ff00090_01400080(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01600080:
    // SMUL<x><y><c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 1, 1, 0, 'd', 'd', 'd', 'd', 'sbz', 'sbz', 'sbz', 'sbz', 'm', 'm', 'm', 'm', 1, 'M', 'N', 0, 'n', 'n', 'n', 'n']
    return Instruction_SMUL_A1_0ff00090_01600080(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fe00070)
  {
  case 0x07a00050:
    // SBFX<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 1, 0, 1, 'widthm1', 'widthm1', 'widthm1', 'widthm1', 'widthm1', 'd', 'd', 'd', 'd', 'lsb', 'lsb', 'lsb', 'lsb', 'lsb', 1, 0, 1, 'n', 'n', 'n', 'n']
    return Instruction_SBFX_A1_0fe00070_07a00050(rBinStrm, Offset, Opcode32, rInsn);
  case 0x07c00010:
    // BFI<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 1, 1, 0, 'msb', 'msb', 'msb', 'msb', 'msb', 'd', 'd', 'd', 'd', 'lsb', 'lsb', 'lsb', 'lsb', 'lsb', 0, 0, 1, 'n', 'n', 'n', 'n']
    return Instruction_BFI_A1_0fe00070_07c00010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x07e00050:
    // UBFX<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 1, 1, 1, 'widthm1', 'widthm1', 'widthm1', 'widthm1', 'widthm1', 'd', 'd', 'd', 'd', 'lsb', 'lsb', 'lsb', 'lsb', 'lsb', 1, 0, 1, 'n', 'n', 'n', 'n']
    return Instruction_UBFX_A1_0fe00070_07e00050(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xff100010)
  {
  case 0xfe000010:
    // MCR2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['could_jmp'] - [1, 1, 1, 1, 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 1, 'm', 'm', 'm', 'm']
    return Instruction_MCR2_A2_ff100010_fe000010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfe100010:
    // MRC2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['could_jmp'] - [1, 1, 1, 1, 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 1, 'm', 'm', 'm', 'm']
    return Instruction_MRC2_A2_ff100010_fe100010(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fe00090)
  {
  case 0x00000010:
    // AND{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 0, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
    return Instruction_AND_A1_0fe00090_00000010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00200010:
    // EOR{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 0, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
    return Instruction_EOR_A1_0fe00090_00200010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00400010:
    // SUB{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 1, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
    return Instruction_SUB_A1_0fe00090_00400010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00600010:
    // RSB{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 1, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
    return Instruction_RSB_A1_0fe00090_00600010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00800010:
    // ADD{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 0, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
    return Instruction_ADD_A1_0fe00090_00800010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00a00010:
    // ADC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 0, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
    return Instruction_ADC_A1_0fe00090_00a00010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00c00010:
    // SBC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 1, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
    return Instruction_SBC_A1_0fe00090_00c00010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00e00010:
    // RSC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 1, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
    return Instruction_RSC_A1_0fe00090_00e00010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01800010:
    // ORR{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
    return Instruction_ORR_A1_0fe00090_01800010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01c00010:
    // BIC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 1, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
    return Instruction_BIC_A1_0fe00090_01c00010(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0e5000f0)
  {
  case 0x004000b0:
    // STRH<c> <Rt>, [<Rn>, #<imm>]! - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 1, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 0, 1, 1, 'i', 'i', 'i', 'i']
    return Instruction_STRH_A1_0e5000f0_004000b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x004000d0:
    // LDRD<c> <Rt>, <Rt2>, [<Rn>, #<imm>]! - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 1, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 1, 0, 1, 'i', 'i', 'i', 'i']
    return Instruction_LDRD_A1_0e5000f0_004000d0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x004000f0:
    // STRD<c> <Rt>, <Rt2>, [<Rn>, #<imm>]! - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 1, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'i', 'i']
    return Instruction_STRD_A1_0e5000f0_004000f0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x005000b0:
    // LDRH<c> <Rt>, [<Rn>, #<imm>]! - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 1, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 0, 1, 1, 'i', 'i', 'i', 'i']
    return Instruction_LDRH_A1_0e5000f0_005000b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x005000d0:
    // LDRSB<c> <Rt>, [<Rn>, #<imm>]! - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 1, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 1, 0, 1, 'i', 'i', 'i', 'i']
    return Instruction_LDRSB_A1_0e5000f0_005000d0(rBinStrm, Offset, Opcode32, rInsn);
  case 0x005000f0:
    // LDRSH<c> <Rt>, [<Rn>, #<imm>]! - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 1, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'i', 'i']
    return Instruction_LDRSH_A1_0e5000f0_005000f0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fe00030)
  {
  case 0x06a00010:
    // SSAT<c> <Rd>, #<imm>, <Rn>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 1, 'sat_imm_5', 'sat_imm_5', 'sat_imm_5', 'sat_imm_5', 'sat_imm_5', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'sh', 0, 1, 'n', 'n', 'n', 'n']
    return Instruction_SSAT_A1_0fe00030_06a00010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06e00010:
    // USAT<c> <Rd>, #<imm5>, <Rn>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 1, 1, 'sat_imm_5', 'sat_imm_5', 'sat_imm_5', 'sat_imm_5', 'sat_imm_5', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'sh', 0, 1, 'n', 'n', 'n', 'n']
    return Instruction_USAT_A1_0fe00030_06e00010(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xff000010) == 0xfe000000)
    // CDP2<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 'opc1', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 0, 'm', 'm', 'm', 'm']
    return Instruction_CDP2_A2_ff000010_fe000000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0x0e1f0000) == 0x0c1f0000)
    // LDC{L}<c> <coproc>, <CRd>, [PC],<option> - ['support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 'P', 'U', 'D', 'W', 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDC_A1_0e1f0000_0c1f0000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0ff00000)
  {
  case 0x03000000:
    // MOVW<c> <Rd>, #<arm_expand_imm_c> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 0, 0, 0, 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_MOVW_A2_0ff00000_03000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x03400000:
    // MOVT<c> <Rd>, #<imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 1, 0, 0, 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_MOVT_A1_0ff00000_03400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0c400000:
    // MCRR<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 1, 1, 0, 0, 0, 1, 0, 0, 't2', 't2', 't2', 't2', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc1', 'opc1', 'opc1', 'opc1', 'm', 'm', 'm', 'm']
    return Instruction_MCRR_A1_0ff00000_0c400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0c500000:
    // MRRC<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 1, 1, 0, 0, 0, 1, 0, 1, 't2', 't2', 't2', 't2', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc1', 'opc1', 'opc1', 'opc1', 'm', 'm', 'm', 'm']
    return Instruction_MRRC_A1_0ff00000_0c500000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0e100f00)
  {
  case 0x0c000a00:
    // FSTMX - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 'P', 'U', 'D', 'W', 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_FSTMX_A2_0e100f00_0c000a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0c000b00:
    // VSTM{mode}<c> <Rn>{!}, <list> - [] - ['c', 'c', 'c', 'c', 1, 1, 0, 'P', 'U', 'D', 'W', 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_VSTM_A1_0e100f00_0c000b00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0c100a00:
    // FLDMX - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 'P', 'U', 'D', 'W', 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_FLDMX_A2_0e100f00_0c100a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0c100b00:
    // VLDM{mode}<c> <Rn>{!}, <list> - [] - ['c', 'c', 'c', 'c', 1, 1, 0, 'P', 'U', 'D', 'W', 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_VLDM_A1_0e100f00_0c100b00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfe100000)
  {
  case 0xfc000000:
    // STC2{L}<c> <coproc>, <CRd>, [<Rn>],<option> - ['support_it_block', 'support_it_block'] - [1, 1, 1, 1, 1, 1, 0, 'P', 'U', 'D', 'W', 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_STC2_A2_fe100000_fc000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfc100000:
    // LDC2{L}<c> <coproc>, <CRd>, [<Rn>],<option> - ['support_it_block', 'support_it_block'] - [1, 1, 1, 1, 1, 1, 0, 'P', 'U', 'D', 'W', 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDC2_A2_fe100000_fc100000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0f700010)
  {
  case 0x06200000:
    // STRT<c> <Rt>, [<Rn>],+/-<Rm>{,<shift>} - [] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 'U', 0, 1, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_STRT_A2_0f700010_06200000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06300000:
    // LDRT<c> <Rt>, [<Rn>],+/-<Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 'U', 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_LDRT_A2_0f700010_06300000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06600000:
    // STRBT<c> <Rt>, [<Rn>],+/-<Rm>{,<shift>} - [] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 'U', 1, 1, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_STRBT_A2_0f700010_06600000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06700000:
    // LDRBT<c> <Rt>, [<Rn>],+/-<Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 'U', 1, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_LDRBT_A2_0f700010_06700000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fe00010)
  {
  case 0x00000000:
    // AND{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 0, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_AND_A1_0fe00010_00000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00200000:
    // EOR{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 0, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_EOR_A1_0fe00010_00200000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00400000:
    // SUB{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 1, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_SUB_A1_0fe00010_00400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00600000:
    // RSB{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 1, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_RSB_A1_0fe00010_00600000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00800000:
    // ADD{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 0, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_ADD_A1_0fe00010_00800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00a00000:
    // ADC{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 0, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_ADC_A1_0fe00010_00a00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00c00000:
    // SBC{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 1, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_SBC_A1_0fe00010_00c00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x00e00000:
    // RSC{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 1, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_RSC_A1_0fe00010_00e00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01800000:
    // ORR{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_ORR_A1_0fe00010_01800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x01c00000:
    // BIC{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 1, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_BIC_A1_0fe00010_01c00000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0f700000)
  {
  case 0x04200000:
    // STRT<c> <Rt>, [<Rn>] {, #<imm>} - [] - ['c', 'c', 'c', 'c', 0, 1, 0, 0, 'U', 0, 1, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_STRT_A1_0f700000_04200000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x04300000:
    // LDRT<c> <Rt>, [<Rn>] {,#<imm>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 0, 0, 'U', 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRT_A1_0f700000_04300000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x04600000:
    // STRBT<c> <Rt>, [<Rn>], #<imm> - [] - ['c', 'c', 'c', 'c', 0, 1, 0, 0, 'U', 1, 1, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_STRBT_A1_0f700000_04600000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x04700000:
    // LDRBT<c> <Rt>, [<Rn>], #<imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 0, 0, 'U', 1, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRBT_A1_0f700000_04700000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fd00000)
  {
  case 0x08000000:
    // STMDA<c> <Rn>{!},<registers> - [] - ['c', 'c', 'c', 'c', 1, 0, 0, 0, 0, 0, 'W', 0, 'n', 'n', 'n', 'n', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
    return Instruction_STMDA_A1_0fd00000_08000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x08100000:
    // LDMDA<c> <Rn>{!},<registers> - ['could_jmp'] - ['c', 'c', 'c', 'c', 1, 0, 0, 0, 0, 0, 'W', 1, 'n', 'n', 'n', 'n', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
    return Instruction_LDMDA_A1_0fd00000_08100000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x08800000:
    // STM<c> <Rn>{!},<registers> - [] - ['c', 'c', 'c', 'c', 1, 0, 0, 0, 1, 0, 'W', 0, 'n', 'n', 'n', 'n', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
    return Instruction_STM_A1_0fd00000_08800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x08900000:
    // LDM<c> <Rn>{!},<registers> - ['could_jmp'] - ['c', 'c', 'c', 'c', 1, 0, 0, 0, 1, 0, 'W', 1, 'n', 'n', 'n', 'n', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
    return Instruction_LDM_A1_0fd00000_08900000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x09000000:
    // STMDB<c> <Rn>{!},<registers> - [] - ['c', 'c', 'c', 'c', 1, 0, 0, 1, 0, 0, 'W', 0, 'n', 'n', 'n', 'n', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
    return Instruction_STMDB_A1_0fd00000_09000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x09100000:
    // LDMDB<c> <Rn>{!},<registers> - ['could_jmp'] - ['c', 'c', 'c', 'c', 1, 0, 0, 1, 0, 0, 'W', 1, 'n', 'n', 'n', 'n', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
    return Instruction_LDMDB_A1_0fd00000_09100000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x09800000:
    // STMIB<c> <Rn>{!},<registers> - [] - ['c', 'c', 'c', 'c', 1, 0, 0, 1, 1, 0, 'W', 0, 'n', 'n', 'n', 'n', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
    return Instruction_STMIB_A1_0fd00000_09800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x09900000:
    // LDMIB<c> <Rn>{!},<registers> - ['could_jmp'] - ['c', 'c', 'c', 'c', 1, 0, 0, 1, 1, 0, 'W', 1, 'n', 'n', 'n', 'n', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
    return Instruction_LDMIB_A1_0fd00000_09900000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0fe00000)
  {
  case 0x02000000:
    // AND{S}<c> <Rd>, <Rn>, #<arm_expand_imm_c> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 0, 0, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_AND_A1_0fe00000_02000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x02200000:
    // EOR{S}<c> <Rd>, <Rn>, #<arm_expand_imm_c> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 0, 0, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_EOR_A1_0fe00000_02200000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x02400000:
    // SUB{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 0, 1, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_SUB_A1_0fe00000_02400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x02600000:
    // RSB{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 0, 1, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_RSB_A1_0fe00000_02600000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x02800000:
    // ADD{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 1, 0, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_ADD_A1_0fe00000_02800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x02a00000:
    // ADC{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 1, 0, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_ADC_A1_0fe00000_02a00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x02c00000:
    // SBC{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 1, 1, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_SBC_A1_0fe00000_02c00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x02e00000:
    // RSC{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 1, 1, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_RSC_A1_0fe00000_02e00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x03800000:
    // ORR{S}<c> <Rd>, <Rn>, #<arm_expand_imm_c> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 1, 0, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_ORR_A1_0fe00000_03800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x03c00000:
    // BIC{S}<c> <Rd>, <Rn>, #<arm_expand_imm_c> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 1, 1, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_BIC_A1_0fe00000_03c00000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfe000000) == 0xfa000000)
    // BLX <arm_branch_label> - ['call'] - [1, 1, 1, 1, 1, 0, 1, 'H', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_BLX_A2_fe000000_fa000000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0e500010)
  {
  case 0x06000000:
    // STR<c> <Rt>, [<Rn>],+/-<Rm>{,<shift>} - [] - ['c', 'c', 'c', 'c', 0, 1, 1, 'P', 'U', 0, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_STR_A1_0e500010_06000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06100000:
    // LDR<c> <Rt>, [<Rn>],+/-<Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 'P', 'U', 0, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_LDR_A1_0e500010_06100000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06400000:
    // STRB<c> <Rt>, [<Rn>],+/-<Rm>{,<shift>} - [] - ['c', 'c', 'c', 'c', 0, 1, 1, 'P', 'U', 1, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_STRB_A1_0e500010_06400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x06500000:
    // LDRB<c> <Rt>, [<Rn>],+/-<Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 'P', 'U', 1, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
    return Instruction_LDRB_A1_0e500010_06500000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0f100010)
  {
  case 0x0e000010:
    // MCR<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - [] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 1, 'm', 'm', 'm', 'm']
    return Instruction_MCR_A1_0f100010_0e000010(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0e100010:
    // MRC<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 1, 'm', 'm', 'm', 'm']
    return Instruction_MRC_A1_0f100010_0e100010(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0x0f000010) == 0x0e000000)
    // CDP<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2> - [] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 'opc1', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 0, 'm', 'm', 'm', 'm']
    return Instruction_CDP_A1_0f000010_0e000000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0x0e500000)
  {
  case 0x04000000:
    // STR<c> <Rt>, [<Rn>,#<imm>]! - [] - ['c', 'c', 'c', 'c', 0, 1, 0, 'P', 'U', 0, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_STR_A1_0e500000_04000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x04100000:
    // LDR<c> <Rt>, [<Rn>,#<imm>]! - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 0, 'P', 'U', 0, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDR_A1_0e500000_04100000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x04400000:
    // STRB<c> <Rt>, [<Rn>,#<imm>]! - [] - ['c', 'c', 'c', 'c', 0, 1, 0, 'P', 'U', 1, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_STRB_A1_0e500000_04400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x04500000:
    // LDRB<c> <Rt>, [<Rn>,#<imm>]! - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 0, 'P', 'U', 1, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRB_A1_0e500000_04500000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0e100000)
  {
  case 0x0c000000:
    // STC{L}<c> <coproc>, <CRd>, [<Rn>],<option> - ['support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 'P', 'U', 'D', 'W', 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_STC_A1_0e100000_0c000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0c100000:
    // LDC{L}<c> <coproc>, <CRd>, [<Rn>],<option> - ['support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 'P', 'U', 'D', 'W', 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDC_A1_0e100000_0c100000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0x0f000000)
  {
  case 0x0a000000:
    // B<c> <arm_branch_label> - ['jmp'] - ['c', 'c', 'c', 'c', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_B_A1_0f000000_0a000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0b000000:
    // BL<c> <arm_branch_label> - ['call'] - ['c', 'c', 'c', 'c', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_BL_A1_0f000000_0b000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0x0f000000:
    // SVC<c> #<imm> - ['syscall'] - ['c', 'c', 'c', 'c', 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_SVC_A1_0f000000_0f000000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  return false;
}
bool ArmArchitecture::DisassembleThumb(BinaryStream const& rBinStrm, TOffset Offset, Instruction& rInsn)
{
  u16 Opcode16Low;
  if (!rBinStrm.Read(Offset & ~1, Opcode16Low))
    return false;

  u16 Opcode16High;
  if (!rBinStrm.Read((Offset + 2) & ~1, Opcode16High))
    return false;

  u16 Opcode16 = Opcode16Low;
  u32 Opcode32 = ((Opcode16Low << 16) | Opcode16High);
  switch (Opcode32 & 0xffffffff)
  {
  case 0xf3af8000:
    // NOP<c>.W - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, '(0)', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    return Instruction_NOP_T2_ffffffff_f3af8000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3af8001:
    // YIELD<c>.W - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, '(0)', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
    return Instruction_YIELD_T2_ffffffff_f3af8001(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3af8002:
    // WFE<c>.W - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, '(0)', 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]
    return Instruction_WFE_T2_ffffffff_f3af8002(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3af8003:
    // WFI<c>.W - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, '(0)', 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]
    return Instruction_WFI_T2_ffffffff_f3af8003(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3af8004:
    // SEV<c>.W - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, '(0)', 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]
    return Instruction_SEV_T2_ffffffff_f3af8004(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3bf8f2f:
    // CLREX<c> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 0, '(1)', '(1)', '(1)', '(1)']
    return Instruction_CLREX_T1_ffffffff_f3bf8f2f(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfffffff0)
  {
  case 0xf3af80f0:
    // DBG<c> #<option> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, '(0)', 0, 0, 0, 1, 1, 1, 1, 'option', 'option', 'option', 'option']
    return Instruction_DBG_T1_fffffff0_f3af80f0(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3bf8f40:
    // DSB<c> #<option> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 0, 'option', 'option', 'option', 'option']
    return Instruction_DSB_T1_fffffff0_f3bf8f40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3bf8f50:
    // DMB<c> #<option> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 1, 'option', 'option', 'option', 'option']
    return Instruction_DMB_T1_fffffff0_f3bf8f50(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3bf8f60:
    // ISB<c> #<option> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, '(1)', '(1)', '(1)', '(1)', 0, 1, 1, 0, 'option', 'option', 'option', 'option']
    return Instruction_ISB_T1_fffffff0_f3bf8f60(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffff0fff)
  {
  case 0xeee10a10:
    // VMSR<c> FPSCR, <Rt> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 't', 't', 't', 't', 1, 0, 1, 0, 0, '(0)', '(0)', 1, '(0)', '(0)', '(0)', '(0)']
    return Instruction_VMSR_T1_ffff0fff_eee10a10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeef10a10:
    // VMRS<c> <Rt>, FPSCR - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 't', 't', 't', 't', 1, 0, 1, 0, 0, '(0)', '(0)', 1, '(0)', '(0)', '(0)', '(0)']
    return Instruction_VMRS_T1_ffff0fff_eef10a10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf84d0d04:
    // PUSH<c>.W <Rt> - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 't', 't', 't', 't', 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0]
    return Instruction_PUSH_T3_ffff0fff_f84d0d04(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf85d0b04:
    // POP<c>.W <Rt> - ['could_ret'] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 't', 't', 't', 't', 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0]
    return Instruction_POP_T3_ffff0fff_f85d0b04(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfffff0ff) == 0xf3ef8000)
    // MRS<c> <Rd>, <spec_reg> - ['could_jmp'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, 'd', 'd', 'd', 'd', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)']
    return Instruction_MRS_T1_fffff0ff_f3ef8000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xfff0ffff) == 0xf3c08f00)
    // BXJ<c> <Rm> - ['call', 'change_to_jazelle'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 'm', 'm', 'm', 'm', 1, 0, '(0)', 0, '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)']
    return Instruction_BXJ_T1_fff0ffff_f3c08f00(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xfff0f3ff) == 0xf3808000)
    // MSR<c> <spec_reg>, <Rn> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 0, '(0)', 0, 'mask_4', 'mask_4', 0, 0, '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)']
    return Instruction_MSR_T1_fff0f3ff_f3808000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xffbf0e7f) == 0xeeb50a40)
    // VCMP{E}<c>.F64 <Dd>, #0.0 - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 0, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'E', 1, '(0)', 0, '(0)', '(0)', '(0)', '(0)']
    return Instruction_VCMP_T2_ffbf0e7f_eeb50a40(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfff00fff)
  {
  case 0xe8d00f4f:
    // LDREXB<c> <Rt>, [<Rn>] - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 0, '(1)', '(1)', '(1)', '(1)']
    return Instruction_LDREXB_T1_fff00fff_e8d00f4f(rBinStrm, Offset, Opcode32, rInsn);
  case 0xe8d00f5f:
    // LDREXH<c> <Rt>, [<Rn>] - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 1, '(1)', '(1)', '(1)', '(1)']
    return Instruction_LDREXH_T1_fff00fff_e8d00f5f(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfff0ffe0) == 0xe8d0f000)
    // TBH<c> [<Rn>, <Rm>,LSL #1] - ['jmp'] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 0, 0, 'H', 'm', 'm', 'm', 'm']
    return Instruction_TBH_T1_fff0ffe0_e8d0f000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffeff0f0)
  {
  case 0xea4f0000:
    // MOV{S}<c>.W <Rd>, <Rm> - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 'S', 1, 1, 1, 1, '(0)', 0, 0, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_MOV_T3_ffeff0f0_ea4f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xea4f0030:
    // RRX{S}<c> <Rd>, <Rm> - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 'S', 1, 1, 1, 1, '(0)', 0, 0, 0, 'd', 'd', 'd', 'd', 0, 0, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_RRX_T1_ffeff0f0_ea4f0030(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfffff0c0)
  {
  case 0xfa0ff080:
    // SXTH<c>.W <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
    return Instruction_SXTH_T2_fffff0c0_fa0ff080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa1ff080:
    // UXTH<c>.W <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
    return Instruction_UXTH_T2_fffff0c0_fa1ff080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa2ff080:
    // SXTB16<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
    return Instruction_SXTB16_T1_fffff0c0_fa2ff080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa3ff080:
    // UXTB16<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
    return Instruction_UXTB16_T1_fffff0c0_fa3ff080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa4ff080:
    // SXTB<c>.W <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
    return Instruction_SXTB_T2_fffff0c0_fa4ff080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa5ff080:
    // UXTB<c>.W <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
    return Instruction_UXTB_T2_fffff0c0_fa5ff080(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffe00f7f) == 0xee000a10)
    // VMOV<c> <Sn>, <Rt> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 'op', 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 0, 1, 0, 'N', '(0)', '(0)', 1, '(0)', '(0)', '(0)', '(0)']
    return Instruction_VMOV_T1_ffe00f7f_ee000a10(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xfff0ffc0) == 0xf910f000)
    // PLI<c> [<Rn>, <Rm>{,LSL #<imm>}] - [] - [1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 'i', 'i', 'm', 'm', 'm', 'm']
    return Instruction_PLI_T1_fff0ffc0_f910f000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffbf0ed0)
  {
  case 0xeeb00a40:
    // VMOV<c>.F64 <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 0, 0, 0, 0, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 0, 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VMOV_T2_ffbf0ed0_eeb00a40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeeb00ac0:
    // VABS<c>.F64 <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 0, 0, 0, 0, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 1, 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VABS_T2_ffbf0ed0_eeb00ac0(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeeb10a40:
    // VNEG<c>.F64 <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 0, 0, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 0, 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VNEG_T2_ffbf0ed0_eeb10a40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeeb10ac0:
    // VSQRT<c>.F64 <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 0, 0, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 1, 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VSQRT_T1_ffbf0ed0_eeb10ac0(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeeb70ac0:
    // VCVT<c>.F64.F32 <Dd>, <Sm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 0, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 1, 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCVT_T1_ffbf0ed0_eeb70ac0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffd0ffc0) == 0xf810f000)
    // PLD{R}<c> [<Rn>, <Rm>{,LSL #<imm>}] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 'R', 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 'i', 'i', 'm', 'm', 'm', 'm']
    return Instruction_PLD_T1_ffd0ffc0_f810f000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xfff0ff00) == 0xf910fc00)
    // PLI<c> [<Rn>,#-<imm>] - [] - [1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 1, 1, 0, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_PLI_T2_fff0ff00_f910fc00(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xffbe0f50) == 0xeeb20a40)
    // VCVT<y><c>.F32.F16 <Sd>, <Sm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 0, 0, 1, 'op', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'T', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCVT_T1_ffbe0f50_eeb20a40(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xffbf0e50) == 0xeeb40a40)
    // VCMP{E}<c>.F64 <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 0, 1, 0, 0, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'E', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCMP_T1_ffbf0e50_eeb40a40(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffb30fd0)
  {
  case 0xffb20200:
    // VMOVN<c>.<dt> <Dd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 0, 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VMOVN_T1_ffb30fd0_ffb20200(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb20300:
    // VSHLL<c>.<type_4><size> <Qd>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 1, 1, 0, 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VSHLL_T2_ffb30fd0_ffb20300(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xff900f5f) == 0xee800b10)
    // VDUP<c>.<size> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'B', 'Q', 0, 'd', 'd', 'd', 'd', 't', 't', 't', 't', 1, 0, 1, 1, 'D', 0, 'E', 1, '(0)', '(0)', '(0)', '(0)']
    return Instruction_VDUP_T1_ff900f5f_ee800b10(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfff0f0f0)
  {
  case 0xf3200000:
    // SSAT16<c> <Rd>, #<imm>, <Rn> - ['could_jmp'] - [1, 1, 1, 1, 0, '(0)', 1, 1, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 0, 0, 0, 0, 'd', 'd', 'd', 'd', 0, 0, '(0)', '(0)', 'i', 'i', 'i', 'i']
    return Instruction_SSAT16_T1_fff0f0f0_f3200000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3a00000:
    // USAT16<c> <Rd>, #<imm4>, <Rn> - ['could_jmp'] - [1, 1, 1, 1, 0, '(0)', 1, 1, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 0, 0, 0, 0, 'd', 'd', 'd', 'd', 0, 0, '(0)', '(0)', 'i', 'i', 'i', 'i']
    return Instruction_USAT16_T1_fff0f0f0_f3a00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa80f000:
    // SADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_SADD8_T1_fff0f0f0_fa80f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa80f010:
    // QADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_QADD8_T1_fff0f0f0_fa80f010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa80f020:
    // SHADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'm', 'm', 'm', 'm']
    return Instruction_SHADD8_T1_fff0f0f0_fa80f020(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa80f040:
    // UADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_UADD8_T1_fff0f0f0_fa80f040(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa80f050:
    // UQADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_UQADD8_T1_fff0f0f0_fa80f050(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa80f060:
    // UHADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'm', 'm', 'm', 'm']
    return Instruction_UHADD8_T1_fff0f0f0_fa80f060(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa80f080:
    // QADD<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_QADD_T1_fff0f0f0_fa80f080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa80f090:
    // QDADD<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_QDADD_T1_fff0f0f0_fa80f090(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa80f0a0:
    // QSUB<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'm', 'm', 'm', 'm']
    return Instruction_QSUB_T1_fff0f0f0_fa80f0a0(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa80f0b0:
    // QDSUB<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_QDSUB_T1_fff0f0f0_fa80f0b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa90f080:
    // REV<c>.W <Rd>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 'm', 'm', 'm', 'm', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_REV_T2_fff0f0f0_fa90f080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa90f090:
    // REV16<c>.W <Rd>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 'm', 'm', 'm', 'm', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_REV16_T2_fff0f0f0_fa90f090(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa90f0a0:
    // RBIT<c> <Rd>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 'm', 'm', 'm', 'm', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'm', 'm', 'm', 'm']
    return Instruction_RBIT_T1_fff0f0f0_fa90f0a0(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa90f0b0:
    // REVSH<c>.W <Rd>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 'm', 'm', 'm', 'm', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_REVSH_T2_fff0f0f0_fa90f0b0(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa90f000:
    // SADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_SADD16_T1_fff0f0f0_fa90f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa90f010:
    // QADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_QADD16_T1_fff0f0f0_fa90f010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa90f020:
    // SHADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'm', 'm', 'm', 'm']
    return Instruction_SHADD16_T1_fff0f0f0_fa90f020(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa90f040:
    // UADD16<c> <Rd>, <Rn>, <Rm> - [] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_UADD16_T1_fff0f0f0_fa90f040(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa90f050:
    // UQADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_UQADD16_T1_fff0f0f0_fa90f050(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa90f060:
    // UHADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'm', 'm', 'm', 'm']
    return Instruction_UHADD16_T1_fff0f0f0_fa90f060(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfaa0f000:
    // SASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_SASX_T1_fff0f0f0_faa0f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfaa0f010:
    // QASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_QASX_T1_fff0f0f0_faa0f010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfaa0f020:
    // SHASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'm', 'm', 'm', 'm']
    return Instruction_SHASX_T1_fff0f0f0_faa0f020(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfaa0f040:
    // UASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_UASX_T1_fff0f0f0_faa0f040(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfaa0f050:
    // UQASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_UQASX_T1_fff0f0f0_faa0f050(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfaa0f060:
    // UHASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'm', 'm', 'm', 'm']
    return Instruction_UHASX_T1_fff0f0f0_faa0f060(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfaa0f080:
    // SEL<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_SEL_T1_fff0f0f0_faa0f080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfab0f080:
    // CLZ<c> <Rd>, <Rm> - [] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 'm', 'm', 'm', 'm', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_CLZ_T1_fff0f0f0_fab0f080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfac0f000:
    // SSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_SSUB8_T1_fff0f0f0_fac0f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfac0f010:
    // QSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_QSUB8_T1_fff0f0f0_fac0f010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfac0f020:
    // SHSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'm', 'm', 'm', 'm']
    return Instruction_SHSUB8_T1_fff0f0f0_fac0f020(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfac0f040:
    // USUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_USUB8_T1_fff0f0f0_fac0f040(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfac0f050:
    // UQSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_UQSUB8_T1_fff0f0f0_fac0f050(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfac0f060:
    // UHSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'm', 'm', 'm', 'm']
    return Instruction_UHSUB8_T1_fff0f0f0_fac0f060(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfad0f000:
    // SSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_SSUB16_T1_fff0f0f0_fad0f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfad0f010:
    // QSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_QSUB16_T1_fff0f0f0_fad0f010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfad0f020:
    // SHSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'm', 'm', 'm', 'm']
    return Instruction_SHSUB16_T1_fff0f0f0_fad0f020(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfad0f040:
    // USUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_USUB16_T1_fff0f0f0_fad0f040(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfad0f050:
    // UQSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_UQSUB16_T1_fff0f0f0_fad0f050(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfad0f060:
    // UHSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'm', 'm', 'm', 'm']
    return Instruction_UHSUB16_T1_fff0f0f0_fad0f060(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfae0f000:
    // SSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_SSAX_T1_fff0f0f0_fae0f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfae0f010:
    // QSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_QSAX_T1_fff0f0f0_fae0f010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfae0f020:
    // SHSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'm', 'm', 'm', 'm']
    return Instruction_SHSAX_T1_fff0f0f0_fae0f020(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfae0f040:
    // USAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_USAX_T1_fff0f0f0_fae0f040(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfae0f050:
    // UQSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_UQSAX_T1_fff0f0f0_fae0f050(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfae0f060:
    // UHSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'm', 'm', 'm', 'm']
    return Instruction_UHSAX_T1_fff0f0f0_fae0f060(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb00f000:
    // MUL<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_MUL_T2_fff0f0f0_fb00f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb70f000:
    // USAD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_USAD8_T1_fff0f0f0_fb70f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb90f0f0:
    // SDIV<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 'n', 'n', 'n', 'n', '(1)', '(1)', '(1)', '(1)', 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_SDIV_T1_fff0f0f0_fb90f0f0(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfbb0f0f0:
    // UDIV<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 'n', 'n', 'n', 'n', '(1)', '(1)', '(1)', '(1)', 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_UDIV_T1_fff0f0f0_fbb0f0f0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfff000ff) == 0xe8d0007f)
    // LDREXD<c> <Rt>, <Rt2>, [<Rn>] - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 't2', 't2', 't2', 't2', 0, 1, 1, 1, '(1)', '(1)', '(1)', '(1)']
    return Instruction_LDREXD_T1_fff000ff_e8d0007f(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfff00ff0)
  {
  case 0xe8c00f40:
    // STREXB<c> <Rd>, <Rt>, [<Rn>] - [] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 0, 'd', 'd', 'd', 'd']
    return Instruction_STREXB_T1_fff00ff0_e8c00f40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xe8c00f50:
    // STREXH<c> <Rd>, <Rt>, [<Rn>] - [] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 1, 'd', 'd', 'd', 'd']
    return Instruction_STREXH_T1_fff00ff0_e8c00f50(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffd0ff00) == 0xf810fc00)
    // PLD{R}<c> [<Rn>, #-<imm>] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 'R', 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 1, 1, 0, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_PLD_T2_ffd0ff00_f810fc00(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffbf0f00)
  {
  case 0xecbd0a00:
    // VPOP <list> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 0, 1, 'D', 1, 1, 1, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_VPOP_T2_ffbf0f00_ecbd0a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xecbd0b00:
    // VPOP <list> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 0, 1, 'D', 1, 1, 1, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_VPOP_T1_ffbf0f00_ecbd0b00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xed2d0a00:
    // VPUSH<c> <list> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 1, 0, 'D', 1, 0, 1, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_VPUSH_T2_ffbf0f00_ed2d0a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xed2d0b00:
    // VPUSH<c> <list> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 1, 0, 'D', 1, 0, 1, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_VPUSH_T1_ffbf0f00_ed2d0b00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffe0f0f0)
  {
  case 0xfa00f000:
    // LSL{S}<c>.W <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 'S', 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_LSL_T2_ffe0f0f0_fa00f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa20f000:
    // LSR{S}<c>.W <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 'S', 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_LSR_T2_ffe0f0f0_fa20f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa40f000:
    // ASR{S}<c>.W <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 'S', 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_ASR_T2_ffe0f0f0_fa40f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa60f000:
    // ROR{S}<c>.W <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 'S', 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_ROR_T2_ffe0f0f0_fa60f000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffb30ed0) == 0xffb20600)
    // VCVT<c>.F32.F16 <Qd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 1, 1, 'op', 0, 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCVT_T1_ffb30ed0_ffb20600(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xff900f1f) == 0xee000b10)
    // VMOV<c>.<size> <Dd[x]>, <Rt> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 0, 'opc1', 'opc1', 0, 'd', 'd', 'd', 'd', 't', 't', 't', 't', 1, 0, 1, 1, 'D', 'opc2', 'opc2', 1, '(0)', '(0)', '(0)', '(0)']
    return Instruction_VMOV_T1_ff900f1f_ee000b10(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfff0f0e0)
  {
  case 0xfb20f000:
    // SMUAD{X}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 'M', 'm', 'm', 'm', 'm']
    return Instruction_SMUAD_T1_fff0f0e0_fb20f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb30f000:
    // SMULW<y><c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 'M', 'm', 'm', 'm', 'm']
    return Instruction_SMULW_T1_fff0f0e0_fb30f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb40f000:
    // SMUSD{X}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 'M', 'm', 'm', 'm', 'm']
    return Instruction_SMUSD_T1_fff0f0e0_fb40f000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb50f000:
    // SMMUL{R}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 'R', 'm', 'm', 'm', 'm']
    return Instruction_SMMUL_T1_fff0f0e0_fb50f000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xff7ff000)
  {
  case 0xf81ff000:
    // PLD<c> [PC,#-0] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 'U', 0, '(0)', 1, 1, 1, 1, 1, 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_PLD_T1_ff7ff000_f81ff000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf91ff000:
    // PLI<c> [PC,#-0] - [] - [1, 1, 1, 1, 1, 0, 0, 1, 'U', 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_PLI_T3_ff7ff000_f91ff000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffb30f90)
  {
  case 0xffb00400:
    // VCLS<c>.<dt> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 0, 0, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCLS_T1_ffb30f90_ffb00400(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb00480:
    // VCLZ<c>.<dt> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 0, 0, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCLZ_T1_ffb30f90_ffb00480(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb00500:
    // VCNT<c>.8 <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 0, 1, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCNT_T1_ffb30f90_ffb00500(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb00580:
    // VMVN<c> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 0, 1, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VMVN_T1_ffb30f90_ffb00580(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb00700:
    // VQABS<c>.<dt> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 1, 1, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQABS_T1_ffb30f90_ffb00700(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb00780:
    // VQNEG<c>.<dt> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 1, 1, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQNEG_T1_ffb30f90_ffb00780(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb20000:
    // VSWP<c> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VSWP_T1_ffb30f90_ffb20000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb20080:
    // VTRN<c>.<size> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VTRN_T1_ffb30f90_ffb20080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb20100:
    // VUZP<c>.<size> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 1, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VUZP_T1_ffb30f90_ffb20100(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb20180:
    // VZIP<c>.<size> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 1, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VZIP_T1_ffb30f90_ffb20180(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfff0f0c0)
  {
  case 0xfa00f080:
    // SXTAH<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
    return Instruction_SXTAH_T1_fff0f0c0_fa00f080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa10f080:
    // UXTAH<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
    return Instruction_UXTAH_T1_fff0f0c0_fa10f080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa20f080:
    // SXTAB16<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
    return Instruction_SXTAB16_T1_fff0f0c0_fa20f080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa30f080:
    // UXTAB16<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
    return Instruction_UXTAB16_T1_fff0f0c0_fa30f080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa40f080:
    // SXTAB<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
    return Instruction_SXTAB_T1_fff0f0c0_fa40f080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfa50f080:
    // UXTAB<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
    return Instruction_UXTAB_T1_fff0f0c0_fa50f080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb10f000:
    // SMUL<x><y><c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 'N', 'M', 'm', 'm', 'm', 'm']
    return Instruction_SMUL_T1_fff0f0c0_fb10f000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffef8030)
  {
  case 0xea4f0000:
    // LSL{S}<c>.W <Rd>, <Rm>, #<imm5> - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 'S', 1, 1, 1, 1, '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_LSL_T2_ffef8030_ea4f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xea4f0010:
    // LSR{S}<c>.W <Rd>, <Rm>, #<imm> - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 'S', 1, 1, 1, 1, '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_LSR_T2_ffef8030_ea4f0010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xea4f0020:
    // ASR{S}<c>.W <Rd>, <Rm>, #<imm> - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 'S', 1, 1, 1, 1, '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 1, 0, 'm', 'm', 'm', 'm']
    return Instruction_ASR_T2_ffef8030_ea4f0020(rBinStrm, Offset, Opcode32, rInsn);
  case 0xea4f0030:
    // ROR{S}<c> <Rd>, <Rm>, #<imm> - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 'S', 1, 1, 1, 1, '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 1, 1, 'm', 'm', 'm', 'm']
    return Instruction_ROR_T1_ffef8030_ea4f0030(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xef870fd0) == 0xef800a10)
    // VMOVL<c>.<dt> <Qd>, <Dm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 0, 0, 0, 'd', 'd', 'd', 'd', 1, 0, 1, 0, 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VMOVL_T1_ef870fd0_ef800a10(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffb30f10)
  {
  case 0xffb00200:
    // VPADDL<c>.<dt> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'op', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VPADDL_T1_ffb30f10_ffb00200(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb00600:
    // VPADAL<c>.<dt> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'op', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VPADAL_T1_ffb30f10_ffb00600(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb20200:
    // VQMOV{op}N<c>.<type><size> <Dd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'op', 'op', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQMOV_T1_ffb30f10_ffb20200(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfff00fc0)
  {
  case 0xf8000000:
    // STRB<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 0, 0, 0, 0, 0, 0, 'i', 'i', 'm', 'm', 'm', 'm']
    return Instruction_STRB_T2_fff00fc0_f8000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8100000:
    // LDRB<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 0, 0, 0, 0, 0, 0, 'i', 'i', 'm', 'm', 'm', 'm']
    return Instruction_LDRB_T2_fff00fc0_f8100000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8200000:
    // STRH<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 0, 0, 0, 0, 0, 0, 'i', 'i', 'm', 'm', 'm', 'm']
    return Instruction_STRH_T2_fff00fc0_f8200000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8300000:
    // LDRH<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 0, 0, 0, 0, 0, 0, 'i', 'i', 'm', 'm', 'm', 'm']
    return Instruction_LDRH_T2_fff00fc0_f8300000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8400000:
    // STR<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 0, 0, 0, 0, 0, 0, 'i', 'i', 'm', 'm', 'm', 'm']
    return Instruction_STR_T2_fff00fc0_f8400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8500000:
    // LDR<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 0, 0, 0, 0, 0, 0, 'i', 'i', 'm', 'm', 'm', 'm']
    return Instruction_LDR_T2_fff00fc0_f8500000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf9100000:
    // LDRSB<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 0, 0, 0, 0, 0, 0, 'i', 'i', 'm', 'm', 'm', 'm']
    return Instruction_LDRSB_T2_fff00fc0_f9100000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf9300000:
    // LDRSH<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 0, 0, 0, 0, 0, 0, 'i', 'i', 'm', 'm', 'm', 'm']
    return Instruction_LDRSH_T2_fff00fc0_f9300000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffb30e90)
  {
  case 0xffb30400:
    // VRECPE<c>.<dt> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 'F', 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VRECPE_T1_ffb30e90_ffb30400(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb30480:
    // VRSQRTE<c>.<dt> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 'F', 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VRSQRTE_T1_ffb30e90_ffb30480(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffb00ef0) == 0xeeb00a00)
    // VMOV<c>.F64 <Dd>, #<imm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', '(0)', 0, '(0)', 0, 'i', 'i', 'i', 'i']
    return Instruction_VMOV_T2_ffb00ef0_eeb00a00(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xffffa000) == 0xe8ad0000)
    // PUSH<c>.W <registers> - [] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, '(0)', 'M', '(0)', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
    return Instruction_PUSH_T2_ffffa000_e8ad0000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xff100f1f) == 0xee100b10)
    // VMOV<c>.<dt> <Rt>, <Dn[x]> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 'U', 'opc1', 'opc1', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 0, 1, 1, 'N', 'opc2', 'opc2', 1, '(0)', '(0)', '(0)', '(0)']
    return Instruction_VMOV_T1_ff100f1f_ee100b10(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffb30b90)
  {
  case 0xffb10000:
    // VCGT<c>.<dt> <Qd>, <Qm>, #0 - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 0, 0, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCGT_T1_ffb30b90_ffb10000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb10080:
    // VCGE<c>.<dt> <Qd>, <Qm>, #0 - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 0, 0, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCGE_T1_ffb30b90_ffb10080(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb10100:
    // VCEQ<c>.<dt> <Qd>, <Qm>, #0 - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 0, 1, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCEQ_T1_ffb30b90_ffb10100(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb10180:
    // VCLE<c>.<dt> <Qd>, <Qm>, #0 - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 0, 1, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCLE_T1_ffb30b90_ffb10180(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb10200:
    // VCLT<c>.<dt> <Qd>, <Qm>, #0 - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 1, 0, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCLT_T1_ffb30b90_ffb10200(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb10300:
    // VABS<c>.<dt> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 1, 1, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VABS_T1_ffb30b90_ffb10300(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb10380:
    // VNEG<c>.<dt> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 1, 1, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VNEG_T1_ffb30b90_ffb10380(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffff8020) == 0xf36f0000)
    // BFC<c> <Rd>, #<lsb>, #<width> - ['could_jmp'] - [1, 1, 1, 1, 0, '(0)', 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', '(0)', 'msb', 'msb', 'msb', 'msb', 'msb']
    return Instruction_BFC_T1_ffff8020_f36f0000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffe00fd0)
  {
  case 0xec400a10:
    // VMOV<c> <Sm>, <Sm1>, <Rt>, <Rt2> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 'op', 't2', 't2', 't2', 't2', 't', 't', 't', 't', 1, 0, 1, 0, 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VMOV_T1_ffe00fd0_ec400a10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xec400b10:
    // VMOV<c> <Dm>, <Rt>, <Rt2> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 'op', 't2', 't2', 't2', 't2', 't', 't', 't', 't', 1, 0, 1, 1, 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VMOV_T1_ffe00fd0_ec400b10(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffba0e50) == 0xeeba0a40)
    // VCVT<c>.<Td>.F64 <Dd>, <Dd>, #<fbits> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 1, 'op', 1, 'U', 'd', 'd', 'd', 'd', 1, 0, 1, 'sf', 'sx', 1, 'i', 0, 'i', 'i', 'i', 'i']
    return Instruction_VCVT_T1_ffba0e50_eeba0a40(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xffb80e50) == 0xeeb80a40)
    // VCVT{R}<c>.S32.F64 <Sd>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 1, 'opc2', 'opc2', 'opc2', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'op', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCVT_T1_ffb80e50_eeb80a40(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffb30e10)
  {
  case 0xffb00000:
    // VREV<n><c>.<size> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 'op', 'op', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VREV_T1_ffb30e10_ffb00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xffb30600:
    // VCVT<c>.<Td>.<Tm> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 1, 'd', 'd', 'd', 'd', 0, 1, 1, 'op', 'op', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCVT_T1_ffb30e10_ffb30600(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfff08f00)
  {
  case 0xea100f00:
    // TST<c>.W <Rn>, <Rm>{,<shift>} - [] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
    return Instruction_TST_T2_fff08f00_ea100f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xea900f00:
    // TEQ<c> <Rn>, <Rm>{,<shift>} - [] - [1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
    return Instruction_TEQ_T1_fff08f00_ea900f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeb100f00:
    // CMN<c>.W <Rn>, <Rm>{,<shift>} - ['cond'] - [1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
    return Instruction_CMN_T2_fff08f00_eb100f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xebb00f00:
    // CMP<c>.W <Rn>, <Rm> {,<shift>} - ['cond'] - [1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
    return Instruction_CMP_T3_fff08f00_ebb00f00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffff2000) == 0xe8bd0000)
    // POP<c>.W <registers> - ['could_ret'] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 'P', 'M', '(0)', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
    return Instruction_POP_T2_ffff2000_e8bd0000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xffb00f90) == 0xffb00c00)
    // VDUP<c>.<size> <Qd>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 1, 0, 0, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VDUP_T1_ffb00f90_ffb00c00(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfff000f0)
  {
  case 0xe8c00070:
    // STREXD<c> <Rd>, <Rt>, <Rt2>, [<Rn>] - [] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 't2', 't2', 't2', 't2', 0, 1, 1, 1, 'd', 'd', 'd', 'd']
    return Instruction_STREXD_T1_fff000f0_e8c00070(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb000000:
    // MLA<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 'n', 'n', 'n', 'n', 'a', 'a', 'a', 'a', 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_MLA_T1_fff000f0_fb000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb000010:
    // MLS<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 'n', 'n', 'n', 'n', 'a', 'a', 'a', 'a', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
    return Instruction_MLS_T1_fff000f0_fb000010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb700000:
    // USADA8<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 'n', 'n', 'n', 'n', 'a', 'a', 'a', 'a', 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_USADA8_T1_fff000f0_fb700000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb800000:
    // SMULL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 'dlo', 'dlo', 'dlo', 'dlo', 'dhi', 'dhi', 'dhi', 'dhi', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_SMULL_T1_fff000f0_fb800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfba00000:
    // UMULL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 'dlo', 'dlo', 'dlo', 'dlo', 'dhi', 'dhi', 'dhi', 'dhi', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_UMULL_T1_fff000f0_fba00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfbc00000:
    // SMLAL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 'dlo', 'dlo', 'dlo', 'dlo', 'dhi', 'dhi', 'dhi', 'dhi', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_SMLAL_T1_fff000f0_fbc00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfbe00000:
    // UMLAL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 'n', 'n', 'n', 'n', 'dlo', 'dlo', 'dlo', 'dlo', 'dhi', 'dhi', 'dhi', 'dhi', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
    return Instruction_UMLAL_T1_fff000f0_fbe00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfbe00060:
    // UMAAL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 'n', 'n', 'n', 'n', 'dlo', 'dlo', 'dlo', 'dlo', 'dhi', 'dhi', 'dhi', 'dhi', 0, 1, 1, 0, 'm', 'm', 'm', 'm']
    return Instruction_UMAAL_T1_fff000f0_fbe00060(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfff00f00)
  {
  case 0xe8500f00:
    // LDREX<c> <Rt>, [<Rn>{,#<imm>}] - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(1)', '(1)', '(1)', '(1)', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDREX_T1_fff00f00_e8500f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8000e00:
    // STRBT<c> <Rt>, [<Rn>, #<imm>] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_STRBT_T1_fff00f00_f8000e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8100e00:
    // LDRBT<c> <Rt>, [<Rn>, #<imm>] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRBT_T1_fff00f00_f8100e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8200e00:
    // STRHT<c> <Rt>, [<Rn>, #<imm>] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_STRHT_T1_fff00f00_f8200e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8300e00:
    // LDRHT<c> <Rt>, [<Rn>, #<imm>] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRHT_T1_fff00f00_f8300e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8400e00:
    // STRT<c> <Rt>, [<Rn>, #<imm>] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_STRT_T1_fff00f00_f8400e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8500e00:
    // LDRT<c> <Rt>, [<Rn>, #<imm>] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRT_T1_fff00f00_f8500e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf9100e00:
    // LDRSBT<c> <Rt>, [<Rn>, #<imm>] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRSBT_T1_fff00f00_f9100e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf9300e00:
    // LDRSHT<c> <Rt>, [<Rn>, #<imm>] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRSHT_T1_fff00f00_f9300e00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffb00f10)
  {
  case 0xef000110:
    // VAND<c> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VAND_T1_ffb00f10_ef000110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef100110:
    // VBIC<c> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VBIC_T1_ffb00f10_ef100110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef200110:
    // VORR<c> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VORR_T1_ffb00f10_ef200110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef300110:
    // VORN<c> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VORN_T1_ffb00f10_ef300110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff000110:
    // VEOR<c> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VEOR_T1_ffb00f10_ff000110(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfbf08f00)
  {
  case 0xf0100f00:
    // TST<c> <Rn>, #<const> - [] - [1, 1, 1, 1, 0, 'i', 0, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_TST_T1_fbf08f00_f0100f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf0900f00:
    // TEQ<c> <Rn>, #<const> - [] - [1, 1, 1, 1, 0, 'i', 0, 0, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_TEQ_T1_fbf08f00_f0900f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf1100f00:
    // CMN<c> <Rn>, #<const> - ['cond'] - [1, 1, 1, 1, 0, 'i', 0, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_CMN_T1_fbf08f00_f1100f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf1b00f00:
    // CMP<c>.W <Rn>, #<const> - ['cond'] - [1, 1, 1, 1, 0, 'i', 0, 1, 1, 0, 1, 1, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_CMP_T2_fbf08f00_f1b00f00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xff800fd0)
  {
  case 0xef800810:
    // VSHRN<c>.I<size> <Dd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VSHRN_T1_ff800fd0_ef800810(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800850:
    // VRSHRN<c>.I<size> <Dd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 0, 1, 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VRSHRN_T1_ff800fd0_ef800850(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xfff0f000) == 0xf990f000)
    // PLI<c> [<Rn>,#<imm>] - [] - [1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_PLI_T1_fff0f000_f990f000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffef8000)
  {
  case 0xea6f0000:
    // MVN{S}<c>.W <Rd>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 'S', 1, 1, 1, 1, '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
    return Instruction_MVN_T2_ffef8000_ea6f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeb0d0000:
    // ADD{S}<c>.W <Rd>, SP, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 'S', 1, 1, 0, 1, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
    return Instruction_ADD_T3_ffef8000_eb0d0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xebad0000:
    // SUB{S}<c> <Rd>, SP, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 'S', 1, 1, 0, 1, '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
    return Instruction_SUB_T1_ffef8000_ebad0000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffb00e50)
  {
  case 0xee200a00:
    // VMUL<c>.F64 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 0, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VMUL_T2_ffb00e50_ee200a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xee200a40:
    // VNMUL<c>.F64 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 0, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VNMUL_T2_ffb00e50_ee200a40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xee300a00:
    // VADD<c>.F64 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 0, 'D', 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VADD_T2_ffb00e50_ee300a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xee300a40:
    // VSUB<c>.F64 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 0, 'D', 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VSUB_T2_ffb00e50_ee300a40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xee800a00:
    // VDIV<c>.F64 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VDIV_T1_ffb00e50_ee800a00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfbff8000)
  {
  case 0xf20d0000:
    // ADDW<c> <Rd>, SP, #<imm> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_ADDW_T4_fbff8000_f20d0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf20f0000:
    // ADR<c>.W <Rd>, <label> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_ADR_T3_fbff8000_f20f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2ad0000:
    // SUBW<c> <Rd>, SP, #<imm> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_SUBW_T3_fbff8000_f2ad0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2af0000:
    // SUB <Rd>, PC, #0 - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_SUB_T2_fbff8000_f2af0000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode16 & 0x0000ffff)
  {
  case 0x0000bf00:
    // NOP<c> - [] - [1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]
    return Instruction_NOP_T1_0000ffff_0000bf00(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000bf10:
    // YIELD<c> - [] - [1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0]
    return Instruction_YIELD_T1_0000ffff_0000bf10(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000bf20:
    // WFE<c> - [] - [1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0]
    return Instruction_WFE_T1_0000ffff_0000bf20(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000bf30:
    // WFI<c> - [] - [1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0]
    return Instruction_WFI_T1_0000ffff_0000bf30(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000bf40:
    // SEV<c> - [] - [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0]
    return Instruction_SEV_T1_0000ffff_0000bf40(rBinStrm, Offset, Opcode16, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfff000e0)
  {
  case 0xfb200000:
    // SMLAD{X}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 'a', 'a', 'a', 'a', 'd', 'd', 'd', 'd', 0, 0, 0, 'M', 'm', 'm', 'm', 'm']
    return Instruction_SMLAD_T1_fff000e0_fb200000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb300000:
    // SMLAW<y><c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 'a', 'a', 'a', 'a', 'd', 'd', 'd', 'd', 0, 0, 0, 'M', 'm', 'm', 'm', 'm']
    return Instruction_SMLAW_T1_fff000e0_fb300000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb400000:
    // SMLSD{X}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 'n', 'n', 'n', 'n', 'a', 'a', 'a', 'a', 'd', 'd', 'd', 'd', 0, 0, 0, 'M', 'm', 'm', 'm', 'm']
    return Instruction_SMLSD_T1_fff000e0_fb400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb500000:
    // SMMLA{R}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 'a', 'a', 'a', 'a', 'd', 'd', 'd', 'd', 0, 0, 0, 'R', 'm', 'm', 'm', 'm']
    return Instruction_SMMLA_T1_fff000e0_fb500000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfb600000:
    // SMMLS{R}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 'n', 'n', 'n', 'n', 'a', 'a', 'a', 'a', 'd', 'd', 'd', 'd', 0, 0, 0, 'R', 'm', 'm', 'm', 'm']
    return Instruction_SMMLS_T1_fff000e0_fb600000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfbc000c0:
    // SMLALD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 'dlo', 'dlo', 'dlo', 'dlo', 'dhi', 'dhi', 'dhi', 'dhi', 1, 1, 0, 'M', 'm', 'm', 'm', 'm']
    return Instruction_SMLALD_T1_fff000e0_fbc000c0(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfbd000c0:
    // SMLSLD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 'dlo', 'dlo', 'dlo', 'dlo', 'dhi', 'dhi', 'dhi', 'dhi', 1, 1, 0, 'M', 'm', 'm', 'm', 'm']
    return Instruction_SMLSLD_T1_fff000e0_fbd000c0(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffb00e10)
  {
  case 0xee000a00:
    // V<op><c>.F64 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 0, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 'op', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_V_T2_ffb00e10_ee000a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xee100a00:
    // VNMLA<c>.F64 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 0, 'D', 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 'op', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VNMLA_T1_ffb00e10_ee100a00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xff7f0000)
  {
  case 0xf81f0000:
    // LDRB<c> <Rt>, [PC,#-0] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 'U', 0, 0, 1, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRB_T1_ff7f0000_f81f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf83f0000:
    // LDRH<c> <Rt>, [PC,#-0] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 'U', 0, 1, 1, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRH_T1_ff7f0000_f83f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf85f0000:
    // LDR<c>.W <Rt>, [PC,#-0] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 'U', 1, 0, 1, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDR_T2_ff7f0000_f85f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf91f0000:
    // LDRSB<c> <Rt>, [PC,#-0] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 1, 'U', 0, 0, 1, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRSB_T1_ff7f0000_f91f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf93f0000:
    // LDRSH<c> <Rt>, [PC,#-0] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 1, 'U', 0, 1, 1, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRSH_T1_ff7f0000_f93f0000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffa00f10)
  {
  case 0xef000d00:
    // VADD<c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VADD_T1_ffa00f10_ef000d00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000e00:
    // VCEQ<c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCEQ_T2_ffa00f10_ef000e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000f10:
    // VRECPS<c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VRECPS_T1_ffa00f10_ef000f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef200d00:
    // VSUB<c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 1, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VSUB_T1_ffa00f10_ef200d00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef200f10:
    // VRSQRTS<c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 1, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VRSQRTS_T1_ffa00f10_ef200f10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff000d00:
    // VPADD<c>.F32 - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VPADD_T1_ffa00f10_ff000d00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff000d10:
    // VMUL<c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VMUL_T1_ffa00f10_ff000d10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff000e00:
    // VCGE<c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCGE_T2_ffa00f10_ff000e00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff200d00:
    // VABD<c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 1, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VABD_T1_ffa00f10_ff200d00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff200e00:
    // VCGT<c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 1, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCGT_T2_ffa00f10_ff200e00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xef800fd0) == 0xef800a10)
    // VSHLL<c>.<type_4><size> <Qd>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VSHLL_T1_ef800fd0_ef800a10(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xffd0f000) == 0xf890f000)
    // PLD{R}<c> [<Rn>, #<imm>] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 'R', 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_PLD_T1_ffd0f000_f890f000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xff800f50)
  {
  case 0xef800400:
    // VADDHN<c>.<dt> <Dd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VADDHN_T1_ff800f50_ef800400(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800600:
    // VSUBHN<c>.<dt> <Dd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VSUBHN_T1_ff800f50_ef800600(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800b40:
    // VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQDMULL_T2_ff800f50_ef800b40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800d00:
    // VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQDMULL_T1_ff800f50_ef800d00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff800400:
    // VRADDHN<c>.<dt> <Dd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VRADDHN_T1_ff800f50_ff800400(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff800600:
    // VRSUBHN<c>.<dt> <Dd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VRSUBHN_T1_ff800f50_ff800600(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffb00f00) == 0xf9a00c00)
    // VLD1<c>.<size> <list>, [<Rn>{@<align>}]{!} - ['support_it_block'] - [1, 1, 1, 1, 1, 0, 0, 1, 1, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 0, 'i', 'i', 'T', 'A', 'm', 'm', 'm', 'm']
    return Instruction_VLD1_T1_ffb00f00_f9a00c00(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfbef8000)
  {
  case 0xf04f0000:
    // MOV{S}<c>.W <Rd>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 0, 0, 1, 0, 'S', 1, 1, 1, 1, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_MOV_T2_fbef8000_f04f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf06f0000:
    // MVN{S}<c> <Rd>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 0, 0, 1, 1, 'S', 1, 1, 1, 1, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_MVN_T1_fbef8000_f06f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf10d0000:
    // ADD{S}<c>.W <Rd>, SP, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 1, 0, 0, 0, 'S', 1, 1, 0, 1, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_ADD_T3_fbef8000_f10d0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf1ad0000:
    // SUB{S}<c>.W <Rd>, SP, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 1, 1, 0, 1, 'S', 1, 1, 0, 1, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_SUB_T2_fbef8000_f1ad0000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode16 & 0x0000fff7) == 0x0000b650)
    // SETEND <endian_specifier> - [] - [1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, '(1)', 'E', '(0)', '(0)', '(0)']
    return Instruction_SETEND_T1_0000fff7_0000b650(rBinStrm, Offset, Opcode16, rInsn);
  if ((Opcode32 & 0xfff08010) == 0xeac00000)
    // PKHTB<c> <Rd>, <Rn>, <Rm>{,ASR #<imm>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tb', 0, 'm', 'm', 'm', 'm']
    return Instruction_PKHTB_T1_fff08010_eac00000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfff08020)
  {
  case 0xf3400000:
    // SBFX<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - [1, 1, 1, 1, 0, '(0)', 1, 1, 0, 1, 0, 0, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', '(0)', 'widthm1', 'widthm1', 'widthm1', 'widthm1', 'widthm1']
    return Instruction_SBFX_T1_fff08020_f3400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3600000:
    // BFI<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - [1, 1, 1, 1, 0, '(0)', 1, 1, 0, 1, 1, 0, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', '(0)', 'msb', 'msb', 'msb', 'msb', 'msb']
    return Instruction_BFI_T1_fff08020_f3600000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3c00000:
    // UBFX<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - [1, 1, 1, 1, 0, '(0)', 1, 1, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', '(0)', 'widthm1', 'widthm1', 'widthm1', 'widthm1', 'widthm1']
    return Instruction_UBFX_T1_fff08020_f3c00000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffb00c10) == 0xffb00800)
    // V<op><c>.8 <Dd>, <list>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 'len', 'len', 'N', 'op', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_V_T1_ffb00c10_ffb00800(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xff300f00)
  {
  case 0xed000a00:
    // VSTR<c> <Sd>, [<Rn>{,#+/-<imm>}] - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 1, 'U', 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_VSTR_T2_ff300f00_ed000a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xed000b00:
    // VSTR<c> <Dd>, [<Rn>{,#+/-<imm>}] - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 1, 'U', 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_VSTR_T1_ff300f00_ed000b00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xed100a00:
    // VLDR<c> <Sd>, [<Rn>{,#+/-<imm>}] - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 1, 'U', 'D', 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_VLDR_T2_ff300f00_ed100a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xed100b00:
    // VLDR<c> <Dd>, [<Rn>{,#+/-<imm>}] - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 1, 'U', 'D', 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_VLDR_T1_ff300f00_ed100b00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfff000c0)
  {
  case 0xfb100000:
    // SMLA<x><y><c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 'a', 'a', 'a', 'a', 'd', 'd', 'd', 'd', 0, 0, 'N', 'M', 'm', 'm', 'm', 'm']
    return Instruction_SMLA_T1_fff000c0_fb100000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfbc00080:
    // SMLAL<x><y><c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 'dlo', 'dlo', 'dlo', 'dlo', 'dhi', 'dhi', 'dhi', 'dhi', 1, 0, 'N', 'M', 'm', 'm', 'm', 'm']
    return Instruction_SMLAL_T1_fff000c0_fbc00080(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xef800ed0)
  {
  case 0xef800810:
    // VQSHR{op}N<c>.<type_4><size> <Dd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 0, 'op', 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VQSHR_T1_ef800ed0_ef800810(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800850:
    // VQRSHR{op}N<c>.<type_4><size> <Dd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 0, 'op', 0, 1, 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VQRSHR_T1_ef800ed0_ef800850(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xefb800b0)
  {
  case 0xef800010:
    // VORR<c>.<dt> <Qd>, #<imm> - ['support_it_block'] - [1, 1, 1, 'i', 1, 1, 1, 1, 1, 'D', 0, 0, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'cmode', 'cmode', 'cmode', 'cmode', 0, 'Q', 0, 1, 'i', 'i', 'i', 'i']
    return Instruction_VORR_T1_efb800b0_ef800010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800030:
    // VBIC<c>.<dt> <Qd>, #<imm> - ['support_it_block'] - [1, 1, 1, 'i', 1, 1, 1, 1, 1, 'D', 0, 0, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'cmode', 'cmode', 'cmode', 'cmode', 0, 'Q', 1, 1, 'i', 'i', 'i', 'i']
    return Instruction_VBIC_T1_efb800b0_ef800030(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xff800f10)
  {
  case 0xef000800:
    // VADD<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VADD_T1_ff800f10_ef000800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000810:
    // VTST<c>.<size> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VTST_T1_ff800f10_ef000810(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000b00:
    // VQDMULH<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQDMULH_T1_ff800f10_ef000b00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000b10:
    // VPADD<c>.<dt> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VPADD_T1_ff800f10_ef000b10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000d10:
    // V<op><c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 'op', 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_V_T1_ff800f10_ef000d10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000f00:
    // V<op><c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 'op', 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_V_T1_ff800f10_ef000f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800510:
    // VSHL<c>.I<size> <Qd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VSHL_T1_ff800f10_ef800510(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff000800:
    // VSUB<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VSUB_T1_ff800f10_ff000800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff000810:
    // VCEQ<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VCEQ_T1_ff800f10_ff000810(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff000b00:
    // VQRDMULH<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQRDMULH_T1_ff800f10_ff000b00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff000110:
    // V<op><c> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 'op', 'op', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_V_T1_ff800f10_ff000110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff000e10:
    // V<op><c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 'op', 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_V_T1_ff800f10_ff000e10(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff000f00:
    // VP<op><c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 'op', 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VP_T1_ff800f10_ff000f00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff800410:
    // VSRI<c>.<size> <Qd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VSRI_T1_ff800f10_ff800410(rBinStrm, Offset, Opcode32, rInsn);
  case 0xff800510:
    // VSLI<c>.<size> <Qd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VSLI_T1_ff800f10_ff800510(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xff800b50) == 0xef800340)
    // VQD<op><c>.<dt> <Qd>, <Dn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 'op', 1, 1, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQD_T2_ff800b50_ef800340(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xfe7f0000) == 0xe85f0000)
    // LDRD<c> <Rt>, <Rt2>, [PC,#-0] - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 0, 'P', 'U', 1, '(0)', 1, 1, 1, 1, 1, 't', 't', 't', 't', 't2', 't2', 't2', 't2', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRD_T1_fe7f0000_e85f0000(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xff800d50) == 0xef800900)
    // VQD<op><c>.<dt> <Qd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 'op', 1, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQD_T1_ff800d50_ef800900(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xef800f50)
  {
  case 0xef800c40:
    // VQDMULH<c>.<dt> <Qd>, <Qn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 'Q', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 0, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQDMULH_T2_ef800f50_ef800c40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800d40:
    // VQRDMULH<c>.<dt> <Qd>, <Qn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 'Q', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VQRDMULH_T2_ef800f50_ef800d40(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800500:
    // VABAL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VABAL_T2_ef800f50_ef800500(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800700:
    // VABDL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 1, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VABDL_T2_ef800f50_ef800700(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800a40:
    // VMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VMULL_T2_ef800f50_ef800a40(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffb00300)
  {
  case 0xf9800000:
    // VST1<c>.<size> <list>, [<Rn>{@<align>}]{!} - ['support_it_block'] - [1, 1, 1, 1, 1, 0, 0, 1, 1, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 0, 0, 'index_align', 'index_align', 'index_align', 'index_align', 'm', 'm', 'm', 'm']
    return Instruction_VST1_T1_ffb00300_f9800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf9a00000:
    // VLD1<c>.<size> <list>, [<Rn>{@<align>}]{!} - ['support_it_block'] - [1, 1, 1, 1, 1, 0, 0, 1, 1, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 0, 0, 'index_align', 'index_align', 'index_align', 'index_align', 'm', 'm', 'm', 'm']
    return Instruction_VLD1_T1_ffb00300_f9a00000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfff00800)
  {
  case 0xf8000800:
    // STRB<c> <Rt>, [<Rn>, #<imm>]! - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 'P', 'U', 'W', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_STRB_T3_fff00800_f8000800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8100800:
    // LDRB<c> <Rt>, [<Rn>, #<imm>]! - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 'P', 'U', 'W', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRB_T3_fff00800_f8100800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8200800:
    // STRH<c> <Rt>, [<Rn>, #<imm>]! - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 'P', 'U', 'W', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_STRH_T3_fff00800_f8200800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8300800:
    // LDRH<c> <Rt>, [<Rn>, #<imm>]! - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 'P', 'U', 'W', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRH_T3_fff00800_f8300800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8400800:
    // STR<c> <Rt>, [<Rn>, #<imm>]! - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 'P', 'U', 'W', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_STR_T4_fff00800_f8400800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8500800:
    // LDR<c> <Rt>, [<Rn>, #<imm>]! - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 'P', 'U', 'W', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDR_T4_fff00800_f8500800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf9100800:
    // LDRSB<c> <Rt>, [<Rn>, #<imm>]! - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 'P', 'U', 'W', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRSB_T2_fff00800_f9100800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf9300800:
    // LDRSH<c> <Rt>, [<Rn>, #<imm>]! - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 'P', 'U', 'W', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRSH_T2_fff00800_f9300800(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffd08020)
  {
  case 0xf3000000:
    // SSAT<c> <Rd>, #<imm>, <Rn>{,<shift>} - ['could_jmp'] - [1, 1, 1, 1, 0, '(0)', 1, 1, 0, 0, 'sh', 0, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', '(0)', 'sat_imm_5', 'sat_imm_5', 'sat_imm_5', 'sat_imm_5', 'sat_imm_5']
    return Instruction_SSAT_T1_ffd08020_f3000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf3800000:
    // USAT<c> <Rd>, #<imm5>, <Rn>{,<shift>} - ['could_jmp'] - [1, 1, 1, 1, 0, '(0)', 1, 1, 1, 0, 'sh', 0, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', '(0)', 'sat_imm_5', 'sat_imm_5', 'sat_imm_5', 'sat_imm_5', 'sat_imm_5']
    return Instruction_USAT_T1_ffd08020_f3800000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xef800b50) == 0xef800240)
    // V<op>L<c>.<dt> <Qd>, <Dn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 'op', 1, 0, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_V_T2_ef800b50_ef800240(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xefb80090) == 0xef800010)
    // VMOV<c>.<dt> <Qd>, #<imm> - ['support_it_block'] - [1, 1, 1, 'i', 1, 1, 1, 1, 1, 'D', 0, 0, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'cmode', 'cmode', 'cmode', 'cmode', 0, 'Q', 'op', 1, 'i', 'i', 'i', 'i']
    return Instruction_VMOV_T1_efb80090_ef800010(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xef800d50)
  {
  case 0xef800800:
    // V<op>L<c>.<dt> <Qd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 'op', 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_V_T2_ef800d50_ef800800(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800c00:
    // VMULL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 'op', 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VMULL_T2_ef800d50_ef800c00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xef800e50)
  {
  case 0xef800840:
    // VMUL<c>.<dt> <Qd>, <Qn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 'Q', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 'F', 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VMUL_T1_ef800e50_ef800840(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800000:
    // VADDL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 'op', 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VADDL_T1_ef800e50_ef800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800200:
    // VSUBL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 1, 'op', 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VSUBL_T1_ef800e50_ef800200(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffd0a000)
  {
  case 0xe8800000:
    // STM<c>.W <Rn>{!},<registers> - [] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 'W', 0, 'n', 'n', 'n', 'n', '(0)', 'M', '(0)', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
    return Instruction_STM_T2_ffd0a000_e8800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xe9000000:
    // STMDB<c> <Rn>{!},<registers> - [] - [1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 'W', 0, 'n', 'n', 'n', 'n', '(0)', 'M', '(0)', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
    return Instruction_STMDB_T1_ffd0a000_e9000000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xef800e90) == 0xef800e10)
    // VCVT<c>.<Td>.<Tm> <Qd>, <Qm>, #<fbits> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 1, 1, 'op', 0, 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VCVT_T1_ef800e90_ef800e10(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xef800f10)
  {
  case 0xef000010:
    // VQADD<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VQADD_T1_ef800f10_ef000010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000100:
    // VRHADD<c> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VRHADD_T1_ef800f10_ef000100(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000210:
    // VQSUB<c>.<type_4><size> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VQSUB_T1_ef800f10_ef000210(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000300:
    // VCGT<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VCGT_T1_ef800f10_ef000300(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000310:
    // VCGE<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 1, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VCGE_T1_ef800f10_ef000310(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000400:
    // VSHL<c>.I<size> <Qd>, <Qm>, <Qn> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VSHL_T1_ef800f10_ef000400(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000410:
    // VQSHL<c>.<type_4><size> <Qd>, <Qm>, <Qn> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VQSHL_T1_ef800f10_ef000410(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000500:
    // VRSHL<c>.<type_4><size> <Qd>, <Qm>, <Qn> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VRSHL_T1_ef800f10_ef000500(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000510:
    // VQRSHL<c>.<type><size> <Qd>, <Qm>, <Qn> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VQRSHL_T1_ef800f10_ef000510(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000700:
    // VABD<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VABD_T1_ef800f10_ef000700(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000710:
    // VABA<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VABA_T1_ef800f10_ef000710(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800010:
    // VSHR<c>.<type_4><size> <Qd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VSHR_T1_ef800f10_ef800010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800110:
    // VSRA<c>.<type_4><size> <Qd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VSRA_T1_ef800f10_ef800110(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800210:
    // VRSHR<c>.<type_4><size> <Qd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VRSHR_T1_ef800f10_ef800210(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef800310:
    // VRSRA<c>.<type_4><size> <Qd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 0, 1, 1, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VRSRA_T1_ef800f10_ef800310(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000900:
    // V<op><c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'op', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_V_T1_ef800f10_ef000900(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000910:
    // VMUL<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'op', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VMUL_T1_ef800f10_ef000910(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffe08000)
  {
  case 0xea000000:
    // AND{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 'S', 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
    return Instruction_AND_T2_ffe08000_ea000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xea200000:
    // BIC{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 'S', 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
    return Instruction_BIC_T2_ffe08000_ea200000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xea400000:
    // ORR{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 'S', 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
    return Instruction_ORR_T2_ffe08000_ea400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xea600000:
    // ORN{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 'S', 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
    return Instruction_ORN_T1_ffe08000_ea600000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xea800000:
    // EOR{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 'S', 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
    return Instruction_EOR_T2_ffe08000_ea800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeb000000:
    // ADD{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 'S', 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
    return Instruction_ADD_T3_ffe08000_eb000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeb400000:
    // ADC{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 'S', 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
    return Instruction_ADC_T2_ffe08000_eb400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeb600000:
    // SBC{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 'S', 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
    return Instruction_SBC_T2_ffe08000_eb600000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xeba00000:
    // SUB{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 'S', 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
    return Instruction_SUB_T2_ffe08000_eba00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xebc00000:
    // RSB{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 'S', 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
    return Instruction_RSB_T1_ffe08000_ebc00000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xef800d10) == 0xef000000)
    // VH<op><c> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 'op', 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VH_T1_ef800d10_ef000000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfff00000)
  {
  case 0xe8400000:
    // STREX<c> <Rd>, <Rt>, [<Rn>{,#<imm>}] - [] - [1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_STREX_T1_fff00000_e8400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xec400000:
    // MCRR<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm> - ['support_it_block', 'could_jmp'] - [1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 't2', 't2', 't2', 't2', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc1', 'opc1', 'opc1', 'opc1', 'm', 'm', 'm', 'm']
    return Instruction_MCRR_T1_fff00000_ec400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xec500000:
    // MRRC<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm> - ['support_it_block', 'could_jmp'] - [1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 't2', 't2', 't2', 't2', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc1', 'opc1', 'opc1', 'opc1', 'm', 'm', 'm', 'm']
    return Instruction_MRRC_T1_fff00000_ec500000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8800000:
    // STRB<c>.W <Rt>, [<Rn>, #<imm>] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_STRB_T2_fff00000_f8800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8900000:
    // LDRB<c>.W <Rt>, [<Rn>{,#<imm>}] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRB_T2_fff00000_f8900000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8a00000:
    // STRH<c>.W <Rt>, [<Rn>{,#<imm>}] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_STRH_T2_fff00000_f8a00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8b00000:
    // LDRH<c>.W <Rt>, [<Rn>{,#<imm>}] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRH_T2_fff00000_f8b00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8c00000:
    // STR<c>.W <Rt>, [<Rn>, #<imm>] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_STR_T3_fff00000_f8c00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf8d00000:
    // LDR<c>.W <Rt>, [<Rn>{,#<imm>}] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDR_T3_fff00000_f8d00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf9900000:
    // LDRSB<c> <Rt>, [<Rn>, #<imm>] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRSB_T1_fff00000_f9900000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf9b00000:
    // LDRSH<c> <Rt>, [<Rn>, #<imm>] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRSH_T1_fff00000_f9b00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfc400000:
    // MCRR2<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm> - ['support_it_block', 'could_jmp'] - [1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 't2', 't2', 't2', 't2', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc1', 'opc1', 'opc1', 'opc1', 'm', 'm', 'm', 'm']
    return Instruction_MCRR2_T2_fff00000_fc400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfc500000:
    // MRRC2<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm> - ['support_it_block', 'could_jmp'] - [1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 't2', 't2', 't2', 't2', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc1', 'opc1', 'opc1', 'opc1', 'm', 'm', 'm', 'm']
    return Instruction_MRRC2_T2_fff00000_fc500000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xffb00010) == 0xefb00000)
    // VEXT<c>.8 <Qd>, <Qn>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 1, 'D', 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_VEXT_T1_ffb00010_efb00000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfe100f00)
  {
  case 0xec000a00:
    // VSTM{mode}<c> <Rn>{!}, <list> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 'P', 'U', 'D', 'W', 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_VSTM_T2_fe100f00_ec000a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xec000b00:
    // VSTM{mode}<c> <Rn>{!}, <list> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 'P', 'U', 'D', 'W', 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_VSTM_T1_fe100f00_ec000b00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xec100a00:
    // VLDM{mode}<c> <Rn>{!}, <list> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 'P', 'U', 'D', 'W', 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_VLDM_T2_fe100f00_ec100a00(rBinStrm, Offset, Opcode32, rInsn);
  case 0xec100b00:
    // VLDM{mode}<c> <Rn>{!}, <list> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 'P', 'U', 'D', 'W', 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_VLDM_T1_fe100f00_ec100b00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfbf08000)
  {
  case 0xf2000000:
    // ADDW<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 1, 0, 0, 0, 0, 0, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_ADDW_T4_fbf08000_f2000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2400000:
    // MOVW<c> <Rd>, #<imm> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 1, 0, 0, 1, 0, 0, 'i', 'i', 'i', 'i', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_MOVW_T3_fbf08000_f2400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2a00000:
    // SUBW<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 1, 0, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_SUBW_T4_fbf08000_f2a00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf2c00000:
    // MOVT<c> <Rd>, #<imm> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 1, 0, 1, 1, 0, 0, 'i', 'i', 'i', 'i', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_MOVT_T1_fbf08000_f2c00000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xffd02000)
  {
  case 0xe8900000:
    // LDM<c>.W <Rn>{!},<registers> - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 'W', 1, 'n', 'n', 'n', 'n', 'P', 'M', '(0)', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
    return Instruction_LDM_T2_ffd02000_e8900000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xe9100000:
    // LDMDB<c> <Rn>{!},<registers> - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 'W', 1, 'n', 'n', 'n', 'n', 'P', 'M', '(0)', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
    return Instruction_LDMDB_T1_ffd02000_e9100000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xef800f00)
  {
  case 0xef000600:
    // V<op><c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'N', 'Q', 'M', 'op', 'm', 'm', 'm', 'm']
    return Instruction_V_T1_ef800f00_ef000600(rBinStrm, Offset, Opcode32, rInsn);
  case 0xef000a00:
    // VP<op><c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'N', 'Q', 'M', 'op', 'm', 'm', 'm', 'm']
    return Instruction_VP_T1_ef800f00_ef000a00(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode16 & 0x0000ff78) == 0x00004468)
    // ADD<c> <Rdm>, SP - ['could_jmp'] - [0, 1, 0, 0, 0, 1, 0, 0, 'DM', 1, 1, 0, 1, 'dm', 'dm', 'dm']
    return Instruction_ADD_T1_0000ff78_00004468(rBinStrm, Offset, Opcode16, rInsn);
  switch (Opcode16 & 0x0000ff87)
  {
  case 0x00004485:
    // ADD<c> SP,<Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 1, 0, 0, 1, 'm', 'm', 'm', 'm', 1, 0, 1]
    return Instruction_ADD_T2_0000ff87_00004485(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004700:
    // BX<c> <Rm> - ['call'] - [0, 1, 0, 0, 0, 1, 1, 1, 0, 'm', 'm', 'm', 'm', '(0)', '(0)', '(0)']
    return Instruction_BX_T1_0000ff87_00004700(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004780:
    // BLX<c> <Rm> - ['call'] - [0, 1, 0, 0, 0, 1, 1, 1, 1, 'm', 'm', 'm', 'm', '(0)', '(0)', '(0)']
    return Instruction_BLX_T1_0000ff87_00004780(rBinStrm, Offset, Opcode16, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfe1f0000)
  {
  case 0xec1f0000:
    // LDC{L}<c> <coproc>, <CRd>, <label> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 'P', 'U', 'D', 'W', 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDC_T1_fe1f0000_ec1f0000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfc1f0000:
    // LDC2{L}<c> <coproc>, <CRd>, <label> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 0, 'P', 'U', 'D', 'W', 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDC2_T2_fe1f0000_fc1f0000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xef800e10) == 0xef800610)
    // VQSHL{op}<c>.<type_4><size> <Qd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 1, 1, 'op', 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
    return Instruction_VQSHL_T1_ef800e10_ef800610(rBinStrm, Offset, Opcode32, rInsn);
  if ((Opcode32 & 0xef800a50) == 0xef800040)
    // V<op><c>.<dt> <Qd>, <Qn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 'Q', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 'op', 0, 'F', 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
    return Instruction_V_T1_ef800a50_ef800040(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xffb00000)
  {
  case 0xf9000000:
    // VST1<c>.<size> <list>, [<Rn>{@<align>}]{!} - ['support_it_block'] - [1, 1, 1, 1, 1, 0, 0, 1, 0, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'tp', 'tp', 'tp', 'tp', 'i', 'i', 'align', 'align', 'm', 'm', 'm', 'm']
    return Instruction_VST1_T1_ffb00000_f9000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf9200000:
    // VLD1<c>.<size> <list>, [<Rn>{@<align>}]{!} - ['support_it_block'] - [1, 1, 1, 1, 1, 0, 0, 1, 0, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'tp', 'tp', 'tp', 'tp', 'i', 'i', 'align', 'align', 'm', 'm', 'm', 'm']
    return Instruction_VLD1_T1_ffb00000_f9200000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfbe08000)
  {
  case 0xf0000000:
    // AND{S}<c> <Rd>, <Rn>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 0, 0, 0, 0, 'S', 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_AND_T1_fbe08000_f0000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf0200000:
    // BIC{S}<c> <Rd>, <Rn>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 0, 0, 0, 1, 'S', 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_BIC_T1_fbe08000_f0200000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf0400000:
    // ORR{S}<c> <Rd>, <Rn>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 0, 0, 1, 0, 'S', 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_ORR_T1_fbe08000_f0400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf0600000:
    // ORN{S}<c> <Rd>, <Rn>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 0, 0, 1, 1, 'S', 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_ORN_T1_fbe08000_f0600000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf0800000:
    // EOR{S}<c> <Rd>, <Rn>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 0, 1, 0, 0, 'S', 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_EOR_T1_fbe08000_f0800000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf1000000:
    // ADD{S}<c>.W <Rd>, <Rn>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 1, 0, 0, 0, 'S', 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_ADD_T3_fbe08000_f1000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf1400000:
    // ADC{S}<c> <Rd>, <Rn>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 1, 0, 1, 0, 'S', 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_ADC_T1_fbe08000_f1400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf1600000:
    // SBC{S}<c> <Rd>, <Rn>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 1, 0, 1, 1, 'S', 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_SBC_T1_fbe08000_f1600000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf1a00000:
    // SUB{S}<c>.W <Rd>, <Rn>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 1, 1, 0, 1, 'S', 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_SUB_T3_fbe08000_f1a00000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf1c00000:
    // RSB{S}<c>.W <Rd>, <Rn>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 1, 1, 1, 0, 'S', 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_RSB_T2_fbe08000_f1c00000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode16 & 0x0000ffc0)
  {
  case 0x00000000:
    // MOVS <Rd>, <Rm> - ['could_jmp'] - [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'm', 'm', 'm', 'd', 'd', 'd']
    return Instruction_MOVS_T2_0000ffc0_00000000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004000:
    // ANDS <Rdn>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 'm', 'm', 'm', 'dn', 'dn', 'dn']
    return Instruction_ANDS_T1_0000ffc0_00004000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004040:
    // EORS <Rdn>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 'm', 'm', 'm', 'dn', 'dn', 'dn']
    return Instruction_EORS_T1_0000ffc0_00004040(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004080:
    // LSLS <Rdn>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 'm', 'm', 'm', 'dn', 'dn', 'dn']
    return Instruction_LSLS_T1_0000ffc0_00004080(rBinStrm, Offset, Opcode16, rInsn);
  case 0x000040c0:
    // LSRS <Rdn>, <Rm> - ['support_it_block', 'could_jmp'] - [0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 'm', 'm', 'm', 'dn', 'dn', 'dn']
    return Instruction_LSRS_T1_0000ffc0_000040c0(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004100:
    // ASRS <Rdn>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 'm', 'm', 'm', 'dn', 'dn', 'dn']
    return Instruction_ASRS_T1_0000ffc0_00004100(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004140:
    // ADCS <Rdn>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 'm', 'm', 'm', 'dn', 'dn', 'dn']
    return Instruction_ADCS_T1_0000ffc0_00004140(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004180:
    // SBCS <Rdn>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 'm', 'm', 'm', 'dn', 'dn', 'dn']
    return Instruction_SBCS_T1_0000ffc0_00004180(rBinStrm, Offset, Opcode16, rInsn);
  case 0x000041c0:
    // RORS <Rdn>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 'm', 'm', 'm', 'dn', 'dn', 'dn']
    return Instruction_RORS_T1_0000ffc0_000041c0(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004200:
    // TST<c> <Rn>, <Rm> - [] - [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 'm', 'm', 'm', 'n', 'n', 'n']
    return Instruction_TST_T1_0000ffc0_00004200(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004240:
    // RSBS <Rd>, <Rn>, #0 - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 'n', 'n', 'n', 'd', 'd', 'd']
    return Instruction_RSBS_T1_0000ffc0_00004240(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004280:
    // CMP<c> <Rn>, <Rm> - ['cond'] - [0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 'm', 'm', 'm', 'n', 'n', 'n']
    return Instruction_CMP_T1_0000ffc0_00004280(rBinStrm, Offset, Opcode16, rInsn);
  case 0x000042c0:
    // CMN<c> <Rn>, <Rm> - ['cond'] - [0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 'm', 'm', 'm', 'n', 'n', 'n']
    return Instruction_CMN_T1_0000ffc0_000042c0(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004300:
    // ORRS <Rdn>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 'm', 'm', 'm', 'dn', 'dn', 'dn']
    return Instruction_ORRS_T1_0000ffc0_00004300(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004340:
    // MULS <Rdm>, <Rn> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'dm', 'dm', 'dm']
    return Instruction_MULS_T1_0000ffc0_00004340(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004380:
    // BICS <Rdn>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 'm', 'm', 'm', 'dn', 'dn', 'dn']
    return Instruction_BICS_T1_0000ffc0_00004380(rBinStrm, Offset, Opcode16, rInsn);
  case 0x000043c0:
    // MVNS <Rd>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 'm', 'm', 'm', 'd', 'd', 'd']
    return Instruction_MVNS_T1_0000ffc0_000043c0(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000b200:
    // SXTH<c> <Rd>, <Rm> - ['could_jmp'] - [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 'm', 'm', 'm', 'd', 'd', 'd']
    return Instruction_SXTH_T1_0000ffc0_0000b200(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000b240:
    // SXTB<c> <Rd>, <Rm> - ['could_jmp'] - [1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 'm', 'm', 'm', 'd', 'd', 'd']
    return Instruction_SXTB_T1_0000ffc0_0000b240(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000b280:
    // UXTH<c> <Rd>, <Rm> - ['could_jmp'] - [1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 'm', 'm', 'm', 'd', 'd', 'd']
    return Instruction_UXTH_T1_0000ffc0_0000b280(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000b2c0:
    // UXTB<c> <Rd>, <Rm> - ['could_jmp'] - [1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 'm', 'm', 'm', 'd', 'd', 'd']
    return Instruction_UXTB_T1_0000ffc0_0000b2c0(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000ba00:
    // REV<c> <Rd>, <Rm> - ['could_jmp'] - [1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 'm', 'm', 'm', 'd', 'd', 'd']
    return Instruction_REV_T1_0000ffc0_0000ba00(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000ba40:
    // REV16<c> <Rd>, <Rm> - ['could_jmp'] - [1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 'm', 'm', 'm', 'd', 'd', 'd']
    return Instruction_REV16_T1_0000ffc0_0000ba40(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000bac0:
    // REVSH<c> <Rd>, <Rm> - ['could_jmp'] - [1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 'm', 'm', 'm', 'd', 'd', 'd']
    return Instruction_REVSH_T1_0000ffc0_0000bac0(rBinStrm, Offset, Opcode16, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xff100010)
  {
  case 0xee000010:
    // MCR<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['support_it_block', 'could_jmp'] - [1, 1, 1, 0, 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 1, 'm', 'm', 'm', 'm']
    return Instruction_MCR_T1_ff100010_ee000010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xee100010:
    // MRC<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['support_it_block', 'could_jmp'] - [1, 1, 1, 0, 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 1, 'm', 'm', 'm', 'm']
    return Instruction_MRC_T1_ff100010_ee100010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfe000010:
    // MCR2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['support_it_block', 'could_jmp'] - [1, 1, 1, 1, 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 1, 'm', 'm', 'm', 'm']
    return Instruction_MCR2_T2_ff100010_fe000010(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfe100010:
    // MRC2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['support_it_block', 'could_jmp'] - [1, 1, 1, 1, 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 1, 'm', 'm', 'm', 'm']
    return Instruction_MRC2_T2_ff100010_fe100010(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  if ((Opcode32 & 0xf800d001) == 0xf000c000)
    // BLX<c> <label> - ['thumb_branch_label'] - [1, 1, 1, 1, 0, 'S', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 1, 1, 'J1', 0, 'J2', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 0]
    return Instruction_BLX_T2_f800d001_f000c000(rBinStrm, Offset, Opcode32, rInsn);
  switch (Opcode32 & 0xfe500000)
  {
  case 0xe8400000:
    // STRD<c> <Rt>, <Rt2>, [<Rn>, #+/-<imm>]! - [] - [1, 1, 1, 0, 1, 0, 0, 'P', 'U', 1, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 't2', 't2', 't2', 't2', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_STRD_T1_fe500000_e8400000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xe8500000:
    // LDRD<c> <Rt>, <Rt2>, [<Rn>, #+/-<imm>]! - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 0, 'P', 'U', 1, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 't2', 't2', 't2', 't2', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDRD_T1_fe500000_e8500000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode16 & 0x0000ff80)
  {
  case 0x0000b000:
    // ADD<c> SP, SP, #<imm> - ['could_jmp'] - [1, 0, 1, 1, 0, 0, 0, 0, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_ADD_T2_0000ff80_0000b000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000b080:
    // SUB<c> SP, SP, #<imm> - ['could_jmp'] - [1, 0, 1, 1, 0, 0, 0, 0, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_SUB_T1_0000ff80_0000b080(rBinStrm, Offset, Opcode16, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xff000010)
  {
  case 0xee000000:
    // CDP<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 'opc1', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 0, 'm', 'm', 'm', 'm']
    return Instruction_CDP_T1_ff000010_ee000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfe000000:
    // CDP2<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 'opc1', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 0, 'm', 'm', 'm', 'm']
    return Instruction_CDP2_T2_ff000010_fe000000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xfe100000)
  {
  case 0xec000000:
    // STC{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!} - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 'P', 'U', 'D', 'W', 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_STC_T1_fe100000_ec000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xec100000:
    // LDC{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!} - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 'P', 'U', 'D', 'W', 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDC_T1_fe100000_ec100000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfc000000:
    // STC2{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!} - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 0, 'P', 'U', 'D', 'W', 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_STC2_T2_fe100000_fc000000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xfc100000:
    // LDC2{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!} - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 0, 'P', 'U', 'D', 'W', 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDC2_T2_fe100000_fc100000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode32 & 0xf800d000)
  {
  case 0xf0008000:
    // B<c>.W <thumb_branch_label> - ['jmp'] - [1, 1, 1, 1, 0, 'S', 'c', 'c', 'c', 'c', 'i', 'i', 'i', 'i', 'i', 'i', 1, 0, 'J1', 0, 'J2', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_B_T3_f800d000_f0008000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf0009000:
    // B<c>.W <thumb_branch_label> - ['jmp'] - [1, 1, 1, 1, 0, 'S', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 1, 0, 'J1', 1, 'J2', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_B_T4_f800d000_f0009000(rBinStrm, Offset, Opcode32, rInsn);
  case 0xf000d000:
    // BL<c> <thumb_branch_label> - ['call'] - [1, 1, 1, 1, 0, 'S', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 1, 1, 'J1', 1, 'J2', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_BL_T1_f800d000_f000d000(rBinStrm, Offset, Opcode32, rInsn);
  default:
    break;
  }
  switch (Opcode16 & 0x0000ff00)
  {
  case 0x00004400:
    // ADD<c> <Rdn>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 1, 0, 0, 'DN', 'm', 'm', 'm', 'm', 'dn', 'dn', 'dn']
    return Instruction_ADD_T2_0000ff00_00004400(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004500:
    // CMP<c> <Rn>, <Rm> - ['cond'] - [0, 1, 0, 0, 0, 1, 0, 1, 'N', 'm', 'm', 'm', 'm', 'n', 'n', 'n']
    return Instruction_CMP_T2_0000ff00_00004500(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004600:
    // MOV<c> <Rd>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 1, 1, 0, 'D', 'm', 'm', 'm', 'm', 'd', 'd', 'd']
    return Instruction_MOV_T1_0000ff00_00004600(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000be00:
    // BKPT #<imm> - [] - [1, 0, 1, 1, 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_BKPT_T1_0000ff00_0000be00(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000bf00:
    // IT{x{y{z}}} <firstcond> - [] - [1, 0, 1, 1, 1, 1, 1, 1, 'firstcond', 'firstcond', 'firstcond', 'firstcond', 'mask_4', 'mask_4', 'mask_4', 'mask_4']
    return Instruction_IT_T1_0000ff00_0000bf00(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000df00:
    // SVC<c> #<imm> - ['syscall'] - [1, 1, 0, 1, 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_SVC_T1_0000ff00_0000df00(rBinStrm, Offset, Opcode16, rInsn);
  default:
    break;
  }
  switch (Opcode16 & 0x0000fe00)
  {
  case 0x00001800:
    // ADDS <Rd>, <Rn>, <Rm> - ['could_jmp'] - [0, 0, 0, 1, 1, 0, 0, 'm', 'm', 'm', 'n', 'n', 'n', 'd', 'd', 'd']
    return Instruction_ADDS_T1_0000fe00_00001800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00001a00:
    // SUBS <Rd>, <Rn>, <Rm> - ['could_jmp'] - [0, 0, 0, 1, 1, 0, 1, 'm', 'm', 'm', 'n', 'n', 'n', 'd', 'd', 'd']
    return Instruction_SUBS_T1_0000fe00_00001a00(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00001c00:
    // ADDS <Rd>, <Rn>, #<imm> - [] - [0, 0, 0, 1, 1, 1, 0, 'i', 'i', 'i', 'n', 'n', 'n', 'd', 'd', 'd']
    return Instruction_ADDS_T1_0000fe00_00001c00(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00001e00:
    // SUBS <Rd>, <Rn>, #<imm> - ['could_jmp'] - [0, 0, 0, 1, 1, 1, 1, 'i', 'i', 'i', 'n', 'n', 'n', 'd', 'd', 'd']
    return Instruction_SUBS_T1_0000fe00_00001e00(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00005000:
    // STR<c> <Rt>, [<Rn>, <Rm>] - [] - [0, 1, 0, 1, 0, 0, 0, 'm', 'm', 'm', 'n', 'n', 'n', 't', 't', 't']
    return Instruction_STR_T1_0000fe00_00005000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00005200:
    // STRH<c> <Rt>, [<Rn>, <Rm>] - [] - [0, 1, 0, 1, 0, 0, 1, 'm', 'm', 'm', 'n', 'n', 'n', 't', 't', 't']
    return Instruction_STRH_T1_0000fe00_00005200(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00005400:
    // STRB<c> <Rt>, [<Rn>, <Rm>] - [] - [0, 1, 0, 1, 0, 1, 0, 'm', 'm', 'm', 'n', 'n', 'n', 't', 't', 't']
    return Instruction_STRB_T1_0000fe00_00005400(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00005600:
    // LDRSB<c> <Rt>, [<Rn>, <Rm>] - ['could_jmp'] - [0, 1, 0, 1, 0, 1, 1, 'm', 'm', 'm', 'n', 'n', 'n', 't', 't', 't']
    return Instruction_LDRSB_T1_0000fe00_00005600(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00005800:
    // LDR<c> <Rt>, [<Rn>, <Rm>] - ['could_jmp'] - [0, 1, 0, 1, 1, 0, 0, 'm', 'm', 'm', 'n', 'n', 'n', 't', 't', 't']
    return Instruction_LDR_T1_0000fe00_00005800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00005a00:
    // LDRH<c> <Rt>, [<Rn>, <Rm>] - ['could_jmp'] - [0, 1, 0, 1, 1, 0, 1, 'm', 'm', 'm', 'n', 'n', 'n', 't', 't', 't']
    return Instruction_LDRH_T1_0000fe00_00005a00(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00005c00:
    // LDRB<c> <Rt>, [<Rn>, <Rm>] - ['could_jmp'] - [0, 1, 0, 1, 1, 1, 0, 'm', 'm', 'm', 'n', 'n', 'n', 't', 't', 't']
    return Instruction_LDRB_T1_0000fe00_00005c00(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00005e00:
    // LDRSH<c> <Rt>, [<Rn>, <Rm>] - ['could_jmp'] - [0, 1, 0, 1, 1, 1, 1, 'm', 'm', 'm', 'n', 'n', 'n', 't', 't', 't']
    return Instruction_LDRSH_T1_0000fe00_00005e00(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000b400:
    // PUSH<c> <registers> - ['could_jmp'] - [1, 0, 1, 1, 0, 1, 0, 'M', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
    return Instruction_PUSH_T1_0000fe00_0000b400(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000bc00:
    // POP<c> <registers> - ['could_ret'] - [1, 0, 1, 1, 1, 1, 0, 'P', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
    return Instruction_POP_T1_0000fe00_0000bc00(rBinStrm, Offset, Opcode16, rInsn);
  default:
    break;
  }
  if ((Opcode16 & 0x0000f500) == 0x0000b100)
    // CB{N}Z <Rn>, <label> - ['cond', 'jmp'] - [1, 0, 1, 1, 'op', 0, 'i', 1, 'i', 'i', 'i', 'i', 'i', 'n', 'n', 'n']
    return Instruction_CB_T1_0000f500_0000b100(rBinStrm, Offset, Opcode16, rInsn);
  switch (Opcode16 & 0x0000f800)
  {
  case 0x00000000:
    // LSLS <Rd>, <Rm>, #<imm5> - ['could_jmp'] - [0, 0, 0, 0, 0, 'i', 'i', 'i', 'i', 'i', 'm', 'm', 'm', 'd', 'd', 'd']
    return Instruction_LSLS_T1_0000f800_00000000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00000800:
    // LSRS <Rd>, <Rm>, #<imm> - ['could_jmp'] - [0, 0, 0, 0, 1, 'i', 'i', 'i', 'i', 'i', 'm', 'm', 'm', 'd', 'd', 'd']
    return Instruction_LSRS_T1_0000f800_00000800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00001000:
    // ASRS <Rd>, <Rm>, #<imm> - ['could_jmp'] - [0, 0, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'm', 'm', 'm', 'd', 'd', 'd']
    return Instruction_ASRS_T1_0000f800_00001000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00002000:
    // MOVS <Rd>, #<imm> - ['could_jmp'] - [0, 0, 1, 0, 0, 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_MOVS_T1_0000f800_00002000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00002800:
    // CMP<c> <Rn>, #<imm> - ['cond'] - [0, 0, 1, 0, 1, 'n', 'n', 'n', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_CMP_T1_0000f800_00002800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00003000:
    // ADDS <Rdn>, #<imm> - ['could_jmp'] - [0, 0, 1, 1, 0, 'dn', 'dn', 'dn', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_ADDS_T2_0000f800_00003000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00003800:
    // SUBS <Rdn>, #<imm> - ['could_jmp'] - [0, 0, 1, 1, 1, 'dn', 'dn', 'dn', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_SUBS_T2_0000f800_00003800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00004800:
    // LDR<c> <Rt>, <label> - ['could_jmp'] - [0, 1, 0, 0, 1, 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDR_T1_0000f800_00004800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00006000:
    // STR<c> <Rt>, [<Rn>{,#<imm>}] - [] - [0, 1, 1, 0, 0, 'i', 'i', 'i', 'i', 'i', 'n', 'n', 'n', 't', 't', 't']
    return Instruction_STR_T1_0000f800_00006000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00006800:
    // LDR<c> <Rt>, [<Rn>{,#<imm>}] - ['could_jmp'] - [0, 1, 1, 0, 1, 'i', 'i', 'i', 'i', 'i', 'n', 'n', 'n', 't', 't', 't']
    return Instruction_LDR_T1_0000f800_00006800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00007000:
    // STRB<c> <Rt>, [<Rn>, #<imm5>] - [] - [0, 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'i', 'n', 'n', 'n', 't', 't', 't']
    return Instruction_STRB_T1_0000f800_00007000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00007800:
    // LDRB<c> <Rt>, [<Rn>{,#<imm5>}] - ['could_jmp'] - [0, 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'n', 'n', 'n', 't', 't', 't']
    return Instruction_LDRB_T1_0000f800_00007800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00008000:
    // STRH<c> <Rt>, [<Rn>{,#<imm>}] - [] - [1, 0, 0, 0, 0, 'i', 'i', 'i', 'i', 'i', 'n', 'n', 'n', 't', 't', 't']
    return Instruction_STRH_T1_0000f800_00008000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00008800:
    // LDRH<c> <Rt>, [<Rn>{,#<imm>}] - ['could_jmp'] - [1, 0, 0, 0, 1, 'i', 'i', 'i', 'i', 'i', 'n', 'n', 'n', 't', 't', 't']
    return Instruction_LDRH_T1_0000f800_00008800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00009000:
    // STR<c> <Rt>, [SP, #<imm>] - [] - [1, 0, 0, 1, 0, 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_STR_T2_0000f800_00009000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x00009800:
    // LDR<c> <Rt>, [SP{,#<imm>}] - ['could_jmp'] - [1, 0, 0, 1, 1, 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_LDR_T2_0000f800_00009800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000a000:
    // ADR<c> <Rd>, <label> - ['could_jmp'] - [1, 0, 1, 0, 0, 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_ADR_T1_0000f800_0000a000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000a800:
    // ADD<c> <Rd>, SP, #<imm> - ['could_jmp'] - [1, 0, 1, 0, 1, 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_ADD_T1_0000f800_0000a800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000c000:
    // STM<c> <Rn>!,<registers> - [] - [1, 1, 0, 0, 0, 'n', 'n', 'n', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
    return Instruction_STM_T1_0000f800_0000c000(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000c800:
    // LDM<c> <Rn>, <registers> - ['could_jmp'] - [1, 1, 0, 0, 1, 'n', 'n', 'n', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
    return Instruction_LDM_T1_0000f800_0000c800(rBinStrm, Offset, Opcode16, rInsn);
  case 0x0000e000:
    // B<c> <thumb_branch_label> - ['jmp'] - [1, 1, 1, 0, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_B_T2_0000f800_0000e000(rBinStrm, Offset, Opcode16, rInsn);
  default:
    break;
  }
  if ((Opcode16 & 0x0000f000) == 0x0000d000)
    // B<c> <thumb_branch_label> - ['jmp'] - [1, 1, 0, 1, 'c', 'c', 'c', 'c', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
    return Instruction_B_T1_0000f000_0000d000(rBinStrm, Offset, Opcode16, rInsn);
  return false;
}
// SETEND <endian_specifier> - [] - [1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, '(0)', '(0)', '(0)', 1, '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', 'E', '(0)', 0, 0, 0, 0, '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_SETEND_A1_fffffdff_f1010000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SETEND");
  rInsn.SetOpcode(ARM_Opcode_Setend);
  rInsn.Length() += 4;

  // field: endian_specifier
  /* unhandled field endian_specifier */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VAND<c> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VAND_A1_ffb00f10_f2000110(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VAND");
  rInsn.SetOpcode(ARM_Opcode_Vand);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VBIC<c> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VBIC_A1_ffb00f10_f2100110(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VBIC");
  rInsn.SetOpcode(ARM_Opcode_Vbic);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VADD<c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VADD_A1_ffa00f10_f2000d00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VADD");
  rInsn.SetOpcode(ARM_Opcode_Vadd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCEQ<c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCEQ_A2_ffa00f10_f2000e00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCEQ");
  rInsn.SetOpcode(ARM_Opcode_Vceq);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRECPS<c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRECPS_A1_ffa00f10_f2000f10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRECPS");
  rInsn.SetOpcode(ARM_Opcode_Vrecps);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VORR<c> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VORR_A1_ffb00f10_f2200110(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VORR");
  rInsn.SetOpcode(ARM_Opcode_Vorr);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VORN<c> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VORN_A1_ffb00f10_f2300110(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VORN");
  rInsn.SetOpcode(ARM_Opcode_Vorn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSUB<c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 1, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSUB_A1_ffa00f10_f2200d00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSUB");
  rInsn.SetOpcode(ARM_Opcode_Vsub);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRSQRTS<c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 1, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRSQRTS_A1_ffa00f10_f2200f10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRSQRTS");
  rInsn.SetOpcode(ARM_Opcode_Vrsqrts);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VADD<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VADD_A1_ff800f10_f2000800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VADD");
  rInsn.SetOpcode(ARM_Opcode_Vadd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VTST<c>.<size> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VTST_A1_ff800f10_f2000810(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VTST");
  rInsn.SetOpcode(ARM_Opcode_Vtst);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQDMULH<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQDMULH_A1_ff800f10_f2000b00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQDMULH");
  rInsn.SetOpcode(ARM_Opcode_Vqdmulh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VPADD<c>.<dt> - [] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VPADD_A1_ff800f10_f2000b10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VPADD");
  rInsn.SetOpcode(ARM_Opcode_Vpadd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op><c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 'op', 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_A1_ff800f10_f2000d10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op><c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 0, 'D', 'op', 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_A1_ff800f10_f2000f00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VEXT<c>.8 <Dd>, <Dn>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 1, 'D', 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VEXT_A1_ffb00010_f2b00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VEXT");
  rInsn.SetOpcode(ARM_Opcode_Vext);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 12>(ExtractBits<8, 11>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSHL<c>.I<size> <Dd>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 0, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSHL_A1_ff800f10_f2800510(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSHL");
  rInsn.SetOpcode(ARM_Opcode_Vshl);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSHRN<c>.I<size> <Dd>, <Qm>, #<imm> - [] - [1, 1, 1, 1, 0, 0, 1, 0, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSHRN_A1_ff800fd0_f2800810(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSHRN");
  rInsn.SetOpcode(ARM_Opcode_Vshrn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Qm
  /* unhandled field Qm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRSHRN<c>.I<size> <Dd>, <Qm>, #<imm> - [] - [1, 1, 1, 1, 0, 0, 1, 0, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 0, 1, 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRSHRN_A1_ff800fd0_f2800850(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRSHRN");
  rInsn.SetOpcode(ARM_Opcode_Vrshrn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Qm
  /* unhandled field Qm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VADDHN<c>.<dt> <Dd>, <Qn>, <Qm> - [] - [1, 1, 1, 1, 0, 0, 1, 0, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VADDHN_A1_ff800f50_f2800400(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VADDHN");
  rInsn.SetOpcode(ARM_Opcode_Vaddhn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSUBHN<c>.<dt> <Dd>, <Qn>, <Qm> - [] - [1, 1, 1, 1, 0, 0, 1, 0, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSUBHN_A1_ff800f50_f2800600(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSUBHN");
  rInsn.SetOpcode(ARM_Opcode_Vsubhn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQD<op><c>.<dt> <Qd>, <Dn>, <Dm[x]> - [] - [1, 1, 1, 1, 0, 0, 1, 0, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 'op', 1, 1, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQD_A2_ff800b50_f2800340(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQD");
  rInsn.SetOpcode(ARM_Opcode_Vqd);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm[x]
  /* unhandled field Dm[x] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]> - [] - [1, 1, 1, 1, 0, 0, 1, 0, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQDMULL_A2_ff800f50_f2800b40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQDMULL");
  rInsn.SetOpcode(ARM_Opcode_Vqdmull);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm[x]
  /* unhandled field Dm[x] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQD<op><c>.<dt> <Qd>, <Dn>, <Dm> - [] - [1, 1, 1, 1, 0, 0, 1, 0, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 'op', 1, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQD_A1_ff800d50_f2800900(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQD");
  rInsn.SetOpcode(ARM_Opcode_Vqd);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm> - [] - [1, 1, 1, 1, 0, 0, 1, 0, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQDMULL_A1_ff800f50_f2800d00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQDMULL");
  rInsn.SetOpcode(ARM_Opcode_Vqdmull);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VEOR<c> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VEOR_A1_ffb00f10_f3000110(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VEOR");
  rInsn.SetOpcode(ARM_Opcode_Veor);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VPADD<c>.F32 - [] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VPADD_A1_ffa00f10_f3000d00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VPADD");
  rInsn.SetOpcode(ARM_Opcode_Vpadd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMUL<c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMUL_A1_ffa00f10_f3000d10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMUL");
  rInsn.SetOpcode(ARM_Opcode_Vmul);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCGE<c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCGE_A2_ffa00f10_f3000e00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCGE");
  rInsn.SetOpcode(ARM_Opcode_Vcge);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VABD<c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 1, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VABD_A1_ffa00f10_f3200d00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VABD");
  rInsn.SetOpcode(ARM_Opcode_Vabd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCGT<c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 1, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCGT_A2_ffa00f10_f3200e00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCGT");
  rInsn.SetOpcode(ARM_Opcode_Vcgt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSUB<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSUB_A1_ff800f10_f3000800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSUB");
  rInsn.SetOpcode(ARM_Opcode_Vsub);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCEQ<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCEQ_A1_ff800f10_f3000810(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCEQ");
  rInsn.SetOpcode(ARM_Opcode_Vceq);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQRDMULH<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQRDMULH_A1_ff800f10_f3000b00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQRDMULH");
  rInsn.SetOpcode(ARM_Opcode_Vqrdmulh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op><c> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 'op', 'op', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_A1_ff800f10_f3000110(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op><c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 'op', 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_A1_ff800f10_f3000e10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VP<op><c>.F32 <Dd>, <Dn>, <Dm> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 0, 'D', 'op', 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VP_A1_ff800f10_f3000f00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VP");
  rInsn.SetOpcode(ARM_Opcode_Vp);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VREV<n><c>.<size> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 'op', 'op', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VREV_A1_ffb30e10_f3b00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VREV");
  rInsn.SetOpcode(ARM_Opcode_Vrev);
  rInsn.Length() += 4;

  // field: n
  /* unhandled field n */

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VPADDL<c>.<dt> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'op', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VPADDL_A1_ffb30f10_f3b00200(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VPADDL");
  rInsn.SetOpcode(ARM_Opcode_Vpaddl);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCLS<c>.<dt> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 0, 0, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCLS_A1_ffb30f90_f3b00400(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCLS");
  rInsn.SetOpcode(ARM_Opcode_Vcls);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCLZ<c>.<dt> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 0, 0, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCLZ_A1_ffb30f90_f3b00480(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCLZ");
  rInsn.SetOpcode(ARM_Opcode_Vclz);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCNT<c>.8 <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 0, 1, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCNT_A1_ffb30f90_f3b00500(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCNT");
  rInsn.SetOpcode(ARM_Opcode_Vcnt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMVN<c> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 0, 1, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMVN_A1_ffb30f90_f3b00580(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMVN");
  rInsn.SetOpcode(ARM_Opcode_Vmvn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VPADAL<c>.<dt> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'op', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VPADAL_A1_ffb30f10_f3b00600(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VPADAL");
  rInsn.SetOpcode(ARM_Opcode_Vpadal);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQABS<c>.<dt> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 1, 1, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQABS_A1_ffb30f90_f3b00700(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQABS");
  rInsn.SetOpcode(ARM_Opcode_Vqabs);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQNEG<c>.<dt> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 1, 1, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQNEG_A1_ffb30f90_f3b00780(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQNEG");
  rInsn.SetOpcode(ARM_Opcode_Vqneg);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCGT<c>.<dt> <Dd>, <Dm>, #0 - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 0, 0, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCGT_A1_ffb30b90_f3b10000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCGT");
  rInsn.SetOpcode(ARM_Opcode_Vcgt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */

  // field: #0
  auto pOprd0 = Expr::MakeConst(32, 0);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCGE<c>.<dt> <Dd>, <Dm>, #0 - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 0, 0, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCGE_A1_ffb30b90_f3b10080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCGE");
  rInsn.SetOpcode(ARM_Opcode_Vcge);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */

  // field: #0
  auto pOprd0 = Expr::MakeConst(32, 0);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCEQ<c>.<dt> <Dd>, <Dm>, #0 - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 0, 1, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCEQ_A1_ffb30b90_f3b10100(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCEQ");
  rInsn.SetOpcode(ARM_Opcode_Vceq);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */

  // field: #0
  auto pOprd0 = Expr::MakeConst(32, 0);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCLE<c>.<dt> <Dd>, <Dm>, #0 - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 0, 1, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCLE_A1_ffb30b90_f3b10180(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCLE");
  rInsn.SetOpcode(ARM_Opcode_Vcle);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */

  // field: #0
  auto pOprd0 = Expr::MakeConst(32, 0);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCLT<c>.<dt> <Dd>, <Dm>, #0 - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 1, 0, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCLT_A1_ffb30b90_f3b10200(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCLT");
  rInsn.SetOpcode(ARM_Opcode_Vclt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */

  // field: #0
  auto pOprd0 = Expr::MakeConst(32, 0);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VABS<c>.<dt> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 1, 1, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VABS_A1_ffb30b90_f3b10300(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VABS");
  rInsn.SetOpcode(ARM_Opcode_Vabs);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VNEG<c>.<dt> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 1, 1, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VNEG_A1_ffb30b90_f3b10380(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VNEG");
  rInsn.SetOpcode(ARM_Opcode_Vneg);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSWP<c> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSWP_A1_ffb30f90_f3b20000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSWP");
  rInsn.SetOpcode(ARM_Opcode_Vswp);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VTRN<c>.<size> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VTRN_A1_ffb30f90_f3b20080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VTRN");
  rInsn.SetOpcode(ARM_Opcode_Vtrn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VUZP<c>.<size> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 1, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VUZP_A1_ffb30f90_f3b20100(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VUZP");
  rInsn.SetOpcode(ARM_Opcode_Vuzp);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VZIP<c>.<size> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 1, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VZIP_A1_ffb30f90_f3b20180(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VZIP");
  rInsn.SetOpcode(ARM_Opcode_Vzip);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMOVN<c>.<dt> <Dd>, <Qm> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 0, 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMOVN_A1_ffb30fd0_f3b20200(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMOVN");
  rInsn.SetOpcode(ARM_Opcode_Vmovn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQMOV{op}N<c>.<type><size> <Dd>, <Qm> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'op', 'op', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQMOV_A1_ffb30f10_f3b20200(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQMOV");
  rInsn.SetOpcode(ARM_Opcode_Vqmov);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: type
  /* unhandled field type */

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSHLL<c>.<type_4><size> <Qd>, <Dm>, #<imm> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 1, 1, 0, 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSHLL_A2_ffb30fd0_f3b20300(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSHLL");
  rInsn.SetOpcode(ARM_Opcode_Vshll);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Dm
  /* unhandled field Dm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 20>(ExtractBits<18, 19>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCVT<c>.F16.F32 <Dd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 1, 1, 'op', 0, 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCVT_A1_ffb30ed0_f3b20600(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCVT");
  rInsn.SetOpcode(ARM_Opcode_Vcvt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRECPE<c>.<dt> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 'F', 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRECPE_A1_ffb30e90_f3b30400(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRECPE");
  rInsn.SetOpcode(ARM_Opcode_Vrecpe);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRSQRTE<c>.<dt> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 'F', 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRSQRTE_A1_ffb30e90_f3b30480(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRSQRTE");
  rInsn.SetOpcode(ARM_Opcode_Vrsqrte);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCVT<c>.<Td>.<Tm> <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 1, 'd', 'd', 'd', 'd', 0, 1, 1, 'op', 'op', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCVT_A1_ffb30e10_f3b30600(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCVT");
  rInsn.SetOpcode(ARM_Opcode_Vcvt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Td
  /* unhandled field Td */

  // field: Tm
  /* unhandled field Tm */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VDUP<c>.<size> <Dd>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 1, 0, 0, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VDUP_A1_ffb00f90_f3b00c00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VDUP");
  rInsn.SetOpcode(ARM_Opcode_Vdup);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm[x]
  /* unhandled field Dm[x] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op><c>.8 <Dd>, <list>, <Dm> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 'len', 'len', 'N', 'op', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_A1_ffb00c10_f3b00800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: list
  /* unhandled field list */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSRI<c>.<size> <Dd>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSRI_A1_ff800f10_f3800410(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSRI");
  rInsn.SetOpcode(ARM_Opcode_Vsri);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSLI<c>.<size> <Dd>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSLI_A1_ff800f10_f3800510(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSLI");
  rInsn.SetOpcode(ARM_Opcode_Vsli);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRADDHN<c>.<dt> <Dd>, <Qn>, <Qm> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRADDHN_A1_ff800f50_f3800400(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRADDHN");
  rInsn.SetOpcode(ARM_Opcode_Vraddhn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRSUBHN<c>.<dt> <Dd>, <Qn>, <Qm> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRSUBHN_A1_ff800f50_f3800600(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRSUBHN");
  rInsn.SetOpcode(ARM_Opcode_Vrsubhn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op><c>.<dt> <Dd>, <Dn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'Q', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 'op', 0, 'F', 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_A1_fe800a50_f2800040(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm[x]
  /* unhandled field Dm[x] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMUL<c>.<dt> <Dd>, <Dn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'Q', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 'F', 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMUL_A1_fe800e50_f2800840(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMUL");
  rInsn.SetOpcode(ARM_Opcode_Vmul);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm[x]
  /* unhandled field Dm[x] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQDMULH<c>.<dt> <Dd>, <Dn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'Q', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 0, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQDMULH_A2_fe800f50_f2800c40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQDMULH");
  rInsn.SetOpcode(ARM_Opcode_Vqdmulh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm[x]
  /* unhandled field Dm[x] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQRDMULH<c>.<dt> <Dd>, <Dn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'Q', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQRDMULH_A2_fe800f50_f2800d40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQRDMULH");
  rInsn.SetOpcode(ARM_Opcode_Vqrdmulh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm[x]
  /* unhandled field Dm[x] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQADD<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQADD_A1_fe800f10_f2000010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQADD");
  rInsn.SetOpcode(ARM_Opcode_Vqadd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRHADD<c> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRHADD_A1_fe800f10_f2000100(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRHADD");
  rInsn.SetOpcode(ARM_Opcode_Vrhadd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQSUB<c>.<type_4><size> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQSUB_A1_fe800f10_f2000210(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQSUB");
  rInsn.SetOpcode(ARM_Opcode_Vqsub);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCGT<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCGT_A1_fe800f10_f2000300(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCGT");
  rInsn.SetOpcode(ARM_Opcode_Vcgt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCGE<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 1, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCGE_A1_fe800f10_f2000310(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCGE");
  rInsn.SetOpcode(ARM_Opcode_Vcge);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VH<op><c> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 'op', 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VH_A1_fe800d10_f2000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VH");
  rInsn.SetOpcode(ARM_Opcode_Vh);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSHL<c>.I<size> <Dd>, <Dm>, <Dn> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSHL_A1_fe800f10_f2000400(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSHL");
  rInsn.SetOpcode(ARM_Opcode_Vshl);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */

  // field: Dn
  /* unhandled field Dn */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQSHL<c>.<type_4><size> <Dd>, <Dm>, <Dn> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQSHL_A1_fe800f10_f2000410(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQSHL");
  rInsn.SetOpcode(ARM_Opcode_Vqshl);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */

  // field: Dn
  /* unhandled field Dn */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRSHL<c>.<type_4><size> <Dd>, <Dm>, <Dn> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRSHL_A1_fe800f10_f2000500(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRSHL");
  rInsn.SetOpcode(ARM_Opcode_Vrshl);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */

  // field: Dn
  /* unhandled field Dn */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQRSHL<c>.<type_4><size> <Dd>, <Dm>, <Dn> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQRSHL_A1_fe800f10_f2000510(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQRSHL");
  rInsn.SetOpcode(ARM_Opcode_Vqrshl);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */

  // field: Dn
  /* unhandled field Dn */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op><c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'N', 'Q', 'M', 'op', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_A1_fe800f00_f2000600(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VABD<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VABD_A1_fe800f10_f2000700(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VABD");
  rInsn.SetOpcode(ARM_Opcode_Vabd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VABA<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VABA_A1_fe800f10_f2000710(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VABA");
  rInsn.SetOpcode(ARM_Opcode_Vaba);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VP<op><c>.<dt> <Dd>, <Dn>, <Dm> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'N', 'Q', 'M', 'op', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VP_A1_fe800f00_f2000a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VP");
  rInsn.SetOpcode(ARM_Opcode_Vp);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMOVL<c>.<dt> <Qd>, <Dm> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'i', 0, 0, 0, 'd', 'd', 'd', 'd', 1, 0, 1, 0, 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMOVL_A1_fe870fd0_f2800a10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMOVL");
  rInsn.SetOpcode(ARM_Opcode_Vmovl);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSHR<c>.<type_4><size> <Dd>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSHR_A1_fe800f10_f2800010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSHR");
  rInsn.SetOpcode(ARM_Opcode_Vshr);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSRA<c>.<type_4><size> <Dd>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSRA_A1_fe800f10_f2800110(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSRA");
  rInsn.SetOpcode(ARM_Opcode_Vsra);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRSHR<c>.<type_4><size> <Dd>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRSHR_A1_fe800f10_f2800210(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRSHR");
  rInsn.SetOpcode(ARM_Opcode_Vrshr);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRSRA<c>.<type_4><size> <Dd>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 0, 1, 1, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRSRA_A1_fe800f10_f2800310(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRSRA");
  rInsn.SetOpcode(ARM_Opcode_Vrsra);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQSHL{op}<c>.<type_4><size> <Dd>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 1, 1, 'op', 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQSHL_A1_fe800e10_f2800610(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQSHL");
  rInsn.SetOpcode(ARM_Opcode_Vqshl);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQSHR{op}N<c>.<type_4><size> <Dd>, <Qm>, #<imm> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 0, 'op', 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQSHR_A1_fe800ed0_f2800810(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQSHR");
  rInsn.SetOpcode(ARM_Opcode_Vqshr);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Qm
  /* unhandled field Qm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQRSHR{op}N<c>.<type_4><size> <Dd>, <Qm>, #<imm> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 0, 'op', 0, 1, 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQRSHR_A1_fe800ed0_f2800850(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQRSHR");
  rInsn.SetOpcode(ARM_Opcode_Vqrshr);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Qm
  /* unhandled field Qm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSHLL<c>.<type_4><size> <Qd>, <Dm>, #<imm> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSHLL_A1_fe800fd0_f2800a10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSHLL");
  rInsn.SetOpcode(ARM_Opcode_Vshll);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Dm
  /* unhandled field Dm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCVT<c>.<Td>.<Tm> <Dd>, <Dm>, #<fbits> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 1, 1, 'op', 0, 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCVT_A1_fe800e90_f2800e10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCVT");
  rInsn.SetOpcode(ARM_Opcode_Vcvt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Td
  /* unhandled field Td */

  // field: Tm
  /* unhandled field Tm */

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */

  // field: fbits
  /* unhandled field fbits */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VADDW<c>.<dt> <Qd>, <Qn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 'op', 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VADDW_A1_fe800e50_f2800000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VADDW");
  rInsn.SetOpcode(ARM_Opcode_Vaddw);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSUBW<c>.<dt> {<Qd>,} <Qn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 1, 'op', 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSUBW_A1_fe800e50_f2800200(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSUBW");
  rInsn.SetOpcode(ARM_Opcode_Vsubw);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: {<Qd>,}
  /* unhandled field {<Qd>,} */

  // field: Qn
  /* unhandled field Qn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VABAL<c>.<dt> <Qd>, <Dn>, <Dm> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VABAL_A2_fe800f50_f2800500(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VABAL");
  rInsn.SetOpcode(ARM_Opcode_Vabal);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VABDL<c>.<dt> <Qd>, <Dn>, <Dm> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 1, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VABDL_A2_fe800f50_f2800700(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VABDL");
  rInsn.SetOpcode(ARM_Opcode_Vabdl);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op>L<c>.<dt> <Qd>, <Dn>, <Dm[x]> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 'op', 1, 0, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_A2_fe800b50_f2800240(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm[x]
  /* unhandled field Dm[x] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMULL_A2_fe800f50_f2800a40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMULL");
  rInsn.SetOpcode(ARM_Opcode_Vmull);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm[x]
  /* unhandled field Dm[x] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op>L<c>.<dt> <Qd>, <Dn>, <Dm> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 'op', 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_A2_fe800d50_f2800800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMULL<c>.<dt> <Qd>, <Dn>, <Dm> - [] - [1, 1, 1, 1, 0, 0, 1, 'U', 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 'op', 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMULL_A2_fe800d50_f2800c00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMULL");
  rInsn.SetOpcode(ARM_Opcode_Vmull);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VORR<c>.<dt> <Dd>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'i', 1, 'D', 0, 0, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'cmode', 'cmode', 'cmode', 'cmode', 0, 'Q', 0, 1, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VORR_A1_feb800b0_f2800010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VORR");
  rInsn.SetOpcode(ARM_Opcode_Vorr);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 4>(ExtractBits<0, 3>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VBIC<c>.<dt> <Dd>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'i', 1, 'D', 0, 0, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'cmode', 'cmode', 'cmode', 'cmode', 0, 'Q', 1, 1, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VBIC_A1_feb800b0_f2800030(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VBIC");
  rInsn.SetOpcode(ARM_Opcode_Vbic);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 4>(ExtractBits<0, 3>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMOV<c>.<dt> <Dd>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'i', 1, 'D', 0, 0, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'cmode', 'cmode', 'cmode', 'cmode', 0, 'Q', 'op', 1, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VMOV_A1_feb80090_f2800010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMOV");
  rInsn.SetOpcode(ARM_Opcode_Vmov);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 4>(ExtractBits<0, 3>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op><c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'op', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_A1_fe800f10_f2000900(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMUL<c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 0, 0, 1, 'op', 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMUL_A1_fe800f10_f2000910(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMUL");
  rInsn.SetOpcode(ARM_Opcode_Vmul);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VST1<c>.<size> <list>, [<Rn>{@<align>}], <Rm> - ['support_it_block', 'support_it_block'] - [1, 1, 1, 1, 0, 1, 0, 0, 0, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'tp', 'tp', 'tp', 'tp', 'i', 'i', 'align', 'align', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VST1_A1_ffb00000_f4000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VST1");
  rInsn.SetOpcode(ARM_Opcode_Vst1);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: list
  /* unhandled field list */

  // field: [<Rn>{@<align>}]
  /* unhandled field [<Rn>{@<align>}] */

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd0 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VLD1<c>.<size> <list>, [<Rn>{@<align>}], <Rm> - ['support_it_block', 'support_it_block'] - [1, 1, 1, 1, 0, 1, 0, 0, 0, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'tp', 'tp', 'tp', 'tp', 'i', 'i', 'align', 'align', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VLD1_A1_ffb00000_f4200000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VLD1");
  rInsn.SetOpcode(ARM_Opcode_Vld1);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: list
  /* unhandled field list */

  // field: [<Rn>{@<align>}]
  /* unhandled field [<Rn>{@<align>}] */

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd0 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VST1<c>.<size> <list>, [<Rn>{@<align>}], <Rm> - ['support_it_block'] - [1, 1, 1, 1, 0, 1, 0, 0, 1, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 0, 0, 'index_align', 'index_align', 'index_align', 'index_align', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VST1_A1_ffb00300_f4800000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VST1");
  rInsn.SetOpcode(ARM_Opcode_Vst1);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: list
  /* unhandled field list */

  // field: [<Rn>{@<align>}]
  /* unhandled field [<Rn>{@<align>}] */

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd0 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VLD1<c>.<size> <list>, [<Rn>{@<align>}], <Rm> - ['support_it_block'] - [1, 1, 1, 1, 0, 1, 0, 0, 1, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 0, 'i', 'i', 'T', 'A', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VLD1_A1_ffb00f00_f4a00c00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VLD1");
  rInsn.SetOpcode(ARM_Opcode_Vld1);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: list
  /* unhandled field list */

  // field: [<Rn>{@<align>}]
  /* unhandled field [<Rn>{@<align>}] */

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd0 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VLD1<c>.<size> <list>, [<Rn>{@<align>}], <Rm> - ['support_it_block'] - [1, 1, 1, 1, 0, 1, 0, 0, 1, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 0, 0, 'index_align', 'index_align', 'index_align', 'index_align', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VLD1_A1_ffb00300_f4a00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VLD1");
  rInsn.SetOpcode(ARM_Opcode_Vld1);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: list
  /* unhandled field list */

  // field: [<Rn>{@<align>}]
  /* unhandled field [<Rn>{@<align>}] */

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd0 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// PLI [PC,#-0] - [] - [1, 1, 1, 1, 0, 1, 0, 0, 'U', 1, 0, 1, 'n', 'n', 'n', 'n', '(1)', '(1)', '(1)', '(1)', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_PLI_A1_ff70f000_f450f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("PLI");
  rInsn.SetOpcode(ARM_Opcode_Pli);
  rInsn.Length() += 4;

  // field: [PC,#-0]
  auto pOprd0 = Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_RegPC, &m_CpuInfo), true);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CLREX - [] - [1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 0, 0, 1, '(1)', '(1)', '(1)', '(1)']
bool ArmArchitecture::Instruction_CLREX_A1_ffffffff_f57ff01f(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CLREX");
  rInsn.SetOpcode(ARM_Opcode_Clrex);
  rInsn.Length() += 4;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// DSB #<option> - [] - [1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 1, 0, 0, 'option', 'option', 'option', 'option']
bool ArmArchitecture::Instruction_DSB_A1_fffffff0_f57ff040(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("DSB");
  rInsn.SetOpcode(ARM_Opcode_Dsb);
  rInsn.Length() += 4;

  // field: option
  /* unhandled field option */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// DMB #<option> - [] - [1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 1, 0, 1, 'option', 'option', 'option', 'option']
bool ArmArchitecture::Instruction_DMB_A1_fffffff0_f57ff050(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("DMB");
  rInsn.SetOpcode(ARM_Opcode_Dmb);
  rInsn.Length() += 4;

  // field: option
  /* unhandled field option */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ISB #<option> - [] - [1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 1, 1, 0, 'option', 'option', 'option', 'option']
bool ArmArchitecture::Instruction_ISB_A1_fffffff0_f57ff060(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ISB");
  rInsn.SetOpcode(ARM_Opcode_Isb);
  rInsn.Length() += 4;

  // field: option
  /* unhandled field option */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// PLD [PC,#-0] - [] - [1, 1, 1, 1, 0, 1, 0, 1, 'U', '(1)', 0, 1, 1, 1, 1, 1, '(1)', '(1)', '(1)', '(1)', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_PLD_A1_ff7ff000_f55ff000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("PLD");
  rInsn.SetOpcode(ARM_Opcode_Pld);
  rInsn.Length() += 4;

  // field: [PC,#-0]
  auto pOprd0 = Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_RegPC, &m_CpuInfo), true);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// PLD{R} [<Rn>, #<imm>] - [] - [1, 1, 1, 1, 0, 1, 0, 1, 'U', 'R', 0, 1, 'n', 'n', 'n', 'n', '(1)', '(1)', '(1)', '(1)', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_PLD_A1_ff30f000_f510f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("PLD");
  rInsn.SetOpcode(ARM_Opcode_Pld);
  rInsn.Length() += 4;

  // field: R
  /* unhandled field R */

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// PLI [<Rn>,+/-<Rm>{,<shift>}] - [] - [1, 1, 1, 1, 0, 1, 1, 0, 'U', 1, 0, 1, 'n', 'n', 'n', 'n', '(1)', '(1)', '(1)', '(1)', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_PLI_A1_ff70f010_f650f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("PLI");
  rInsn.SetOpcode(ARM_Opcode_Pli);
  rInsn.Length() += 4;

  // field: [<Rn>,+/-<Rm>{,<shift>}]
  /* unhandled field [<Rn>,+/-<Rm>{,<shift>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// PLD{R}<c> [<Rn>,+/-<Rm>{,<shift>}] - [] - [1, 1, 1, 1, 0, 1, 1, 1, 'U', 'R', 0, 1, 'n', 'n', 'n', 'n', '(1)', '(1)', '(1)', '(1)', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_PLD_A1_ff30f010_f710f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("PLD");
  rInsn.SetOpcode(ARM_Opcode_Pld);
  rInsn.Length() += 4;

  // field: R
  /* unhandled field R */

  // field: c
  // TODO: unable to find conditional bits

  // field: [<Rn>,+/-<Rm>{,<shift>}]
  /* unhandled field [<Rn>,+/-<Rm>{,<shift>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BLX <arm_branch_label> - ['call'] - [1, 1, 1, 1, 1, 0, 1, 'H', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_BLX_A2_fe000000_fa000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BLX");
  rInsn.SetOpcode(ARM_Opcode_Blx);
  rInsn.Length() += 4;
  rInsn.SubType() |= Instruction::CallType;

  // field: arm_branch_label
  auto pOprd0 = Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(ARM_RegPC, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 24>(ExtractBits<0, 23>(Opcode)) << 2));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MCRR2<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm> - ['could_jmp'] - [1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 't2', 't2', 't2', 't2', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc1', 'opc1', 'opc1', 'opc1', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MCRR2_A2_fff00000_fc400000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MCRR2");
  rInsn.SetOpcode(ARM_Opcode_Mcrr2);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: opc1
  /* unhandled field opc1 */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: CRm
  /* unhandled field CRm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MRRC2<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm> - ['could_jmp'] - [1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 't2', 't2', 't2', 't2', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc1', 'opc1', 'opc1', 'opc1', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MRRC2_A2_fff00000_fc500000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MRRC2");
  rInsn.SetOpcode(ARM_Opcode_Mrrc2);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: opc
  /* unhandled field opc */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: CRm
  /* unhandled field CRm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STC2{L}<c> <coproc>, <CRd>, [<Rn>],<option> - ['support_it_block', 'support_it_block'] - [1, 1, 1, 1, 1, 1, 0, 'P', 'U', 'D', 'W', 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STC2_A2_fe100000_fc000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STC2");
  rInsn.SetOpcode(ARM_Opcode_Stc2);
  rInsn.Length() += 4;

  // field: L
  /* unhandled field L */

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: CRd
  /* unhandled field CRd */

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: option
  /* unhandled field option */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDC2{L}<c> <coproc>, <CRd>, [PC],<option> - ['support_it_block', 'support_it_block'] - [1, 1, 1, 1, 1, 1, 0, 'P', 'U', 'D', 'W', 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDC2_A2_fe1f0000_fc1f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDC2");
  rInsn.SetOpcode(ARM_Opcode_Ldc2);
  rInsn.Length() += 4;

  // field: L
  /* unhandled field L */

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: CRd
  /* unhandled field CRd */

  // field: [PC]
  /* unhandled field [PC] */

  // field: option
  /* unhandled field option */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDC2{L}<c> <coproc>, <CRd>, [<Rn>],<option> - ['support_it_block', 'support_it_block'] - [1, 1, 1, 1, 1, 1, 0, 'P', 'U', 'D', 'W', 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDC2_A2_fe100000_fc100000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDC2");
  rInsn.SetOpcode(ARM_Opcode_Ldc2);
  rInsn.Length() += 4;

  // field: L
  /* unhandled field L */

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: CRd
  /* unhandled field CRd */

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: option
  /* unhandled field option */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MCR2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['could_jmp'] - [1, 1, 1, 1, 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MCR2_A2_ff100010_fe000010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MCR2");
  rInsn.SetOpcode(ARM_Opcode_Mcr2);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: opc1
  /* unhandled field opc1 */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: CRn
  /* unhandled field CRn */

  // field: <CRm>{,<opc2>}
  /* unhandled field <CRm>{,<opc2>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MRC2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['could_jmp'] - [1, 1, 1, 1, 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MRC2_A2_ff100010_fe100010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MRC2");
  rInsn.SetOpcode(ARM_Opcode_Mrc2);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: opc1
  /* unhandled field opc1 */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: CRn
  /* unhandled field CRn */

  // field: <CRm>{,<opc2>}
  /* unhandled field <CRm>{,<opc2>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CDP2<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 'opc1', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_CDP2_A2_ff000010_fe000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CDP2");
  rInsn.SetOpcode(ARM_Opcode_Cdp2);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: opc1
  /* unhandled field opc1 */

  // field: CRd
  /* unhandled field CRd */

  // field: CRn
  /* unhandled field CRn */

  // field: CRm
  /* unhandled field CRm */

  // field: opc2
  /* unhandled field opc2 */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MUL{S}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 0, 0, 'S', 'd', 'd', 'd', 'd', '(0)', '(0)', '(0)', '(0)', 'm', 'm', 'm', 'm', 1, 0, 0, 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_MUL_A1_0fe0f0f0_00000090(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MUL");
  rInsn.SetOpcode(ARM_Opcode_Mul);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<16, 19>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// AND{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 0, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_AND_A1_0fe00010_00000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("AND");
  rInsn.SetOpcode(ARM_Opcode_And);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// AND{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 0, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_AND_A1_0fe00090_00000010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("AND");
  rInsn.SetOpcode(ARM_Opcode_And);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: type
  /* unhandled field type */

  // field: Rs
  u32 RegS = ExtractBits<8, 11>(Opcode);
  auto pOprd3 = Expr::MakeId(RegS + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MLA{S}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 0, 1, 'S', 'd', 'd', 'd', 'd', 'a', 'a', 'a', 'a', 'm', 'm', 'm', 'm', 1, 0, 0, 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_MLA_A1_0fe000f0_00200090(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MLA");
  rInsn.SetOpcode(ARM_Opcode_Mla);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<16, 19>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: Ra
  u32 RegA = ExtractBits<12, 15>(Opcode);
  auto pOprd3 = Expr::MakeId(RegA + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// EOR{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 0, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_EOR_A1_0fe00010_00200000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("EOR");
  rInsn.SetOpcode(ARM_Opcode_Eor);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// EOR{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 0, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_EOR_A1_0fe00090_00200010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("EOR");
  rInsn.SetOpcode(ARM_Opcode_Eor);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: type
  /* unhandled field type */

  // field: Rs
  u32 RegS = ExtractBits<8, 11>(Opcode);
  auto pOprd3 = Expr::MakeId(RegS + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UMAAL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 1, 0, 0, 'dhi', 'dhi', 'dhi', 'dhi', 'dlo', 'dlo', 'dlo', 'dlo', 'm', 'm', 'm', 'm', 1, 0, 0, 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_UMAAL_A1_0ff000f0_00400090(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UMAAL");
  rInsn.SetOpcode(ARM_Opcode_Umaal);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: RdLo
  /* unhandled field RdLo */

  // field: RdHi
  /* unhandled field RdHi */

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SUB{S}<c> <Rd>, SP, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 1, 0, 'S', 1, 1, 0, 1, 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SUB_A1_0fef0010_004d0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SUB");
  rInsn.SetOpcode(ARM_Opcode_Sub);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: SP
  auto pOprd1 = Expr::MakeId(ARM_RegSP, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SUB{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 1, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SUB_A1_0fe00010_00400000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SUB");
  rInsn.SetOpcode(ARM_Opcode_Sub);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SUB{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 1, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SUB_A1_0fe00090_00400010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SUB");
  rInsn.SetOpcode(ARM_Opcode_Sub);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: type
  /* unhandled field type */

  // field: Rs
  u32 RegS = ExtractBits<8, 11>(Opcode);
  auto pOprd3 = Expr::MakeId(RegS + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MLS<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 1, 1, 0, 'd', 'd', 'd', 'd', 'a', 'a', 'a', 'a', 'm', 'm', 'm', 'm', 1, 0, 0, 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_MLS_A1_0ff000f0_00600090(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MLS");
  rInsn.SetOpcode(ARM_Opcode_Mls);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<16, 19>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: Ra
  u32 RegA = ExtractBits<12, 15>(Opcode);
  auto pOprd3 = Expr::MakeId(RegA + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// RSB{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 1, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_RSB_A1_0fe00010_00600000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("RSB");
  rInsn.SetOpcode(ARM_Opcode_Rsb);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// RSB{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 0, 1, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_RSB_A1_0fe00090_00600010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("RSB");
  rInsn.SetOpcode(ARM_Opcode_Rsb);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: type
  /* unhandled field type */

  // field: Rs
  u32 RegS = ExtractBits<8, 11>(Opcode);
  auto pOprd3 = Expr::MakeId(RegS + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADD{S}<c> <Rd>, SP, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 0, 0, 'S', 1, 1, 0, 1, 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_ADD_A1_0fef0010_008d0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADD");
  rInsn.SetOpcode(ARM_Opcode_Add);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: SP
  auto pOprd1 = Expr::MakeId(ARM_RegSP, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UMULL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 0, 0, 'S', 'dhi', 'dhi', 'dhi', 'dhi', 'dlo', 'dlo', 'dlo', 'dlo', 'm', 'm', 'm', 'm', 1, 0, 0, 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_UMULL_A1_0fe000f0_00800090(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UMULL");
  rInsn.SetOpcode(ARM_Opcode_Umull);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: RdLo
  /* unhandled field RdLo */

  // field: RdHi
  /* unhandled field RdHi */

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADD{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 0, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_ADD_A1_0fe00010_00800000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADD");
  rInsn.SetOpcode(ARM_Opcode_Add);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADD{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 0, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_ADD_A1_0fe00090_00800010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADD");
  rInsn.SetOpcode(ARM_Opcode_Add);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: type
  /* unhandled field type */

  // field: Rs
  u32 RegS = ExtractBits<8, 11>(Opcode);
  auto pOprd3 = Expr::MakeId(RegS + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UMLAL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 0, 1, 'S', 'dhi', 'dhi', 'dhi', 'dhi', 'dlo', 'dlo', 'dlo', 'dlo', 'm', 'm', 'm', 'm', 1, 0, 0, 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_UMLAL_A1_0fe000f0_00a00090(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UMLAL");
  rInsn.SetOpcode(ARM_Opcode_Umlal);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: RdLo
  /* unhandled field RdLo */

  // field: RdHi
  /* unhandled field RdHi */

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADC{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 0, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_ADC_A1_0fe00010_00a00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADC");
  rInsn.SetOpcode(ARM_Opcode_Adc);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 0, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_ADC_A1_0fe00090_00a00010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADC");
  rInsn.SetOpcode(ARM_Opcode_Adc);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: type
  /* unhandled field type */

  // field: Rs
  u32 RegS = ExtractBits<8, 11>(Opcode);
  auto pOprd3 = Expr::MakeId(RegS + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMULL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 1, 0, 'S', 'dhi', 'dhi', 'dhi', 'dhi', 'dlo', 'dlo', 'dlo', 'dlo', 'm', 'm', 'm', 'm', 1, 0, 0, 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_SMULL_A1_0fe000f0_00c00090(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMULL");
  rInsn.SetOpcode(ARM_Opcode_Smull);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: RdLo
  /* unhandled field RdLo */

  // field: RdHi
  /* unhandled field RdHi */

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SBC{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 1, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SBC_A1_0fe00010_00c00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SBC");
  rInsn.SetOpcode(ARM_Opcode_Sbc);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SBC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 1, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SBC_A1_0fe00090_00c00010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SBC");
  rInsn.SetOpcode(ARM_Opcode_Sbc);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: type
  /* unhandled field type */

  // field: Rs
  u32 RegS = ExtractBits<8, 11>(Opcode);
  auto pOprd3 = Expr::MakeId(RegS + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMLAL{S}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 1, 1, 'S', 'dhi', 'dhi', 'dhi', 'dhi', 'dlo', 'dlo', 'dlo', 'dlo', 'm', 'm', 'm', 'm', 1, 0, 0, 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_SMLAL_A1_0fe000f0_00e00090(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMLAL");
  rInsn.SetOpcode(ARM_Opcode_Smlal);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: RdLo
  /* unhandled field RdLo */

  // field: RdHi
  /* unhandled field RdHi */

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// RSC{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 1, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_RSC_A1_0fe00010_00e00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("RSC");
  rInsn.SetOpcode(ARM_Opcode_Rsc);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// RSC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 1, 1, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_RSC_A1_0fe00090_00e00010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("RSC");
  rInsn.SetOpcode(ARM_Opcode_Rsc);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: type
  /* unhandled field type */

  // field: Rs
  u32 RegS = ExtractBits<8, 11>(Opcode);
  auto pOprd3 = Expr::MakeId(RegS + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRHT<c> <Rt>, [<Rn>], +/-<Rm> - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 'U', 0, 1, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 0, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_STRHT_A2_0f700ff0_002000b0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRHT");
  rInsn.SetOpcode(ARM_Opcode_Strht);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: +/-<Rm>
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRHT<c> <Rt>, [<Rn>], +/-<Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 'U', 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 0, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LDRHT_A2_0f700ff0_003000b0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRHT");
  rInsn.SetOpcode(ARM_Opcode_Ldrht);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: +/-<Rm>
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSBT<c> <Rt>, [<Rn>], +/-<Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 'U', 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 1, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LDRSBT_A2_0f700ff0_003000d0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSBT");
  rInsn.SetOpcode(ARM_Opcode_Ldrsbt);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: +/-<Rm>
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSHT<c> <Rt>, [<Rn>], +/-<Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 'U', 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LDRSHT_A2_0f700ff0_003000f0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSHT");
  rInsn.SetOpcode(ARM_Opcode_Ldrsht);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: +/-<Rm>
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRHT<c> <Rt>, [<Rn>] {,#<imm>} - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 'U', 1, 1, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 0, 1, 1, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STRHT_A1_0f7000f0_006000b0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRHT");
  rInsn.SetOpcode(ARM_Opcode_Strht);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: {,#<imm>}
  /* unhandled field {,#<imm>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRHT<c> <Rt>, [<Rn>] {,#<imm>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 'U', 1, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 0, 1, 1, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRHT_A1_0f7000f0_007000b0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRHT");
  rInsn.SetOpcode(ARM_Opcode_Ldrht);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: {,#<imm>}
  /* unhandled field {,#<imm>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSBT<c> <Rt>, [<Rn>] {,#<imm>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 'U', 1, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 1, 0, 1, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRSBT_A1_0f7000f0_007000d0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSBT");
  rInsn.SetOpcode(ARM_Opcode_Ldrsbt);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: {,#<imm>}
  /* unhandled field {,#<imm>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSHT<c> <Rt>, [<Rn>] {,#<imm>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 0, 'U', 1, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRSHT_A1_0f7000f0_007000f0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSHT");
  rInsn.SetOpcode(ARM_Opcode_Ldrsht);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: {,#<imm>}
  /* unhandled field {,#<imm>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MRS<c> <Rd>, <spec_reg> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 0, 0, '(1)', '(1)', '(1)', '(1)', 'd', 'd', 'd', 'd', '(0)', '(0)', '(0)', '(0)', 0, 0, 0, 0, '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_MRS_A1_0fff0fff_010f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MRS");
  rInsn.SetOpcode(ARM_Opcode_Mrs);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: spec_reg
  /* unhandled field spec_reg */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMLA<x><y><c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 0, 0, 'd', 'd', 'd', 'd', 'a', 'a', 'a', 'a', 'm', 'm', 'm', 'm', 1, 'M', 'N', 0, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_SMLA_A1_0ff00090_01000080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMLA");
  rInsn.SetOpcode(ARM_Opcode_Smla);
  rInsn.Length() += 4;

  // field: x
  /* unhandled field x */

  // field: y
  /* unhandled field y */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<16, 19>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: Ra
  u32 RegA = ExtractBits<12, 15>(Opcode);
  auto pOprd3 = Expr::MakeId(RegA + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// QADD<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(0)', '(0)', '(0)', '(0)', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_QADD_A1_0ff00ff0_01000050(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("QADD");
  rInsn.SetOpcode(ARM_Opcode_Qadd);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd2 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// TST<c> <Rn>, <Rm>{,<shift>} - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_TST_A1_0ff0f010_01100000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("TST");
  rInsn.SetOpcode(ARM_Opcode_Tst);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// TST<c> <Rn>, <Rm>, <type> <Rs> - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_TST_A1_0ff0f090_01100010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("TST");
  rInsn.SetOpcode(ARM_Opcode_Tst);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: type
  /* unhandled field type */

  // field: Rs
  u32 RegS = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegS + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BX<c> Rm - ['call'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 1, 0, '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_BX_A1_0ffffff0_012fff10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BX");
  rInsn.SetOpcode(ARM_Opcode_Bx);
  rInsn.Length() += 4;
  rInsn.SubType() |= Instruction::CallType;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd0 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BXJ<c> <Rm> - ['call'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 1, 0, '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_BXJ_A1_0ffffff0_012fff20(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BXJ");
  rInsn.SetOpcode(ARM_Opcode_Bxj);
  rInsn.Length() += 4;
  rInsn.SubType() |= Instruction::CallType;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd0 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BLX<c> <Rm> - ['call'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 1, 0, '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_BLX_A1_0ffffff0_012fff30(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BLX");
  rInsn.SetOpcode(ARM_Opcode_Blx);
  rInsn.Length() += 4;
  rInsn.SubType() |= Instruction::CallType;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd0 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMLAW<y><c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 1, 0, 'd', 'd', 'd', 'd', 'a', 'a', 'a', 'a', 'm', 'm', 'm', 'm', 1, 'M', 0, 0, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_SMLAW_A1_0ff000b0_01200080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMLAW");
  rInsn.SetOpcode(ARM_Opcode_Smlaw);
  rInsn.Length() += 4;

  // field: y
  /* unhandled field y */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<16, 19>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: Ra
  u32 RegA = ExtractBits<12, 15>(Opcode);
  auto pOprd3 = Expr::MakeId(RegA + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMULW<y><c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 1, 0, 'd', 'd', 'd', 'd', 'sbz', 'sbz', 'sbz', 'sbz', 'm', 'm', 'm', 'm', 1, 'M', 1, 0, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_SMULW_A1_0ff000b0_012000a0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMULW");
  rInsn.SetOpcode(ARM_Opcode_Smulw);
  rInsn.Length() += 4;

  // field: y
  /* unhandled field y */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<16, 19>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BKPT #<imm> - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 0, 1, 1, 1, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_BKPT_A1_0ff000f0_01200070(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BKPT");
  rInsn.SetOpcode(ARM_Opcode_Bkpt);
  rInsn.Length() += 4;

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 4>(ExtractBits<0, 3>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MSR<c> <spec_reg>, <Rn> - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 1, 0, 'mask_4', 'mask_4', 0, 0, '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 0, 0, 0, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_MSR_A1_0ff3fff0_0120f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MSR");
  rInsn.SetOpcode(ARM_Opcode_Msr);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: spec_reg
  /* unhandled field spec_reg */

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// QSUB<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(0)', '(0)', '(0)', '(0)', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_QSUB_A1_0ff00ff0_01200050(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("QSUB");
  rInsn.SetOpcode(ARM_Opcode_Qsub);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd2 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// TEQ<c> <Rn>, <Rm>{,<shift>} - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 1, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_TEQ_A1_0ff0f010_01300000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("TEQ");
  rInsn.SetOpcode(ARM_Opcode_Teq);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// TEQ<c> <Rn>, <Rm>, <type> <Rs> - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 0, 1, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_TEQ_A1_0ff0f090_01300010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("TEQ");
  rInsn.SetOpcode(ARM_Opcode_Teq);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: type
  /* unhandled field type */

  // field: Rs
  u32 RegS = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegS + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMLAL<x><y><c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 1, 0, 0, 'dhi', 'dhi', 'dhi', 'dhi', 'dlo', 'dlo', 'dlo', 'dlo', 'm', 'm', 'm', 'm', 1, 'M', 'N', 0, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_SMLAL_A1_0ff00090_01400080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMLAL");
  rInsn.SetOpcode(ARM_Opcode_Smlal);
  rInsn.Length() += 4;

  // field: x
  /* unhandled field x */

  // field: y
  /* unhandled field y */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: RdLo
  /* unhandled field RdLo */

  // field: RdHi
  /* unhandled field RdHi */

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// QDADD<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 1, 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(0)', '(0)', '(0)', '(0)', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_QDADD_A1_0ff00ff0_01400050(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("QDADD");
  rInsn.SetOpcode(ARM_Opcode_Qdadd);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd2 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CMP<c> <Rn>, <Rm>{,<shift>} - ['cond'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 1, 0, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_CMP_A1_0ff0f010_01500000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CMP");
  rInsn.SetOpcode(ARM_Opcode_Cmp);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CMP<c> <Rn>, <Rm>, <type> <Rs> - ['cond'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 1, 0, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_CMP_A1_0ff0f090_01500010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CMP");
  rInsn.SetOpcode(ARM_Opcode_Cmp);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: type
  /* unhandled field type */

  // field: Rs
  u32 RegS = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegS + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CLZ<c> <Rd>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 1, 1, 0, '(1)', '(1)', '(1)', '(1)', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_CLZ_A1_0fff0ff0_016f0f10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CLZ");
  rInsn.SetOpcode(ARM_Opcode_Clz);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMUL<x><y><c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 1, 1, 0, 'd', 'd', 'd', 'd', 'sbz', 'sbz', 'sbz', 'sbz', 'm', 'm', 'm', 'm', 1, 'M', 'N', 0, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_SMUL_A1_0ff00090_01600080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMUL");
  rInsn.SetOpcode(ARM_Opcode_Smul);
  rInsn.Length() += 4;

  // field: x
  /* unhandled field x */

  // field: y
  /* unhandled field y */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<16, 19>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// QDSUB<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 1, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(0)', '(0)', '(0)', '(0)', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_QDSUB_A1_0ff00ff0_01600050(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("QDSUB");
  rInsn.SetOpcode(ARM_Opcode_Qdsub);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd2 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CMN<c> <Rn>, <Rm>{,<shift>} - ['cond'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 1, 1, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_CMN_A1_0ff0f010_01700000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CMN");
  rInsn.SetOpcode(ARM_Opcode_Cmn);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CMN<c> <Rn>, <Rm>, <type> <Rs> - ['cond'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 1, 1, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_CMN_A1_0ff0f090_01700010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CMN");
  rInsn.SetOpcode(ARM_Opcode_Cmn);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: type
  /* unhandled field type */

  // field: Rs
  u32 RegS = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegS + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SWP{B}<c> <Rt>, <Rt2>, [<Rn>] - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 0, 'B', 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 0, 0, 1, 't2', 't2', 't2', 't2']
bool ArmArchitecture::Instruction_SWP_A1_0fb00ff0_01000090(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SWP");
  rInsn.SetOpcode(ARM_Opcode_Swp);
  rInsn.Length() += 4;

  // field: B
  /* unhandled field B */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STREX<c> <Rd>, <Rt>, [<Rn>] - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, 't', 't', 't', 't']
bool ArmArchitecture::Instruction_STREX_A1_0ff00ff0_01800f90(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STREX");
  rInsn.SetOpcode(ARM_Opcode_Strex);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt
  u32 RegT = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd2 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDREX<c> <Rt>, [<Rn>] - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, '(1)', '(1)', '(1)', '(1)']
bool ArmArchitecture::Instruction_LDREX_A1_0ff00fff_01900f9f(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDREX");
  rInsn.SetOpcode(ARM_Opcode_Ldrex);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ORR{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_ORR_A1_0fe00010_01800000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ORR");
  rInsn.SetOpcode(ARM_Opcode_Orr);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ORR{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_ORR_A1_0fe00090_01800010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ORR");
  rInsn.SetOpcode(ARM_Opcode_Orr);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: type
  /* unhandled field type */

  // field: Rs
  u32 RegS = ExtractBits<8, 11>(Opcode);
  auto pOprd3 = Expr::MakeId(RegS + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STREXD<c> <Rd>, <Rt>, <Rt2>, [<Rn>] - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, 't', 't', 't', 't']
bool ArmArchitecture::Instruction_STREXD_A1_0ff00ff0_01a00f90(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STREXD");
  rInsn.SetOpcode(ARM_Opcode_Strexd);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt
  u32 RegT = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd2 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDREXD<c> <Rt>, <Rt2>, [<Rn>] - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, '(1)', '(1)', '(1)', '(1)']
bool ArmArchitecture::Instruction_LDREXD_A1_0ff00fff_01b00f9f(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDREXD");
  rInsn.SetOpcode(ARM_Opcode_Ldrexd);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MOV{S}<c> <Rd>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 0, 0, 0, 0, 0, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MOV_A1_0fef0ff0_01a00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MOV");
  rInsn.SetOpcode(ARM_Opcode_Mov);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// RRX{S}<c> <Rd>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 0, 0, 0, 0, 0, 1, 1, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_RRX_A1_0fef0ff0_01a00060(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("RRX");
  rInsn.SetOpcode(ARM_Opcode_Rrx);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LSL{S}<c> <Rd>, <Rm>, #<imm5> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LSL_A1_0fef0070_01a00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LSL");
  rInsn.SetOpcode(ARM_Opcode_Lsl);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm5
  /* unhandled field imm5 */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LSR{S}<c> <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 0, 1, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LSR_A1_0fef0070_01a00020(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LSR");
  rInsn.SetOpcode(ARM_Opcode_Lsr);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 12>(ExtractBits<7, 11>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ASR{S}<c> <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 1, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_ASR_A1_0fef0070_01a00040(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ASR");
  rInsn.SetOpcode(ARM_Opcode_Asr);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 12>(ExtractBits<7, 11>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ROR{S}<c> <Rd>, <Rm>, #<imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 1, 1, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_ROR_A1_0fef0070_01a00060(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ROR");
  rInsn.SetOpcode(ARM_Opcode_Ror);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 12>(ExtractBits<7, 11>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LSL{S}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'm', 'm', 'm', 'm', 0, 0, 0, 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_LSL_A1_0fef00f0_01a00010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LSL");
  rInsn.SetOpcode(ARM_Opcode_Lsl);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LSR{S}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'm', 'm', 'm', 'm', 0, 0, 1, 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_LSR_A1_0fef00f0_01a00030(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LSR");
  rInsn.SetOpcode(ARM_Opcode_Lsr);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ASR{S}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'm', 'm', 'm', 'm', 0, 1, 0, 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_ASR_A1_0fef00f0_01a00050(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ASR");
  rInsn.SetOpcode(ARM_Opcode_Asr);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ROR{S}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'm', 'm', 'm', 'm', 0, 1, 1, 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_ROR_A1_0fef00f0_01a00070(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ROR");
  rInsn.SetOpcode(ARM_Opcode_Ror);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STREXB<c> <Rd>, <Rt>, [<Rn>] - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, 't', 't', 't', 't']
bool ArmArchitecture::Instruction_STREXB_A1_0ff00ff0_01c00f90(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STREXB");
  rInsn.SetOpcode(ARM_Opcode_Strexb);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt
  u32 RegT = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd2 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDREXB<c> <Rt>, [<Rn>] - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, '(1)', '(1)', '(1)', '(1)']
bool ArmArchitecture::Instruction_LDREXB_A1_0ff00fff_01d00f9f(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDREXB");
  rInsn.SetOpcode(ARM_Opcode_Ldrexb);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BIC{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 1, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_BIC_A1_0fe00010_01c00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BIC");
  rInsn.SetOpcode(ARM_Opcode_Bic);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BIC{S}<c> <Rd>, <Rn>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 1, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_BIC_A1_0fe00090_01c00010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BIC");
  rInsn.SetOpcode(ARM_Opcode_Bic);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: type
  /* unhandled field type */

  // field: Rs
  u32 RegS = ExtractBits<8, 11>(Opcode);
  auto pOprd3 = Expr::MakeId(RegS + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STREXH<c> <Rd>, <Rt>, [<Rn>] - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 1, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, 't', 't', 't', 't']
bool ArmArchitecture::Instruction_STREXH_A1_0ff00ff0_01e00f90(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STREXH");
  rInsn.SetOpcode(ARM_Opcode_Strexh);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt
  u32 RegT = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd2 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDREXH<c> <Rt>, [<Rn>] - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 1, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, '(1)', '(1)', '(1)', '(1)']
bool ArmArchitecture::Instruction_LDREXH_A1_0ff00fff_01f00f9f(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDREXH");
  rInsn.SetOpcode(ARM_Opcode_Ldrexh);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MVN{S}<c> <Rd>, <Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 1, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MVN_A1_0fef0010_01e00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MVN");
  rInsn.SetOpcode(ARM_Opcode_Mvn);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MVN{S}<c> <Rd>, <Rm>, <type> <Rs> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 1, 1, 1, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 's', 's', 's', 's', 0, 'tp', 'tp', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MVN_A1_0fef0090_01e00010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MVN");
  rInsn.SetOpcode(ARM_Opcode_Mvn);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: type
  /* unhandled field type */

  // field: Rs
  u32 RegS = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegS + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRD<c> <Rt>, <Rt2>, [PC,#-0] - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, '(1)', 'U', 1, '(0)', 0, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 1, 0, 1, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRD_A1_0f7f00f0_014f00d0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRD");
  rInsn.SetOpcode(ARM_Opcode_Ldrd);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: [PC,#-0]
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_RegPC, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRH<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, '(1)', 'U', 1, '(0)', 1, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 0, 1, 1, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRH_A1_0f7f00f0_015f00b0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRH");
  rInsn.SetOpcode(ARM_Opcode_Ldrh);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [PC,#-0]
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_RegPC, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSB<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, '(1)', 'U', 1, '(0)', 1, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 1, 0, 1, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRSB_A1_0f7f00f0_015f00d0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSB");
  rInsn.SetOpcode(ARM_Opcode_Ldrsb);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [PC,#-0]
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_RegPC, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSH<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, '(1)', 'U', 1, '(0)', 1, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRSH_A1_0f7f00f0_015f00f0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSH");
  rInsn.SetOpcode(ARM_Opcode_Ldrsh);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [PC,#-0]
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_RegPC, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRH<c> <Rt>, [<Rn>],+/-<Rm> - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 0, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 0, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_STRH_A1_0e500ff0_000000b0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRH");
  rInsn.SetOpcode(ARM_Opcode_Strh);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: +/-<Rm>
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRD<c> <Rt>, <Rt2>, [<Rn>],+/-<Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 0, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 1, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LDRD_A1_0e500ff0_000000d0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRD");
  rInsn.SetOpcode(ARM_Opcode_Ldrd);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: +/-<Rm>
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRD<c> <Rt>, <Rt2>, [<Rn>],+/-<Rm> - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 0, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_STRD_A1_0e500ff0_000000f0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRD");
  rInsn.SetOpcode(ARM_Opcode_Strd);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: +/-<Rm>
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRH<c> <Rt>, [<Rn>],+/-<Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 0, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 0, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LDRH_A1_0e500ff0_001000b0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRH");
  rInsn.SetOpcode(ARM_Opcode_Ldrh);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: +/-<Rm>
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSB<c> <Rt>, [<Rn>],+/-<Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 0, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 1, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LDRSB_A1_0e500ff0_001000d0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSB");
  rInsn.SetOpcode(ARM_Opcode_Ldrsb);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: +/-<Rm>
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSH<c> <Rt>, [<Rn>],+/-<Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 0, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(0)', '(0)', '(0)', '(0)', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LDRSH_A1_0e500ff0_001000f0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSH");
  rInsn.SetOpcode(ARM_Opcode_Ldrsh);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: +/-<Rm>
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRH<c> <Rt>, [<Rn>, #<imm>]! - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 1, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 0, 1, 1, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STRH_A1_0e5000f0_004000b0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRH");
  rInsn.SetOpcode(ARM_Opcode_Strh);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */

  // field: !
  rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRD<c> <Rt>, <Rt2>, [<Rn>, #<imm>]! - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 1, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 1, 0, 1, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRD_A1_0e5000f0_004000d0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRD");
  rInsn.SetOpcode(ARM_Opcode_Ldrd);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */

  // field: !
  rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRD<c> <Rt>, <Rt2>, [<Rn>, #<imm>]! - [] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 1, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STRD_A1_0e5000f0_004000f0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRD");
  rInsn.SetOpcode(ARM_Opcode_Strd);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */

  // field: !
  rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRH<c> <Rt>, [<Rn>, #<imm>]! - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 1, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 0, 1, 1, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRH_A1_0e5000f0_005000b0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRH");
  rInsn.SetOpcode(ARM_Opcode_Ldrh);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */

  // field: !
  rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSB<c> <Rt>, [<Rn>, #<imm>]! - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 1, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 1, 0, 1, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRSB_A1_0e5000f0_005000d0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSB");
  rInsn.SetOpcode(ARM_Opcode_Ldrsb);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */

  // field: !
  rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSH<c> <Rt>, [<Rn>, #<imm>]! - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 0, 'P', 'U', 1, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRSH_A1_0e5000f0_005000f0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSH");
  rInsn.SetOpcode(ARM_Opcode_Ldrsh);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */

  // field: !
  rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// AND{S}<c> <Rd>, <Rn>, #<arm_expand_imm_c> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 0, 0, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_AND_A1_0fe00000_02000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("AND");
  rInsn.SetOpcode(ARM_Opcode_And);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: arm_expand_imm_c
  auto pOprd2 = Expr::MakeConst(32, UnsignedRotateRight(ExtractBits<0, 7>(Opcode), ExtractBits<8, 11>(Opcode) << 1));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// EOR{S}<c> <Rd>, <Rn>, #<arm_expand_imm_c> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 0, 0, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_EOR_A1_0fe00000_02200000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("EOR");
  rInsn.SetOpcode(ARM_Opcode_Eor);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: arm_expand_imm_c
  auto pOprd2 = Expr::MakeConst(32, UnsignedRotateRight(ExtractBits<0, 7>(Opcode), ExtractBits<8, 11>(Opcode) << 1));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SUB <Rd>, PC, #0 - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_SUB_A2_0fff0000_024f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SUB");
  rInsn.SetOpcode(ARM_Opcode_Sub);
  rInsn.Length() += 4;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: PC
  auto pOprd1 = Expr::MakeId(ARM_RegPC, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: #0
  auto pOprd2 = Expr::MakeConst(32, 0);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SUB{S}<c> <Rd>, SP, #<arm_expand_imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 0, 1, 0, 'S', 1, 1, 0, 1, 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_SUB_A1_0fef0000_024d0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SUB");
  rInsn.SetOpcode(ARM_Opcode_Sub);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: SP
  auto pOprd1 = Expr::MakeId(ARM_RegSP, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: arm_expand_imm
  auto pOprd2 = Expr::MakeConst(32, UnsignedRotateRight(ExtractBits<0, 7>(Opcode), ExtractBits<8, 11>(Opcode) << 1));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SUB{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 0, 1, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_SUB_A1_0fe00000_02400000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SUB");
  rInsn.SetOpcode(ARM_Opcode_Sub);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: arm_expand_imm
  auto pOprd2 = Expr::MakeConst(32, UnsignedRotateRight(ExtractBits<0, 7>(Opcode), ExtractBits<8, 11>(Opcode) << 1));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// RSB{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 0, 1, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_RSB_A1_0fe00000_02600000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("RSB");
  rInsn.SetOpcode(ARM_Opcode_Rsb);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: arm_expand_imm
  auto pOprd2 = Expr::MakeConst(32, UnsignedRotateRight(ExtractBits<0, 7>(Opcode), ExtractBits<8, 11>(Opcode) << 1));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADR<c> <Rd>, <arm_expand_label> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_ADR_A1_0fff0000_028f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADR");
  rInsn.SetOpcode(ARM_Opcode_Adr);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: arm_expand_label
  auto pOprd1 = Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(ARM_RegPC, &m_CpuInfo),
    Expr::MakeConst(32, UnsignedRotateRight(ExtractBits<0, 7>(Opcode), ExtractBits<8, 11>(Opcode) << 1)));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADD{S}<c> <Rd>, SP, #<arm_expand_imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 1, 0, 0, 'S', 1, 1, 0, 1, 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_ADD_A1_0fef0000_028d0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADD");
  rInsn.SetOpcode(ARM_Opcode_Add);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: SP
  auto pOprd1 = Expr::MakeId(ARM_RegSP, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: arm_expand_imm
  auto pOprd2 = Expr::MakeConst(32, UnsignedRotateRight(ExtractBits<0, 7>(Opcode), ExtractBits<8, 11>(Opcode) << 1));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADD{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 1, 0, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_ADD_A1_0fe00000_02800000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADD");
  rInsn.SetOpcode(ARM_Opcode_Add);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: arm_expand_imm
  auto pOprd2 = Expr::MakeConst(32, UnsignedRotateRight(ExtractBits<0, 7>(Opcode), ExtractBits<8, 11>(Opcode) << 1));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val + op2.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      Expr::MakeOp(
        OperationExpression::OpAdd,
        rInsn.GetOperand(1),
        rInsn.GetOperand(2)));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADC{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 1, 0, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_ADC_A1_0fe00000_02a00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADC");
  rInsn.SetOpcode(ARM_Opcode_Adc);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: arm_expand_imm
  auto pOprd2 = Expr::MakeConst(32, UnsignedRotateRight(ExtractBits<0, 7>(Opcode), ExtractBits<8, 11>(Opcode) << 1));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SBC{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 1, 1, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_SBC_A1_0fe00000_02c00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SBC");
  rInsn.SetOpcode(ARM_Opcode_Sbc);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: arm_expand_imm
  auto pOprd2 = Expr::MakeConst(32, UnsignedRotateRight(ExtractBits<0, 7>(Opcode), ExtractBits<8, 11>(Opcode) << 1));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// RSC{S}<c> <Rd>, <Rn>, #<arm_expand_imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 0, 1, 1, 1, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_RSC_A1_0fe00000_02e00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("RSC");
  rInsn.SetOpcode(ARM_Opcode_Rsc);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: arm_expand_imm
  auto pOprd2 = Expr::MakeConst(32, UnsignedRotateRight(ExtractBits<0, 7>(Opcode), ExtractBits<8, 11>(Opcode) << 1));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MOVW<c> <Rd>, #<arm_expand_imm_c> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 0, 0, 0, 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_MOVW_A2_0ff00000_03000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MOVW");
  rInsn.SetOpcode(ARM_Opcode_Movw);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: arm_expand_imm_c
  auto pOprd1 = Expr::MakeConst(32, UnsignedRotateRight(ExtractBits<0, 7>(Opcode), ExtractBits<8, 11>(Opcode) << 1));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// TST<c> <Rn>, #<arm_expand_imm_c> - [] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_TST_A1_0ff0f000_03100000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("TST");
  rInsn.SetOpcode(ARM_Opcode_Tst);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: arm_expand_imm_c
  auto pOprd1 = Expr::MakeConst(32, UnsignedRotateRight(ExtractBits<0, 7>(Opcode), ExtractBits<8, 11>(Opcode) << 1));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// NOP<c> - [] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 0, 0, 0, 0, 0, 0, 0]
bool ArmArchitecture::Instruction_NOP_A1_0fffffff_0320f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("NOP");
  rInsn.SetOpcode(ARM_Opcode_Nop);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// YIELD<c> - [] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 0, 0, 0, 0, 0, 0, 1]
bool ArmArchitecture::Instruction_YIELD_A1_0fffffff_0320f001(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("YIELD");
  rInsn.SetOpcode(ARM_Opcode_Yield);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// WFE<c> - [] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 0, 0, 0, 0, 0, 1, 0]
bool ArmArchitecture::Instruction_WFE_A1_0fffffff_0320f002(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("WFE");
  rInsn.SetOpcode(ARM_Opcode_Wfe);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// WFI<c> - [] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 0, 0, 0, 0, 0, 1, 1]
bool ArmArchitecture::Instruction_WFI_A1_0fffffff_0320f003(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("WFI");
  rInsn.SetOpcode(ARM_Opcode_Wfi);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SEV<c> - [] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 0, 0, 0, 0, 1, 0, 0]
bool ArmArchitecture::Instruction_SEV_A1_0fffffff_0320f004(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SEV");
  rInsn.SetOpcode(ARM_Opcode_Sev);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// DBG<c> #<option> - [] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 1, 1, 1, 1, 'option', 'option', 'option', 'option']
bool ArmArchitecture::Instruction_DBG_A1_0ffffff0_0320f0f0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("DBG");
  rInsn.SetOpcode(ARM_Opcode_Dbg);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: option
  /* unhandled field option */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MSR<c> <spec_reg>, #<arm_expand_imm> - [] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 0, 1, 0, 'mask_4', 'mask_4', 0, 0, '(1)', '(1)', '(1)', '(1)', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_MSR_A1_0ff3f000_0320f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MSR");
  rInsn.SetOpcode(ARM_Opcode_Msr);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: spec_reg
  /* unhandled field spec_reg */

  // field: arm_expand_imm
  auto pOprd0 = Expr::MakeConst(32, UnsignedRotateRight(ExtractBits<0, 7>(Opcode), ExtractBits<8, 11>(Opcode) << 1));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// TEQ<c> <Rn>, #<arm_expand_imm_c> - [] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 0, 1, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_TEQ_A1_0ff0f000_03300000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("TEQ");
  rInsn.SetOpcode(ARM_Opcode_Teq);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: arm_expand_imm_c
  auto pOprd1 = Expr::MakeConst(32, UnsignedRotateRight(ExtractBits<0, 7>(Opcode), ExtractBits<8, 11>(Opcode) << 1));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MOVT<c> <Rd>, #<imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 1, 0, 0, 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_MOVT_A1_0ff00000_03400000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MOVT");
  rInsn.SetOpcode(ARM_Opcode_Movt);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: imm
  auto pOprd1 = Expr::MakeConst(32, SignExtend<s64, 12>(ExtractBits<0, 11>(Opcode)));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CMP<c> <Rn>, #<arm_expand_imm> - ['cond'] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 1, 0, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_CMP_A1_0ff0f000_03500000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CMP");
  rInsn.SetOpcode(ARM_Opcode_Cmp);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: arm_expand_imm
  auto pOprd1 = Expr::MakeConst(32, UnsignedRotateRight(ExtractBits<0, 7>(Opcode), ExtractBits<8, 11>(Opcode) << 1));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CMN<c> <Rn>, #<arm_expand_imm> - ['cond'] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 0, 1, 1, 1, 'n', 'n', 'n', 'n', '(0)', '(0)', '(0)', '(0)', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_CMN_A1_0ff0f000_03700000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CMN");
  rInsn.SetOpcode(ARM_Opcode_Cmn);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: arm_expand_imm
  auto pOprd1 = Expr::MakeConst(32, UnsignedRotateRight(ExtractBits<0, 7>(Opcode), ExtractBits<8, 11>(Opcode) << 1));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ORR{S}<c> <Rd>, <Rn>, #<arm_expand_imm_c> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 1, 0, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_ORR_A1_0fe00000_03800000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ORR");
  rInsn.SetOpcode(ARM_Opcode_Orr);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: arm_expand_imm_c
  auto pOprd2 = Expr::MakeConst(32, UnsignedRotateRight(ExtractBits<0, 7>(Opcode), ExtractBits<8, 11>(Opcode) << 1));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MOV{S}<c> <Rd>, #<arm_expand_imm_c> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 1, 0, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_MOV_A1_0fef0000_03a00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MOV");
  rInsn.SetOpcode(ARM_Opcode_Mov);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: arm_expand_imm_c
  auto pOprd1 = Expr::MakeConst(32, UnsignedRotateRight(ExtractBits<0, 7>(Opcode), ExtractBits<8, 11>(Opcode) << 1));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BIC{S}<c> <Rd>, <Rn>, #<arm_expand_imm_c> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 1, 1, 0, 'S', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_BIC_A1_0fe00000_03c00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BIC");
  rInsn.SetOpcode(ARM_Opcode_Bic);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: arm_expand_imm_c
  auto pOprd2 = Expr::MakeConst(32, UnsignedRotateRight(ExtractBits<0, 7>(Opcode), ExtractBits<8, 11>(Opcode) << 1));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MVN{S}<c> <Rd>, #<arm_expand_imm_c> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 0, 1, 1, 1, 1, 1, 'S', '(0)', '(0)', '(0)', '(0)', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_MVN_A1_0fef0000_03e00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MVN");
  rInsn.SetOpcode(ARM_Opcode_Mvn);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: arm_expand_imm_c
  auto pOprd1 = Expr::MakeConst(32, UnsignedRotateRight(ExtractBits<0, 7>(Opcode), ExtractBits<8, 11>(Opcode) << 1));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// POP<c> <Rt> - ['could_ret'] - ['c', 'c', 'c', 'c', 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 't', 't', 't', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]
bool ArmArchitecture::Instruction_POP_A2_0fff0fff_049d0004(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("POP");
  rInsn.SetOpcode(ARM_Opcode_Pop);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::ReturnType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = stack.mem */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      Expr::MakeMem(m_CpuInfo.GetSizeOfRegisterInBit(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode())), nullptr, Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo)));
    AllExpr.push_back(pExpr0);
    auto pExpr1 = /* Semantic: stack.id += op0.size */
    Expr::MakeAssign(
      Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo),
      Expr::MakeOp(
        OperationExpression::OpAdd,
        Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo),
        Expr::MakeConst(
          32,
          (rInsn.GetOperand(0)->GetSizeInBit() / 8))));
    AllExpr.push_back(pExpr1);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRT<c> <Rt>, [<Rn>] {, #<imm>} - [] - ['c', 'c', 'c', 'c', 0, 1, 0, 0, 'U', 0, 1, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STRT_A1_0f700000_04200000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRT");
  rInsn.SetOpcode(ARM_Opcode_Strt);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: {,,#<imm>}
  /* unhandled field {,,#<imm>} */

  // field: #<imm>}
  /* unhandled field #<imm>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRT<c> <Rt>, [<Rn>] {,#<imm>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 0, 0, 'U', 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRT_A1_0f700000_04300000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRT");
  rInsn.SetOpcode(ARM_Opcode_Ldrt);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: {,#<imm>}
  /* unhandled field {,#<imm>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRBT<c> <Rt>, [<Rn>], #<imm> - [] - ['c', 'c', 'c', 'c', 0, 1, 0, 0, 'U', 1, 1, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STRBT_A1_0f700000_04600000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRBT");
  rInsn.SetOpcode(ARM_Opcode_Strbt);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 12>(ExtractBits<0, 11>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRBT<c> <Rt>, [<Rn>], #<imm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 0, 0, 'U', 1, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRBT_A1_0f700000_04700000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRBT");
  rInsn.SetOpcode(ARM_Opcode_Ldrbt);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 12>(ExtractBits<0, 11>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// PUSH<c> <Rt> - [] - ['c', 'c', 'c', 'c', 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 't', 't', 't', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]
bool ArmArchitecture::Instruction_PUSH_A2_0fff0fff_052d0004(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("PUSH");
  rInsn.SetOpcode(ARM_Opcode_Push);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: stack.id -= op0.size */
    Expr::MakeAssign(
      Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo),
      Expr::MakeOp(
        OperationExpression::OpSub,
        Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo),
        Expr::MakeConst(
          32,
          (rInsn.GetOperand(0)->GetSizeInBit() / 8))));
    AllExpr.push_back(pExpr0);
    auto pExpr1 = /* Semantic: stack.mem = op0.val */
    Expr::MakeAssign(
      Expr::MakeMem(m_CpuInfo.GetSizeOfRegisterInBit(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode())), nullptr, Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo)),
      rInsn.GetOperand(0));
    AllExpr.push_back(pExpr1);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDR<c> <Rt>, <u_label> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 0, '(1)', 'U', 0, '(0)', 1, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDR_A1_0f7f0000_051f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDR");
  rInsn.SetOpcode(ARM_Opcode_Ldr);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: u_label
  auto OpType = (ExtractBit<23>(Opcode)) ? OperationExpression::OpAdd : OperationExpression::OpSub;
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeOp(OpType,
    Expr::MakeId(ARM_RegPC, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 12>(ExtractBits<0, 11>(Opcode)))), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRB<c> <Rt>, [PC,#-0] - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 0, '(1)', 'U', 1, '(0)', 1, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRB_A1_0f7f0000_055f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRB");
  rInsn.SetOpcode(ARM_Opcode_Ldrb);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [PC,#-0]
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_RegPC, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STR<c> <Rt>, [<Rn>,#<imm>]! - [] - ['c', 'c', 'c', 'c', 0, 1, 0, 'P', 'U', 0, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STR_A1_0e500000_04000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STR");
  rInsn.SetOpcode(ARM_Opcode_Str);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>,#<imm>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(RegN + 1, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 12>(ExtractBits<0, 11>(Opcode)))), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: !
  rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDR<c> <Rt>, [<Rn>,#<imm>]! - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 0, 'P', 'U', 0, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDR_A1_0e500000_04100000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDR");
  rInsn.SetOpcode(ARM_Opcode_Ldr);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>,#<imm>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(RegN + 1, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 12>(ExtractBits<0, 11>(Opcode)))), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: !
  rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRB<c> <Rt>, [<Rn>,#<imm>]! - [] - ['c', 'c', 'c', 'c', 0, 1, 0, 'P', 'U', 1, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STRB_A1_0e500000_04400000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRB");
  rInsn.SetOpcode(ARM_Opcode_Strb);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>,#<imm>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(RegN + 1, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 12>(ExtractBits<0, 11>(Opcode)))), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: !
  rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRB<c> <Rt>, [<Rn>,#<imm>]! - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 0, 'P', 'U', 1, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRB_A1_0e500000_04500000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRB");
  rInsn.SetOpcode(ARM_Opcode_Ldrb);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>,#<imm>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(RegN + 1, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 12>(ExtractBits<0, 11>(Opcode)))), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: !
  rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SADD16_A1_0ff00ff0_06100f10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SADD16");
  rInsn.SetOpcode(ARM_Opcode_Sadd16);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SASX_A1_0ff00ff0_06100f30(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SASX");
  rInsn.SetOpcode(ARM_Opcode_Sasx);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SSAX_A1_0ff00ff0_06100f50(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SSAX");
  rInsn.SetOpcode(ARM_Opcode_Ssax);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SSUB16_A1_0ff00ff0_06100f70(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SSUB16");
  rInsn.SetOpcode(ARM_Opcode_Ssub16);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SADD8_A1_0ff00ff0_06100f90(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SADD8");
  rInsn.SetOpcode(ARM_Opcode_Sadd8);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SSUB8_A1_0ff00ff0_06100ff0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SSUB8");
  rInsn.SetOpcode(ARM_Opcode_Ssub8);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// QADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_QADD16_A1_0ff00ff0_06200f10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("QADD16");
  rInsn.SetOpcode(ARM_Opcode_Qadd16);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// QASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_QASX_A1_0ff00ff0_06200f30(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("QASX");
  rInsn.SetOpcode(ARM_Opcode_Qasx);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// QSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_QSAX_A1_0ff00ff0_06200f50(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("QSAX");
  rInsn.SetOpcode(ARM_Opcode_Qsax);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// QSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_QSUB16_A1_0ff00ff0_06200f70(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("QSUB16");
  rInsn.SetOpcode(ARM_Opcode_Qsub16);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// QADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_QADD8_A1_0ff00ff0_06200f90(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("QADD8");
  rInsn.SetOpcode(ARM_Opcode_Qadd8);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// QSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_QSUB8_A1_0ff00ff0_06200ff0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("QSUB8");
  rInsn.SetOpcode(ARM_Opcode_Qsub8);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SHADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SHADD16_A1_0ff00ff0_06300f10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SHADD16");
  rInsn.SetOpcode(ARM_Opcode_Shadd16);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SHASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SHASX_A1_0ff00ff0_06300f30(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SHASX");
  rInsn.SetOpcode(ARM_Opcode_Shasx);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SHSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SHSAX_A1_0ff00ff0_06300f50(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SHSAX");
  rInsn.SetOpcode(ARM_Opcode_Shsax);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SHSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SHSUB16_A1_0ff00ff0_06300f70(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SHSUB16");
  rInsn.SetOpcode(ARM_Opcode_Shsub16);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SHADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SHADD8_A1_0ff00ff0_06300f90(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SHADD8");
  rInsn.SetOpcode(ARM_Opcode_Shadd8);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SHSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SHSUB8_A1_0ff00ff0_06300ff0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SHSUB8");
  rInsn.SetOpcode(ARM_Opcode_Shsub8);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UADD16<c> <Rd>, <Rn>, <Rm> - [] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UADD16_A1_0ff00ff0_06500f10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UADD16");
  rInsn.SetOpcode(ARM_Opcode_Uadd16);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  return true;
}
// UASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UASX_A1_0ff00ff0_06500f30(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UASX");
  rInsn.SetOpcode(ARM_Opcode_Uasx);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// USAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_USAX_A1_0ff00ff0_06500f50(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("USAX");
  rInsn.SetOpcode(ARM_Opcode_Usax);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// USUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_USUB16_A1_0ff00ff0_06500f70(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("USUB16");
  rInsn.SetOpcode(ARM_Opcode_Usub16);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UADD8_A1_0ff00ff0_06500f90(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UADD8");
  rInsn.SetOpcode(ARM_Opcode_Uadd8);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// USUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_USUB8_A1_0ff00ff0_06500ff0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("USUB8");
  rInsn.SetOpcode(ARM_Opcode_Usub8);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UQADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UQADD16_A1_0ff00ff0_06600f10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UQADD16");
  rInsn.SetOpcode(ARM_Opcode_Uqadd16);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UQASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UQASX_A1_0ff00ff0_06600f30(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UQASX");
  rInsn.SetOpcode(ARM_Opcode_Uqasx);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UQSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UQSAX_A1_0ff00ff0_06600f50(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UQSAX");
  rInsn.SetOpcode(ARM_Opcode_Uqsax);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UQSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UQSUB16_A1_0ff00ff0_06600f70(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UQSUB16");
  rInsn.SetOpcode(ARM_Opcode_Uqsub16);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UQADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UQADD8_A1_0ff00ff0_06600f90(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UQADD8");
  rInsn.SetOpcode(ARM_Opcode_Uqadd8);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UQSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UQSUB8_A1_0ff00ff0_06600ff0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UQSUB8");
  rInsn.SetOpcode(ARM_Opcode_Uqsub8);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UHADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UHADD16_A1_0ff00ff0_06700f10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UHADD16");
  rInsn.SetOpcode(ARM_Opcode_Uhadd16);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UHASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UHASX_A1_0ff00ff0_06700f30(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UHASX");
  rInsn.SetOpcode(ARM_Opcode_Uhasx);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UHSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UHSAX_A1_0ff00ff0_06700f50(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UHSAX");
  rInsn.SetOpcode(ARM_Opcode_Uhsax);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UHSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UHSUB16_A1_0ff00ff0_06700f70(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UHSUB16");
  rInsn.SetOpcode(ARM_Opcode_Uhsub16);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UHADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UHADD8_A1_0ff00ff0_06700f90(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UHADD8");
  rInsn.SetOpcode(ARM_Opcode_Uhadd8);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UHSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 0, 1, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UHSUB8_A1_0ff00ff0_06700ff0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UHSUB8");
  rInsn.SetOpcode(ARM_Opcode_Uhsub8);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SXTB16<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SXTB16_A1_0fff03f0_068f0070(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SXTB16");
  rInsn.SetOpcode(ARM_Opcode_Sxtb16);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SEL<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SEL_A1_0ff00ff0_06800fb0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SEL");
  rInsn.SetOpcode(ARM_Opcode_Sel);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// PKHTB<c> <Rd>, <Rn>, <Rm>{,ASR #<imm>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'tb', 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_PKHTB_A1_0ff00030_06800010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("PKHTB");
  rInsn.SetOpcode(ARM_Opcode_Pkhtb);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,ASR
  /* unhandled field <Rm>{,ASR */

  // field: #<imm>}
  /* unhandled field #<imm>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SXTAB16<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SXTAB16_A1_0ff003f0_06800070(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SXTAB16");
  rInsn.SetOpcode(ARM_Opcode_Sxtab16);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SXTB<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SXTB_A1_0fff03f0_06af0070(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SXTB");
  rInsn.SetOpcode(ARM_Opcode_Sxtb);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SSAT16<c> <Rd>, #<imm>, <Rn> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_SSAT16_A1_0ff00ff0_06a00f30(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SSAT16");
  rInsn.SetOpcode(ARM_Opcode_Ssat16);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: imm
  auto pOprd1 = Expr::MakeConst(32, SignExtend<s64, 20>(ExtractBits<16, 19>(Opcode)));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SXTAB<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SXTAB_A1_0ff003f0_06a00070(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SXTAB");
  rInsn.SetOpcode(ARM_Opcode_Sxtab);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SXTH<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SXTH_A1_0fff03f0_06bf0070(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SXTH");
  rInsn.SetOpcode(ARM_Opcode_Sxth);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// REV<c> <Rd>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 1, 1, '(1)', '(1)', '(1)', '(1)', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_REV_A1_0fff0ff0_06bf0f30(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("REV");
  rInsn.SetOpcode(ARM_Opcode_Rev);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// REV16<c> <Rd>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 1, 1, '(1)', '(1)', '(1)', '(1)', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_REV16_A1_0fff0ff0_06bf0fb0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("REV16");
  rInsn.SetOpcode(ARM_Opcode_Rev16);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SXTAH<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SXTAH_A1_0ff003f0_06b00070(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SXTAH");
  rInsn.SetOpcode(ARM_Opcode_Sxtah);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SSAT<c> <Rd>, #<imm>, <Rn>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 0, 1, 'sat_imm_5', 'sat_imm_5', 'sat_imm_5', 'sat_imm_5', 'sat_imm_5', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'sh', 0, 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_SSAT_A1_0fe00030_06a00010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SSAT");
  rInsn.SetOpcode(ARM_Opcode_Ssat);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: imm
  auto pOprd1 = Expr::MakeConst(32, SignExtend<s64, 12>(ExtractBits<7, 11>(Opcode)));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rn>{,<shift>}
  /* unhandled field <Rn>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UXTB16<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UXTB16_A1_0fff03f0_06cf0070(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UXTB16");
  rInsn.SetOpcode(ARM_Opcode_Uxtb16);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UXTAB16<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UXTAB16_A1_0ff003f0_06c00070(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UXTAB16");
  rInsn.SetOpcode(ARM_Opcode_Uxtab16);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UXTB<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UXTB_A1_0fff03f0_06ef0070(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UXTB");
  rInsn.SetOpcode(ARM_Opcode_Uxtb);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// USAT16<c> <Rd>, #<imm4>, <Rn> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_USAT16_A1_0ff00ff0_06e00f30(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("USAT16");
  rInsn.SetOpcode(ARM_Opcode_Usat16);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: imm4
  /* unhandled field imm4 */

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UXTAB<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 1, 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UXTAB_A1_0ff003f0_06e00070(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UXTAB");
  rInsn.SetOpcode(ARM_Opcode_Uxtab);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UXTH<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UXTH_A1_0fff03f0_06ff0070(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UXTH");
  rInsn.SetOpcode(ARM_Opcode_Uxth);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// RBIT<c> <Rd>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 1, 1, 1, '(1)', '(1)', '(1)', '(1)', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_RBIT_A1_0fff0ff0_06ff0f30(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("RBIT");
  rInsn.SetOpcode(ARM_Opcode_Rbit);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// REVSH<c> <Rd>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 1, 1, 1, '(1)', '(1)', '(1)', '(1)', 'd', 'd', 'd', 'd', '(1)', '(1)', '(1)', '(1)', 1, 0, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_REVSH_A1_0fff0ff0_06ff0fb0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("REVSH");
  rInsn.SetOpcode(ARM_Opcode_Revsh);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UXTAH<c> <Rd>, <Rn>, <Rm>{,<rotation>} - [] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 1, 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'rotate', 'rotate', '(0)', '(0)', 0, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UXTAH_A1_0ff003f0_06f00070(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UXTAH");
  rInsn.SetOpcode(ARM_Opcode_Uxtah);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  return true;
}
// USAT<c> <Rd>, #<imm5>, <Rn>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 1, 1, 1, 'sat_imm_5', 'sat_imm_5', 'sat_imm_5', 'sat_imm_5', 'sat_imm_5', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'sh', 0, 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_USAT_A1_0fe00030_06e00010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("USAT");
  rInsn.SetOpcode(ARM_Opcode_Usat);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: imm5
  /* unhandled field imm5 */

  // field: <Rn>{,<shift>}
  /* unhandled field <Rn>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRT<c> <Rt>, [<Rn>],+/-<Rm>{,<shift>} - [] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 'U', 0, 1, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_STRT_A2_0f700010_06200000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRT");
  rInsn.SetOpcode(ARM_Opcode_Strt);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: +/-<Rm>{,<shift>}
  /* unhandled field +/-<Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRT<c> <Rt>, [<Rn>],+/-<Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 'U', 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LDRT_A2_0f700010_06300000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRT");
  rInsn.SetOpcode(ARM_Opcode_Ldrt);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: +/-<Rm>{,<shift>}
  /* unhandled field +/-<Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRBT<c> <Rt>, [<Rn>],+/-<Rm>{,<shift>} - [] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 'U', 1, 1, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_STRBT_A2_0f700010_06600000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRBT");
  rInsn.SetOpcode(ARM_Opcode_Strbt);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: +/-<Rm>{,<shift>}
  /* unhandled field +/-<Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRBT<c> <Rt>, [<Rn>],+/-<Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 0, 'U', 1, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LDRBT_A2_0f700010_06700000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRBT");
  rInsn.SetOpcode(ARM_Opcode_Ldrbt);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: +/-<Rm>{,<shift>}
  /* unhandled field +/-<Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMUAD{X}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 0, 0, 0, 0, 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'm', 'm', 'm', 'm', 0, 0, 'M', 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_SMUAD_A1_0ff0f0d0_0700f010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMUAD");
  rInsn.SetOpcode(ARM_Opcode_Smuad);
  rInsn.Length() += 4;

  // field: X
  /* unhandled field X */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<16, 19>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMUSD{X}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 0, 0, 0, 0, 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'm', 'm', 'm', 'm', 0, 1, 'M', 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_SMUSD_A1_0ff0f0d0_0700f050(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMUSD");
  rInsn.SetOpcode(ARM_Opcode_Smusd);
  rInsn.Length() += 4;

  // field: X
  /* unhandled field X */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<16, 19>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMLAD{X}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 0, 0, 0, 0, 'd', 'd', 'd', 'd', 'a', 'a', 'a', 'a', 'm', 'm', 'm', 'm', 0, 0, 'M', 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_SMLAD_A1_0ff000d0_07000010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMLAD");
  rInsn.SetOpcode(ARM_Opcode_Smlad);
  rInsn.Length() += 4;

  // field: X
  /* unhandled field X */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<16, 19>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: Ra
  u32 RegA = ExtractBits<12, 15>(Opcode);
  auto pOprd3 = Expr::MakeId(RegA + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMLSD{X}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 0, 0, 0, 0, 'd', 'd', 'd', 'd', 'a', 'a', 'a', 'a', 'm', 'm', 'm', 'm', 0, 1, 'M', 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_SMLSD_A1_0ff000d0_07000050(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMLSD");
  rInsn.SetOpcode(ARM_Opcode_Smlsd);
  rInsn.Length() += 4;

  // field: X
  /* unhandled field X */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<16, 19>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: Ra
  u32 RegA = ExtractBits<12, 15>(Opcode);
  auto pOprd3 = Expr::MakeId(RegA + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMLALD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 0, 1, 0, 0, 'dhi', 'dhi', 'dhi', 'dhi', 'dlo', 'dlo', 'dlo', 'dlo', 'm', 'm', 'm', 'm', 0, 0, 'M', 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_SMLALD_A1_0ff000d0_07400010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMLALD");
  rInsn.SetOpcode(ARM_Opcode_Smlald);
  rInsn.Length() += 4;

  // field: X
  /* unhandled field X */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: RdLo
  /* unhandled field RdLo */

  // field: RdHi
  /* unhandled field RdHi */

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMLSLD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 0, 1, 0, 0, 'dhi', 'dhi', 'dhi', 'dhi', 'dlo', 'dlo', 'dlo', 'dlo', 'm', 'm', 'm', 'm', 0, 1, 'M', 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_SMLSLD_A1_0ff000d0_07400050(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMLSLD");
  rInsn.SetOpcode(ARM_Opcode_Smlsld);
  rInsn.Length() += 4;

  // field: X
  /* unhandled field X */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: RdLo
  /* unhandled field RdLo */

  // field: RdHi
  /* unhandled field RdHi */

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMMUL{R}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 0, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'm', 'm', 'm', 'm', 0, 0, 'R', 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_SMMUL_A1_0ff0f0d0_0750f010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMMUL");
  rInsn.SetOpcode(ARM_Opcode_Smmul);
  rInsn.Length() += 4;

  // field: R
  /* unhandled field R */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<16, 19>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMMLA{R}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 0, 1, 0, 1, 'd', 'd', 'd', 'd', 'a', 'a', 'a', 'a', 'm', 'm', 'm', 'm', 0, 0, 'R', 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_SMMLA_A1_0ff000d0_07500010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMMLA");
  rInsn.SetOpcode(ARM_Opcode_Smmla);
  rInsn.Length() += 4;

  // field: R
  /* unhandled field R */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<16, 19>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: Ra
  u32 RegA = ExtractBits<12, 15>(Opcode);
  auto pOprd3 = Expr::MakeId(RegA + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMMLS{R}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 0, 1, 0, 1, 'd', 'd', 'd', 'd', 'a', 'a', 'a', 'a', 'm', 'm', 'm', 'm', 1, 1, 'R', 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_SMMLS_A1_0ff000d0_075000d0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMMLS");
  rInsn.SetOpcode(ARM_Opcode_Smmls);
  rInsn.Length() += 4;

  // field: R
  /* unhandled field R */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<16, 19>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: Ra
  u32 RegA = ExtractBits<12, 15>(Opcode);
  auto pOprd3 = Expr::MakeId(RegA + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// USAD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 1, 0, 0, 0, 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'm', 'm', 'm', 'm', 0, 0, 0, 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_USAD8_A1_0ff0f0f0_0780f010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("USAD8");
  rInsn.SetOpcode(ARM_Opcode_Usad8);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<16, 19>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// USADA8<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 1, 0, 0, 0, 'd', 'd', 'd', 'd', 'a', 'a', 'a', 'a', 'm', 'm', 'm', 'm', 0, 0, 0, 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_USADA8_A1_0ff000f0_07800010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("USADA8");
  rInsn.SetOpcode(ARM_Opcode_Usada8);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<16, 19>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<8, 11>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: Ra
  u32 RegA = ExtractBits<12, 15>(Opcode);
  auto pOprd3 = Expr::MakeId(RegA + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SBFX<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 1, 0, 1, 'widthm1', 'widthm1', 'widthm1', 'widthm1', 'widthm1', 'd', 'd', 'd', 'd', 'lsb', 'lsb', 'lsb', 'lsb', 'lsb', 1, 0, 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_SBFX_A1_0fe00070_07a00050(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SBFX");
  rInsn.SetOpcode(ARM_Opcode_Sbfx);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: lsb
  /* unhandled field lsb */

  // field: width
  /* unhandled field width */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BFC<c> <Rd>, #<lsb>, #<width> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 1, 1, 0, 'msb', 'msb', 'msb', 'msb', 'msb', 'd', 'd', 'd', 'd', 'lsb', 'lsb', 'lsb', 'lsb', 'lsb', 0, 0, 1, 1, 1, 1, 1]
bool ArmArchitecture::Instruction_BFC_A1_0fe0007f_07c0001f(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BFC");
  rInsn.SetOpcode(ARM_Opcode_Bfc);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: lsb
  /* unhandled field lsb */

  // field: width
  /* unhandled field width */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BFI<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 1, 1, 0, 'msb', 'msb', 'msb', 'msb', 'msb', 'd', 'd', 'd', 'd', 'lsb', 'lsb', 'lsb', 'lsb', 'lsb', 0, 0, 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_BFI_A1_0fe00070_07c00010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BFI");
  rInsn.SetOpcode(ARM_Opcode_Bfi);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: lsb
  /* unhandled field lsb */

  // field: width
  /* unhandled field width */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UBFX<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 1, 1, 1, 1, 'widthm1', 'widthm1', 'widthm1', 'widthm1', 'widthm1', 'd', 'd', 'd', 'd', 'lsb', 'lsb', 'lsb', 'lsb', 'lsb', 1, 0, 1, 'n', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_UBFX_A1_0fe00070_07e00050(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UBFX");
  rInsn.SetOpcode(ARM_Opcode_Ubfx);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rd
  u32 RegD = ExtractBits<12, 15>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: lsb
  /* unhandled field lsb */

  // field: width
  /* unhandled field width */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STR<c> <Rt>, [<Rn>],+/-<Rm>{,<shift>} - [] - ['c', 'c', 'c', 'c', 0, 1, 1, 'P', 'U', 0, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_STR_A1_0e500010_06000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STR");
  rInsn.SetOpcode(ARM_Opcode_Str);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: +/-<Rm>{,<shift>}
  /* unhandled field +/-<Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDR<c> <Rt>, [<Rn>],+/-<Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 'P', 'U', 0, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LDR_A1_0e500010_06100000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDR");
  rInsn.SetOpcode(ARM_Opcode_Ldr);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: +/-<Rm>{,<shift>}
  /* unhandled field +/-<Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRB<c> <Rt>, [<Rn>],+/-<Rm>{,<shift>} - [] - ['c', 'c', 'c', 'c', 0, 1, 1, 'P', 'U', 1, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_STRB_A1_0e500010_06400000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRB");
  rInsn.SetOpcode(ARM_Opcode_Strb);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: +/-<Rm>{,<shift>}
  /* unhandled field +/-<Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRB<c> <Rt>, [<Rn>],+/-<Rm>{,<shift>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 0, 1, 1, 'P', 'U', 1, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'tp', 'tp', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LDRB_A1_0e500010_06500000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRB");
  rInsn.SetOpcode(ARM_Opcode_Ldrb);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: +/-<Rm>{,<shift>}
  /* unhandled field +/-<Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STMDA<c> <Rn>{!},<registers> - [] - ['c', 'c', 'c', 'c', 1, 0, 0, 0, 0, 0, 'W', 0, 'n', 'n', 'n', 'n', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
bool ArmArchitecture::Instruction_STMDA_A1_0fd00000_08000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STMDA");
  rInsn.SetOpcode(ARM_Opcode_Stmda);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rn>{!},<registers
  /* unhandled field Rn>{!},<registers */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDMDA<c> <Rn>{!},<registers> - ['could_jmp'] - ['c', 'c', 'c', 'c', 1, 0, 0, 0, 0, 0, 'W', 1, 'n', 'n', 'n', 'n', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
bool ArmArchitecture::Instruction_LDMDA_A1_0fd00000_08100000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDMDA");
  rInsn.SetOpcode(ARM_Opcode_Ldmda);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rn>{!},<registers
  /* unhandled field Rn>{!},<registers */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// POP<c> <registers> - ['could_ret'] - ['c', 'c', 'c', 'c', 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
bool ArmArchitecture::Instruction_POP_A1_0fff0000_08bd0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("POP");
  rInsn.SetOpcode(ARM_Opcode_Pop);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: registers
  u32 RegList = ExtractBits<0, 15>(Opcode);
  Expression::List IdExprs;
  for (u8 RegIdx = 0; RegIdx < 16; ++RegIdx)
  {
    if (RegList & (1 << RegIdx))
      IdExprs.push_back(Expr::MakeId(RegIdx + 1, &m_CpuInfo));
    if (RegIdx + 1 == ARM_RegPC)
      rInsn.SubType() |= Instruction::ReturnType;
  }
  auto pOprd0 = Expr::MakeBind(IdExprs);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = stack.mem */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      Expr::MakeMem(m_CpuInfo.GetSizeOfRegisterInBit(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode())), nullptr, Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo)));
    AllExpr.push_back(pExpr0);
    auto pExpr1 = /* Semantic: stack.id += op0.size */
    Expr::MakeAssign(
      Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo),
      Expr::MakeOp(
        OperationExpression::OpAdd,
        Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo),
        Expr::MakeConst(
          32,
          (rInsn.GetOperand(0)->GetSizeInBit() / 8))));
    AllExpr.push_back(pExpr1);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STM<c> <Rn>{!},<registers> - [] - ['c', 'c', 'c', 'c', 1, 0, 0, 0, 1, 0, 'W', 0, 'n', 'n', 'n', 'n', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
bool ArmArchitecture::Instruction_STM_A1_0fd00000_08800000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STM");
  rInsn.SetOpcode(ARM_Opcode_Stm);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rn>{!},<registers
  /* unhandled field Rn>{!},<registers */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDM<c> <Rn>{!},<registers> - ['could_jmp'] - ['c', 'c', 'c', 'c', 1, 0, 0, 0, 1, 0, 'W', 1, 'n', 'n', 'n', 'n', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
bool ArmArchitecture::Instruction_LDM_A1_0fd00000_08900000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDM");
  rInsn.SetOpcode(ARM_Opcode_Ldm);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rn>{!},<registers
  /* unhandled field Rn>{!},<registers */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// PUSH<c> <registers> - [] - ['c', 'c', 'c', 'c', 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
bool ArmArchitecture::Instruction_PUSH_A1_0fff0000_092d0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("PUSH");
  rInsn.SetOpcode(ARM_Opcode_Push);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: registers
  u32 RegList = ExtractBits<0, 15>(Opcode);
  Expression::List IdExprs;
  for (u8 RegIdx = 0; RegIdx < 16; ++RegIdx)
  {
    if (RegList & (1 << RegIdx))
      IdExprs.push_back(Expr::MakeId(RegIdx + 1, &m_CpuInfo));
  }
  auto pOprd0 = Expr::MakeBind(IdExprs);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: stack.id -= op0.size */
    Expr::MakeAssign(
      Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo),
      Expr::MakeOp(
        OperationExpression::OpSub,
        Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo),
        Expr::MakeConst(
          32,
          (rInsn.GetOperand(0)->GetSizeInBit() / 8))));
    AllExpr.push_back(pExpr0);
    auto pExpr1 = /* Semantic: stack.mem = op0.val */
    Expr::MakeAssign(
      Expr::MakeMem(m_CpuInfo.GetSizeOfRegisterInBit(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode())), nullptr, Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo)),
      rInsn.GetOperand(0));
    AllExpr.push_back(pExpr1);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STMDB<c> <Rn>{!},<registers> - [] - ['c', 'c', 'c', 'c', 1, 0, 0, 1, 0, 0, 'W', 0, 'n', 'n', 'n', 'n', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
bool ArmArchitecture::Instruction_STMDB_A1_0fd00000_09000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STMDB");
  rInsn.SetOpcode(ARM_Opcode_Stmdb);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rn>{!},<registers
  /* unhandled field Rn>{!},<registers */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDMDB<c> <Rn>{!},<registers> - ['could_jmp'] - ['c', 'c', 'c', 'c', 1, 0, 0, 1, 0, 0, 'W', 1, 'n', 'n', 'n', 'n', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
bool ArmArchitecture::Instruction_LDMDB_A1_0fd00000_09100000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDMDB");
  rInsn.SetOpcode(ARM_Opcode_Ldmdb);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rn>{!},<registers
  /* unhandled field Rn>{!},<registers */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STMIB<c> <Rn>{!},<registers> - [] - ['c', 'c', 'c', 'c', 1, 0, 0, 1, 1, 0, 'W', 0, 'n', 'n', 'n', 'n', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
bool ArmArchitecture::Instruction_STMIB_A1_0fd00000_09800000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STMIB");
  rInsn.SetOpcode(ARM_Opcode_Stmib);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rn>{!},<registers
  /* unhandled field Rn>{!},<registers */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDMIB<c> <Rn>{!},<registers> - ['could_jmp'] - ['c', 'c', 'c', 'c', 1, 0, 0, 1, 1, 0, 'W', 1, 'n', 'n', 'n', 'n', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
bool ArmArchitecture::Instruction_LDMIB_A1_0fd00000_09900000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDMIB");
  rInsn.SetOpcode(ARM_Opcode_Ldmib);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rn>{!},<registers
  /* unhandled field Rn>{!},<registers */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// B<c> <arm_branch_label> - ['jmp'] - ['c', 'c', 'c', 'c', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_B_A1_0f000000_0a000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("B");
  rInsn.SetOpcode(ARM_Opcode_B);
  rInsn.Length() += 4;
  rInsn.SubType() |= Instruction::JumpType;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: arm_branch_label
  auto pOprd0 = Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(ARM_RegPC, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 24>(ExtractBits<0, 23>(Opcode)) << 2));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: program.id = op0.val */
    Expr::MakeAssign(
      Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::ProgramPointerRegister, rInsn.GetMode()), &m_CpuInfo),
      rInsn.GetOperand(0));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BL<c> <arm_branch_label> - ['call'] - ['c', 'c', 'c', 'c', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_BL_A1_0f000000_0b000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BL");
  rInsn.SetOpcode(ARM_Opcode_Bl);
  rInsn.Length() += 4;
  rInsn.SubType() |= Instruction::CallType;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: arm_branch_label
  auto pOprd0 = Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(ARM_RegPC, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 24>(ExtractBits<0, 23>(Opcode)) << 2));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: lr.id = (program.id + insn.size) */
    Expr::MakeAssign(
      Expr::MakeId(ARM_RegLR, &m_CpuInfo),
      Expr::MakeOp(
        OperationExpression::OpAdd,
        Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::ProgramPointerRegister, rInsn.GetMode()), &m_CpuInfo),
        Expr::MakeConst(
          m_CpuInfo.GetSizeOfRegisterInBit(m_CpuInfo.GetRegisterByType(CpuInformation::ProgramPointerRegister, rInsn.GetMode())),
          rInsn.GetLength())));
    AllExpr.push_back(pExpr0);
    auto pExpr1 = /* Semantic: program.id = op0.val */
    Expr::MakeAssign(
      Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::ProgramPointerRegister, rInsn.GetMode()), &m_CpuInfo),
      rInsn.GetOperand(0));
    AllExpr.push_back(pExpr1);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MCRR<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 1, 1, 0, 0, 0, 1, 0, 0, 't2', 't2', 't2', 't2', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc1', 'opc1', 'opc1', 'opc1', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MCRR_A1_0ff00000_0c400000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MCRR");
  rInsn.SetOpcode(ARM_Opcode_Mcrr);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: coproc
  /* unhandled field coproc */

  // field: opc1
  /* unhandled field opc1 */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: CRm
  /* unhandled field CRm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MRRC<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm> - ['could_jmp'] - ['c', 'c', 'c', 'c', 1, 1, 0, 0, 0, 1, 0, 1, 't2', 't2', 't2', 't2', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc1', 'opc1', 'opc1', 'opc1', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MRRC_A1_0ff00000_0c500000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MRRC");
  rInsn.SetOpcode(ARM_Opcode_Mrrc);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: coproc
  /* unhandled field coproc */

  // field: opc
  /* unhandled field opc */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: CRm
  /* unhandled field CRm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMOV<c> <Rt>, <Rt2>, <Sm>, <Sm1> - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 0, 0, 1, 0, 'op', 't2', 't2', 't2', 't2', 't', 't', 't', 't', 1, 0, 1, 0, 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMOV_A1_0fe00fd0_0c400a10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMOV");
  rInsn.SetOpcode(ARM_Opcode_Vmov);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: Sm
  /* unhandled field Sm */

  // field: Sm1
  /* unhandled field Sm1 */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMOV<c> <Rt>, <Rt2>, <Dm> - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 0, 0, 1, 0, 'op', 't2', 't2', 't2', 't2', 't', 't', 't', 't', 1, 0, 1, 1, 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMOV_A1_0fe00fd0_0c400b10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMOV");
  rInsn.SetOpcode(ARM_Opcode_Vmov);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// FLDMX - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 0, 1, 'D', 1, 1, 1, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_FLDMX_A2_0fbf0f00_0cbd0a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("FLDMX");
  rInsn.SetOpcode(ARM_Opcode_Fldmx);
  rInsn.Length() += 4;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VPOP <list> - [] - ['c', 'c', 'c', 'c', 1, 1, 0, 0, 1, 'D', 1, 1, 1, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VPOP_A1_0fbf0f00_0cbd0b00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VPOP");
  rInsn.SetOpcode(ARM_Opcode_Vpop);
  rInsn.Length() += 4;

  // field: list
  /* unhandled field list */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// FSTMX - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 1, 0, 'D', 1, 0, 1, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_FSTMX_A2_0fbf0f00_0d2d0a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("FSTMX");
  rInsn.SetOpcode(ARM_Opcode_Fstmx);
  rInsn.Length() += 4;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VPUSH<c> <list> - [] - ['c', 'c', 'c', 'c', 1, 1, 0, 1, 0, 'D', 1, 0, 1, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VPUSH_A1_0fbf0f00_0d2d0b00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VPUSH");
  rInsn.SetOpcode(ARM_Opcode_Vpush);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: list
  /* unhandled field list */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSTR<c> <Sd>, [<Rn>{,#+/-<imm>}] - [] - ['c', 'c', 'c', 'c', 1, 1, 0, 1, 'U', 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VSTR_A2_0f300f00_0d000a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSTR");
  rInsn.SetOpcode(ARM_Opcode_Vstr);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Sd
  /* unhandled field Sd */

  // field: [<Rn>{,#+/-<imm>}]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeMem(32, nullptr, Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(RegN + 1, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)))), true);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSTR<c> <Dd>, [<Rn>{,#+/-<imm>}] - [] - ['c', 'c', 'c', 'c', 1, 1, 0, 1, 'U', 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VSTR_A1_0f300f00_0d000b00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSTR");
  rInsn.SetOpcode(ARM_Opcode_Vstr);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Dd
  /* unhandled field Dd */

  // field: [<Rn>{,#+/-<imm>}]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeMem(32, nullptr, Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(RegN + 1, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)))), true);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VLDR<c> <Sd>, [PC,#-0] - ['support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 1, 'U', 'D', 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VLDR_A2_0f300f00_0d100a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VLDR");
  rInsn.SetOpcode(ARM_Opcode_Vldr);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Sd
  /* unhandled field Sd */

  // field: [PC,#-0]
  auto pOprd0 = Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_RegPC, &m_CpuInfo), true);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VLDR<c> <Dd>, [PC,#-0] - ['support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 1, 'U', 'D', 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VLDR_A1_0f300f00_0d100b00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VLDR");
  rInsn.SetOpcode(ARM_Opcode_Vldr);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Dd
  /* unhandled field Dd */

  // field: [PC,#-0]
  auto pOprd0 = Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_RegPC, &m_CpuInfo), true);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// FSTMX - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 'P', 'U', 'D', 'W', 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_FSTMX_A2_0e100f00_0c000a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("FSTMX");
  rInsn.SetOpcode(ARM_Opcode_Fstmx);
  rInsn.Length() += 4;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSTM{mode}<c> <Rn>{!}, <list> - [] - ['c', 'c', 'c', 'c', 1, 1, 0, 'P', 'U', 'D', 'W', 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VSTM_A1_0e100f00_0c000b00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSTM");
  rInsn.SetOpcode(ARM_Opcode_Vstm);
  rInsn.Length() += 4;

  // field: mode
  /* unhandled field mode */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: W
  if (ExtractBit<21>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_W;

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: list
  /* unhandled field list */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STC{L}<c> <coproc>, <CRd>, [<Rn>],<option> - ['support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 'P', 'U', 'D', 'W', 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STC_A1_0e100000_0c000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STC");
  rInsn.SetOpcode(ARM_Opcode_Stc);
  rInsn.Length() += 4;

  // field: L
  /* unhandled field L */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: coproc
  /* unhandled field coproc */

  // field: CRd
  /* unhandled field CRd */

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: option
  /* unhandled field option */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDC{L}<c> <coproc>, <CRd>, [PC],<option> - ['support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 'P', 'U', 'D', 'W', 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDC_A1_0e1f0000_0c1f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDC");
  rInsn.SetOpcode(ARM_Opcode_Ldc);
  rInsn.Length() += 4;

  // field: L
  /* unhandled field L */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: coproc
  /* unhandled field coproc */

  // field: CRd
  /* unhandled field CRd */

  // field: [PC]
  /* unhandled field [PC] */

  // field: option
  /* unhandled field option */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// FLDMX - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 'P', 'U', 'D', 'W', 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_FLDMX_A2_0e100f00_0c100a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("FLDMX");
  rInsn.SetOpcode(ARM_Opcode_Fldmx);
  rInsn.Length() += 4;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VLDM{mode}<c> <Rn>{!}, <list> - [] - ['c', 'c', 'c', 'c', 1, 1, 0, 'P', 'U', 'D', 'W', 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VLDM_A1_0e100f00_0c100b00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VLDM");
  rInsn.SetOpcode(ARM_Opcode_Vldm);
  rInsn.Length() += 4;

  // field: mode
  /* unhandled field mode */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: W
  if (ExtractBit<21>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_W;

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: list
  /* unhandled field list */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDC{L}<c> <coproc>, <CRd>, [<Rn>],<option> - ['support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 0, 'P', 'U', 'D', 'W', 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDC_A1_0e100000_0c100000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDC");
  rInsn.SetOpcode(ARM_Opcode_Ldc);
  rInsn.Length() += 4;

  // field: L
  /* unhandled field L */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: coproc
  /* unhandled field coproc */

  // field: CRd
  /* unhandled field CRd */

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: option
  /* unhandled field option */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMOV<c> <Rt>, <Sn> - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 0, 0, 0, 'op', 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 0, 1, 0, 'N', '(0)', '(0)', 1, '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VMOV_A1_0fe00f7f_0e000a10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMOV");
  rInsn.SetOpcode(ARM_Opcode_Vmov);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Sn
  /* unhandled field Sn */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op><c>.F32 <Sd>, <Sn>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 0, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 'op', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_A2_0fb00e10_0e000a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Sd
  /* unhandled field Sd */

  // field: Sn
  /* unhandled field Sn */

  // field: Sm
  /* unhandled field Sm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VNMLS<c>.F32 <Sd>, <Sn>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 0, 'D', 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 'op', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VNMLS_A1_0fb00e10_0e100a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VNMLS");
  rInsn.SetOpcode(ARM_Opcode_Vnmls);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Sd
  /* unhandled field Sd */

  // field: Sn
  /* unhandled field Sn */

  // field: Sm
  /* unhandled field Sm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMUL<c>.F32 <Sd>, <Sn>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 0, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMUL_A2_0fb00e50_0e200a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMUL");
  rInsn.SetOpcode(ARM_Opcode_Vmul);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Sd
  /* unhandled field Sd */

  // field: Sn
  /* unhandled field Sn */

  // field: Sm
  /* unhandled field Sm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VNMUL<c>.F32 <Sd>, <Sn>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 0, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VNMUL_A2_0fb00e50_0e200a40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VNMUL");
  rInsn.SetOpcode(ARM_Opcode_Vnmul);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Sd
  /* unhandled field Sd */

  // field: Sn
  /* unhandled field Sn */

  // field: Sm
  /* unhandled field Sm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VADD<c>.F32 <Sd>, <Sn>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 0, 'D', 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VADD_A2_0fb00e50_0e300a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VADD");
  rInsn.SetOpcode(ARM_Opcode_Vadd);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Sd
  /* unhandled field Sd */

  // field: Sn
  /* unhandled field Sn */

  // field: Sm
  /* unhandled field Sm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSUB<c>.F32 <Sd>, <Sn>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 0, 'D', 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSUB_A2_0fb00e50_0e300a40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSUB");
  rInsn.SetOpcode(ARM_Opcode_Vsub);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Sd
  /* unhandled field Sd */

  // field: Sn
  /* unhandled field Sn */

  // field: Sm
  /* unhandled field Sm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMOV<c>.<size> <Dd[x]>, <Rt> - [] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 0, 'opc1', 'opc1', 0, 'd', 'd', 'd', 'd', 't', 't', 't', 't', 1, 0, 1, 1, 'D', 'opc2', 'opc2', 1, '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VMOV_A1_0f900f1f_0e000b10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMOV");
  rInsn.SetOpcode(ARM_Opcode_Vmov);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: size
  /* unhandled field size */

  // field: Dd[x]
  /* unhandled field Dd[x] */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMSR<c> FPSCR, <Rt> - [] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 't', 't', 't', 't', 1, 0, 1, 0, 0, '(0)', '(0)', 1, '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VMSR_A1_0fff0fff_0ee10a10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMSR");
  rInsn.SetOpcode(ARM_Opcode_Vmsr);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: FPSCR
  /* unhandled field FPSCR */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMRS<c> <Rt>, FPSCR - [] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 't', 't', 't', 't', 1, 0, 1, 0, 0, '(0)', '(0)', 1, '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VMRS_A1_0fff0fff_0ef10a10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMRS");
  rInsn.SetOpcode(ARM_Opcode_Vmrs);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: FPSCR
  /* unhandled field FPSCR */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VDUP<c>.<size> - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'B', 'Q', 0, 'd', 'd', 'd', 'd', 't', 't', 't', 't', 1, 0, 1, 1, 'D', 0, 'E', 1, '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VDUP_A1_0f900f5f_0e800b10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VDUP");
  rInsn.SetOpcode(ARM_Opcode_Vdup);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: size
  /* unhandled field size */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VDIV<c>.F32 <Sd>, <Sn>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VDIV_A1_0fb00e50_0e800a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VDIV");
  rInsn.SetOpcode(ARM_Opcode_Vdiv);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Sd
  /* unhandled field Sd */

  // field: Sn
  /* unhandled field Sn */

  // field: Sm
  /* unhandled field Sm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMOV<c>.F32 <Sd>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 0, 0, 0, 0, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 0, 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMOV_A2_0fbf0ed0_0eb00a40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMOV");
  rInsn.SetOpcode(ARM_Opcode_Vmov);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Sd
  /* unhandled field Sd */

  // field: Sm
  /* unhandled field Sm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VABS<c>.F32 <Sd>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 0, 0, 0, 0, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 1, 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VABS_A2_0fbf0ed0_0eb00ac0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VABS");
  rInsn.SetOpcode(ARM_Opcode_Vabs);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Sd
  /* unhandled field Sd */

  // field: Sm
  /* unhandled field Sm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VNEG<c>.F32 <Sd>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 0, 0, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 0, 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VNEG_A2_0fbf0ed0_0eb10a40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VNEG");
  rInsn.SetOpcode(ARM_Opcode_Vneg);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Sd
  /* unhandled field Sd */

  // field: Sm
  /* unhandled field Sm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSQRT<c>.F32 <Sd>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 0, 0, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 1, 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSQRT_A1_0fbf0ed0_0eb10ac0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSQRT");
  rInsn.SetOpcode(ARM_Opcode_Vsqrt);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Sd
  /* unhandled field Sd */

  // field: Sm
  /* unhandled field Sm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCVT<y><c>.F16.F32 <Sd>, <Sm> - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 0, 0, 1, 'op', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'T', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCVT_A1_0fbe0f50_0eb20a40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCVT");
  rInsn.SetOpcode(ARM_Opcode_Vcvt);
  rInsn.Length() += 4;

  // field: y
  /* unhandled field y */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Sd
  /* unhandled field Sd */

  // field: Sm
  /* unhandled field Sm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCMP{E}<c>.F32 <Sd>, <Sm> - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 0, 1, 0, 0, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'E', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCMP_A1_0fbf0e50_0eb40a40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCMP");
  rInsn.SetOpcode(ARM_Opcode_Vcmp);
  rInsn.Length() += 4;

  // field: E
  /* unhandled field E */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Sd
  /* unhandled field Sd */

  // field: Sm
  /* unhandled field Sm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCMP{E}<c>.F32 <Sd>, #0.0 - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 0, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'E', 1, '(0)', 0, '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VCMP_A2_0fbf0e7f_0eb50a40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCMP");
  rInsn.SetOpcode(ARM_Opcode_Vcmp);
  rInsn.Length() += 4;

  // field: E
  /* unhandled field E */

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Sd
  /* unhandled field Sd */

  // field: #0.0
  /* unhandled field #0.0 */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCVT<c>.F32.F64 <Sd>, <Dm> - ['support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 0, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 1, 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCVT_A1_0fbf0ed0_0eb70ac0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCVT");
  rInsn.SetOpcode(ARM_Opcode_Vcvt);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Sd
  /* unhandled field Sd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCVT<c>.F32.<Td> <Sd>, <Sd>, #<fbits> - ['support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 1, 'op', 1, 'U', 'd', 'd', 'd', 'd', 1, 0, 1, 'sf', 'sx', 1, 'i', 0, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VCVT_A1_0fba0e50_0eba0a40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCVT");
  rInsn.SetOpcode(ARM_Opcode_Vcvt);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Td
  /* unhandled field Td */

  // field: Sd
  /* unhandled field Sd */

  // field: Sd
  /* unhandled field Sd */

  // field: fbits
  /* unhandled field fbits */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCVT<c>.F32.<Tm> <Sd>, <Sm> - ['support_it_block', 'support_it_block', 'support_it_block', 'support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 1, 'opc2', 'opc2', 'opc2', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'op', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCVT_A1_0fb80e50_0eb80a40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCVT");
  rInsn.SetOpcode(ARM_Opcode_Vcvt);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Tm
  /* unhandled field Tm */

  // field: Sd
  /* unhandled field Sd */

  // field: Sm
  /* unhandled field Sm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMOV<c>.F32 <Sd>, #<imm> - ['support_it_block', 'support_it_block'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 1, 'D', 1, 1, 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', '(0)', 0, '(0)', 0, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VMOV_A2_0fb00ef0_0eb00a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMOV");
  rInsn.SetOpcode(ARM_Opcode_Vmov);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: Sd
  /* unhandled field Sd */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 4>(ExtractBits<0, 3>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMOV<c>.<dt> <Rt>, <Dn[x]> - [] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 'U', 'opc1', 'opc1', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 0, 1, 1, 'N', 'opc2', 'opc2', 1, '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VMOV_A1_0f100f1f_0e100b10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMOV");
  rInsn.SetOpcode(ARM_Opcode_Vmov);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: dt
  /* unhandled field dt */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Dn[x]
  /* unhandled field Dn[x] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MCR<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - [] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MCR_A1_0f100010_0e000010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MCR");
  rInsn.SetOpcode(ARM_Opcode_Mcr);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: coproc
  /* unhandled field coproc */

  // field: opc1
  /* unhandled field opc1 */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: CRn
  /* unhandled field CRn */

  // field: <CRm>{,<opc2>}
  /* unhandled field <CRm>{,<opc2>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MRC<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['could_jmp'] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MRC_A1_0f100010_0e100010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MRC");
  rInsn.SetOpcode(ARM_Opcode_Mrc);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: coproc
  /* unhandled field coproc */

  // field: opc1
  /* unhandled field opc1 */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: CRn
  /* unhandled field CRn */

  // field: <CRm>{,<opc2>}
  /* unhandled field <CRm>{,<opc2>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CDP<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2> - [] - ['c', 'c', 'c', 'c', 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 'opc1', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_CDP_A1_0f000010_0e000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CDP");
  rInsn.SetOpcode(ARM_Opcode_Cdp);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: coproc
  /* unhandled field coproc */

  // field: opc1
  /* unhandled field opc1 */

  // field: CRd
  /* unhandled field CRd */

  // field: CRn
  /* unhandled field CRn */

  // field: CRm
  /* unhandled field CRm */

  // field: opc2
  /* unhandled field opc2 */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SVC<c> #<imm> - ['syscall'] - ['c', 'c', 'c', 'c', 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_SVC_A1_0f000000_0f000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SVC");
  rInsn.SetOpcode(ARM_Opcode_Svc);
  rInsn.Length() += 4;

  // field: c
  u8 CondField = ExtractBits<28, 31>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 24>(ExtractBits<0, 23>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MOVS <Rd>, <Rm> - ['could_jmp'] - [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'm', 'm', 'm', 'd', 'd', 'd']
bool ArmArchitecture::Instruction_MOVS_T2_0000ffc0_00000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MOVS");
  rInsn.SetOpcode(ARM_Opcode_Movs);
  rInsn.Length() += 2;

  // field: Rd
  u32 RegD = ExtractBits<0, 2>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LSLS <Rd>, <Rm>, #<imm5> - ['could_jmp'] - [0, 0, 0, 0, 0, 'i', 'i', 'i', 'i', 'i', 'm', 'm', 'm', 'd', 'd', 'd']
bool ArmArchitecture::Instruction_LSLS_T1_0000f800_00000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LSLS");
  rInsn.SetOpcode(ARM_Opcode_Lsls);
  rInsn.Length() += 2;

  // field: Rd
  u32 RegD = ExtractBits<0, 2>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm5
  /* unhandled field imm5 */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LSRS <Rd>, <Rm>, #<imm> - ['could_jmp'] - [0, 0, 0, 0, 1, 'i', 'i', 'i', 'i', 'i', 'm', 'm', 'm', 'd', 'd', 'd']
bool ArmArchitecture::Instruction_LSRS_T1_0000f800_00000800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LSRS");
  rInsn.SetOpcode(ARM_Opcode_Lsrs);
  rInsn.Length() += 2;

  // field: Rd
  u32 RegD = ExtractBits<0, 2>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 11>(ExtractBits<6, 10>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ASRS <Rd>, <Rm>, #<imm> - ['could_jmp'] - [0, 0, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'm', 'm', 'm', 'd', 'd', 'd']
bool ArmArchitecture::Instruction_ASRS_T1_0000f800_00001000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ASRS");
  rInsn.SetOpcode(ARM_Opcode_Asrs);
  rInsn.Length() += 2;

  // field: Rd
  u32 RegD = ExtractBits<0, 2>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 11>(ExtractBits<6, 10>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADDS <Rd>, <Rn>, <Rm> - ['could_jmp'] - [0, 0, 0, 1, 1, 0, 0, 'm', 'm', 'm', 'n', 'n', 'n', 'd', 'd', 'd']
bool ArmArchitecture::Instruction_ADDS_T1_0000fe00_00001800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADDS");
  rInsn.SetOpcode(ARM_Opcode_Adds);
  rInsn.Length() += 2;

  // field: Rd
  u32 RegD = ExtractBits<0, 2>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<6, 8>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SUBS <Rd>, <Rn>, <Rm> - ['could_jmp'] - [0, 0, 0, 1, 1, 0, 1, 'm', 'm', 'm', 'n', 'n', 'n', 'd', 'd', 'd']
bool ArmArchitecture::Instruction_SUBS_T1_0000fe00_00001a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SUBS");
  rInsn.SetOpcode(ARM_Opcode_Subs);
  rInsn.Length() += 2;

  // field: Rd
  u32 RegD = ExtractBits<0, 2>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<6, 8>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADDS <Rd>, <Rn>, #<imm> - [] - [0, 0, 0, 1, 1, 1, 0, 'i', 'i', 'i', 'n', 'n', 'n', 'd', 'd', 'd']
bool ArmArchitecture::Instruction_ADDS_T1_0000fe00_00001c00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADDS");
  rInsn.SetOpcode(ARM_Opcode_Adds);
  rInsn.Length() += 2;

  // field: Rd
  u32 RegD = ExtractBits<0, 2>(Opcode);
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 9>(ExtractBits<6, 8>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SUBS <Rd>, <Rn>, #<imm> - ['could_jmp'] - [0, 0, 0, 1, 1, 1, 1, 'i', 'i', 'i', 'n', 'n', 'n', 'd', 'd', 'd']
bool ArmArchitecture::Instruction_SUBS_T1_0000fe00_00001e00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SUBS");
  rInsn.SetOpcode(ARM_Opcode_Subs);
  rInsn.Length() += 2;

  // field: Rd
  u32 RegD = ExtractBits<0, 2>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 9>(ExtractBits<6, 8>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MOVS <Rd>, #<imm> - ['could_jmp'] - [0, 0, 1, 0, 0, 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_MOVS_T1_0000f800_00002000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MOVS");
  rInsn.SetOpcode(ARM_Opcode_Movs);
  rInsn.Length() += 2;

  // field: Rd
  u32 RegD = ExtractBits<8, 10>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: imm
  auto pOprd1 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CMP<c> <Rn>, #<imm> - ['cond'] - [0, 0, 1, 0, 1, 'n', 'n', 'n', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_CMP_T1_0000f800_00002800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CMP");
  rInsn.SetOpcode(ARM_Opcode_Cmp);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rn
  u32 RegN = ExtractBits<8, 10>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: imm
  auto pOprd1 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADDS <Rdn>, #<imm> - ['could_jmp'] - [0, 0, 1, 1, 0, 'dn', 'dn', 'dn', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_ADDS_T2_0000f800_00003000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADDS");
  rInsn.SetOpcode(ARM_Opcode_Adds);
  rInsn.Length() += 2;

  // field: Rdn
  u32 RegDn = ExtractBits<8, 10>(Opcode);
  if (RegDn + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegDn + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: imm
  auto pOprd1 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SUBS <Rdn>, #<imm> - ['could_jmp'] - [0, 0, 1, 1, 1, 'dn', 'dn', 'dn', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_SUBS_T2_0000f800_00003800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SUBS");
  rInsn.SetOpcode(ARM_Opcode_Subs);
  rInsn.Length() += 2;

  // field: Rdn
  u32 RegDn = ExtractBits<8, 10>(Opcode);
  if (RegDn + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegDn + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: imm
  auto pOprd1 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ANDS <Rdn>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 'm', 'm', 'm', 'dn', 'dn', 'dn']
bool ArmArchitecture::Instruction_ANDS_T1_0000ffc0_00004000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ANDS");
  rInsn.SetOpcode(ARM_Opcode_Ands);
  rInsn.Length() += 2;

  // field: Rdn
  u32 RegDn = ExtractBits<0, 2>(Opcode);
  if (RegDn + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegDn + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// EORS <Rdn>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 'm', 'm', 'm', 'dn', 'dn', 'dn']
bool ArmArchitecture::Instruction_EORS_T1_0000ffc0_00004040(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("EORS");
  rInsn.SetOpcode(ARM_Opcode_Eors);
  rInsn.Length() += 2;

  // field: Rdn
  u32 RegDn = ExtractBits<0, 2>(Opcode);
  if (RegDn + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegDn + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LSLS <Rdn>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 'm', 'm', 'm', 'dn', 'dn', 'dn']
bool ArmArchitecture::Instruction_LSLS_T1_0000ffc0_00004080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LSLS");
  rInsn.SetOpcode(ARM_Opcode_Lsls);
  rInsn.Length() += 2;

  // field: Rdn
  u32 RegDn = ExtractBits<0, 2>(Opcode);
  if (RegDn + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegDn + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LSRS <Rdn>, <Rm> - ['support_it_block', 'could_jmp'] - [0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 'm', 'm', 'm', 'dn', 'dn', 'dn']
bool ArmArchitecture::Instruction_LSRS_T1_0000ffc0_000040c0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LSRS");
  rInsn.SetOpcode(ARM_Opcode_Lsrs);
  rInsn.Length() += 2;

  // field: Rdn
  u32 RegDn = ExtractBits<0, 2>(Opcode);
  if (RegDn + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegDn + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ASRS <Rdn>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 'm', 'm', 'm', 'dn', 'dn', 'dn']
bool ArmArchitecture::Instruction_ASRS_T1_0000ffc0_00004100(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ASRS");
  rInsn.SetOpcode(ARM_Opcode_Asrs);
  rInsn.Length() += 2;

  // field: Rdn
  u32 RegDn = ExtractBits<0, 2>(Opcode);
  if (RegDn + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegDn + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADCS <Rdn>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 'm', 'm', 'm', 'dn', 'dn', 'dn']
bool ArmArchitecture::Instruction_ADCS_T1_0000ffc0_00004140(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADCS");
  rInsn.SetOpcode(ARM_Opcode_Adcs);
  rInsn.Length() += 2;

  // field: Rdn
  u32 RegDn = ExtractBits<0, 2>(Opcode);
  if (RegDn + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegDn + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SBCS <Rdn>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 'm', 'm', 'm', 'dn', 'dn', 'dn']
bool ArmArchitecture::Instruction_SBCS_T1_0000ffc0_00004180(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SBCS");
  rInsn.SetOpcode(ARM_Opcode_Sbcs);
  rInsn.Length() += 2;

  // field: Rdn
  u32 RegDn = ExtractBits<0, 2>(Opcode);
  if (RegDn + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegDn + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// RORS <Rdn>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 'm', 'm', 'm', 'dn', 'dn', 'dn']
bool ArmArchitecture::Instruction_RORS_T1_0000ffc0_000041c0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("RORS");
  rInsn.SetOpcode(ARM_Opcode_Rors);
  rInsn.Length() += 2;

  // field: Rdn
  u32 RegDn = ExtractBits<0, 2>(Opcode);
  if (RegDn + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegDn + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// TST<c> <Rn>, <Rm> - [] - [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 'm', 'm', 'm', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_TST_T1_0000ffc0_00004200(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("TST");
  rInsn.SetOpcode(ARM_Opcode_Tst);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rn
  u32 RegN = ExtractBits<0, 2>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// RSBS <Rd>, <Rn>, #0 - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 'n', 'n', 'n', 'd', 'd', 'd']
bool ArmArchitecture::Instruction_RSBS_T1_0000ffc0_00004240(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("RSBS");
  rInsn.SetOpcode(ARM_Opcode_Rsbs);
  rInsn.Length() += 2;

  // field: Rd
  u32 RegD = ExtractBits<0, 2>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: #0
  auto pOprd2 = Expr::MakeConst(32, 0);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CMP<c> <Rn>, <Rm> - ['cond'] - [0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 'm', 'm', 'm', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_CMP_T1_0000ffc0_00004280(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CMP");
  rInsn.SetOpcode(ARM_Opcode_Cmp);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rn
  u32 RegN = ExtractBits<0, 2>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CMN<c> <Rn>, <Rm> - ['cond'] - [0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 'm', 'm', 'm', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_CMN_T1_0000ffc0_000042c0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CMN");
  rInsn.SetOpcode(ARM_Opcode_Cmn);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rn
  u32 RegN = ExtractBits<0, 2>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ORRS <Rdn>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 'm', 'm', 'm', 'dn', 'dn', 'dn']
bool ArmArchitecture::Instruction_ORRS_T1_0000ffc0_00004300(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ORRS");
  rInsn.SetOpcode(ARM_Opcode_Orrs);
  rInsn.Length() += 2;

  // field: Rdn
  u32 RegDn = ExtractBits<0, 2>(Opcode);
  if (RegDn + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegDn + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MULS <Rdm>, <Rn> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'dm', 'dm', 'dm']
bool ArmArchitecture::Instruction_MULS_T1_0000ffc0_00004340(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MULS");
  rInsn.SetOpcode(ARM_Opcode_Muls);
  rInsn.Length() += 2;

  // field: Rdm
  u32 RegDm = ExtractBits<0, 2>(Opcode);
  if (RegDm + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegDm + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BICS <Rdn>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 'm', 'm', 'm', 'dn', 'dn', 'dn']
bool ArmArchitecture::Instruction_BICS_T1_0000ffc0_00004380(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BICS");
  rInsn.SetOpcode(ARM_Opcode_Bics);
  rInsn.Length() += 2;

  // field: Rdn
  u32 RegDn = ExtractBits<0, 2>(Opcode);
  if (RegDn + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegDn + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MVNS <Rd>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 'm', 'm', 'm', 'd', 'd', 'd']
bool ArmArchitecture::Instruction_MVNS_T1_0000ffc0_000043c0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MVNS");
  rInsn.SetOpcode(ARM_Opcode_Mvns);
  rInsn.Length() += 2;

  // field: Rd
  u32 RegD = ExtractBits<0, 2>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADD<c> SP,<Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 1, 0, 0, 1, 'm', 'm', 'm', 'm', 1, 0, 1]
bool ArmArchitecture::Instruction_ADD_T2_0000ff87_00004485(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADD");
  rInsn.SetOpcode(ARM_Opcode_Add);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: SP,<Rm>
  /* unhandled field SP,<Rm> */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADD<c> <Rdm>, SP - ['could_jmp'] - [0, 1, 0, 0, 0, 1, 0, 0, 'DM', 1, 1, 0, 1, 'dm', 'dm', 'dm']
bool ArmArchitecture::Instruction_ADD_T1_0000ff78_00004468(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADD");
  rInsn.SetOpcode(ARM_Opcode_Add);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rdm
  u32 RegDm = ExtractBits<0, 2>(Opcode);
  if (RegDm + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegDm + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: SP
  auto pOprd1 = Expr::MakeId(ARM_RegSP, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADD<c> <Rdn>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 1, 0, 0, 'DN', 'm', 'm', 'm', 'm', 'dn', 'dn', 'dn']
bool ArmArchitecture::Instruction_ADD_T2_0000ff00_00004400(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADD");
  rInsn.SetOpcode(ARM_Opcode_Add);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rdn
  u32 RegDn = ExtractBits<0, 2>(Opcode);
  if (RegDn + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegDn + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 6>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CMP<c> <Rn>, <Rm> - ['cond'] - [0, 1, 0, 0, 0, 1, 0, 1, 'N', 'm', 'm', 'm', 'm', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_CMP_T2_0000ff00_00004500(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CMP");
  rInsn.SetOpcode(ARM_Opcode_Cmp);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rn
  u32 RegN = ExtractBits<0, 2>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 6>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MOV<c> <Rd>, <Rm> - ['could_jmp'] - [0, 1, 0, 0, 0, 1, 1, 0, 'D', 'm', 'm', 'm', 'm', 'd', 'd', 'd']
bool ArmArchitecture::Instruction_MOV_T1_0000ff00_00004600(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MOV");
  rInsn.SetOpcode(ARM_Opcode_Mov);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<0, 2>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 6>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BX<c> <Rm> - ['call'] - [0, 1, 0, 0, 0, 1, 1, 1, 0, 'm', 'm', 'm', 'm', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_BX_T1_0000ff87_00004700(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BX");
  rInsn.SetOpcode(ARM_Opcode_Bx);
  rInsn.Length() += 2;
  rInsn.SubType() |= Instruction::CallType;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rm
  u32 RegM = ExtractBits<3, 6>(Opcode);
  auto pOprd0 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BLX<c> <Rm> - ['call'] - [0, 1, 0, 0, 0, 1, 1, 1, 1, 'm', 'm', 'm', 'm', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_BLX_T1_0000ff87_00004780(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BLX");
  rInsn.SetOpcode(ARM_Opcode_Blx);
  rInsn.Length() += 2;
  rInsn.SubType() |= Instruction::CallType;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rm
  u32 RegM = ExtractBits<3, 6>(Opcode);
  auto pOprd0 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDR<c> <Rt>, <label> - ['could_jmp'] - [0, 1, 0, 0, 1, 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDR_T1_0000f800_00004800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDR");
  rInsn.SetOpcode(ARM_Opcode_Ldr);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<8, 10>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: label
  auto pOprd1 = Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(ARM_RegPC, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode))));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STR<c> <Rt>, [<Rn>, <Rm>] - [] - [0, 1, 0, 1, 0, 0, 0, 'm', 'm', 'm', 'n', 'n', 'n', 't', 't', 't']
bool ArmArchitecture::Instruction_STR_T1_0000fe00_00005000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STR");
  rInsn.SetOpcode(ARM_Opcode_Str);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<0, 2>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, <Rm>]
  /* unhandled field [<Rn>, <Rm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRH<c> <Rt>, [<Rn>, <Rm>] - [] - [0, 1, 0, 1, 0, 0, 1, 'm', 'm', 'm', 'n', 'n', 'n', 't', 't', 't']
bool ArmArchitecture::Instruction_STRH_T1_0000fe00_00005200(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRH");
  rInsn.SetOpcode(ARM_Opcode_Strh);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<0, 2>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, <Rm>]
  /* unhandled field [<Rn>, <Rm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRB<c> <Rt>, [<Rn>, <Rm>] - [] - [0, 1, 0, 1, 0, 1, 0, 'm', 'm', 'm', 'n', 'n', 'n', 't', 't', 't']
bool ArmArchitecture::Instruction_STRB_T1_0000fe00_00005400(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRB");
  rInsn.SetOpcode(ARM_Opcode_Strb);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<0, 2>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, <Rm>]
  /* unhandled field [<Rn>, <Rm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSB<c> <Rt>, [<Rn>, <Rm>] - ['could_jmp'] - [0, 1, 0, 1, 0, 1, 1, 'm', 'm', 'm', 'n', 'n', 'n', 't', 't', 't']
bool ArmArchitecture::Instruction_LDRSB_T1_0000fe00_00005600(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSB");
  rInsn.SetOpcode(ARM_Opcode_Ldrsb);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<0, 2>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, <Rm>]
  /* unhandled field [<Rn>, <Rm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDR<c> <Rt>, [<Rn>, <Rm>] - ['could_jmp'] - [0, 1, 0, 1, 1, 0, 0, 'm', 'm', 'm', 'n', 'n', 'n', 't', 't', 't']
bool ArmArchitecture::Instruction_LDR_T1_0000fe00_00005800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDR");
  rInsn.SetOpcode(ARM_Opcode_Ldr);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<0, 2>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, <Rm>]
  /* unhandled field [<Rn>, <Rm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRH<c> <Rt>, [<Rn>, <Rm>] - ['could_jmp'] - [0, 1, 0, 1, 1, 0, 1, 'm', 'm', 'm', 'n', 'n', 'n', 't', 't', 't']
bool ArmArchitecture::Instruction_LDRH_T1_0000fe00_00005a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRH");
  rInsn.SetOpcode(ARM_Opcode_Ldrh);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<0, 2>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, <Rm>]
  /* unhandled field [<Rn>, <Rm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRB<c> <Rt>, [<Rn>, <Rm>] - ['could_jmp'] - [0, 1, 0, 1, 1, 1, 0, 'm', 'm', 'm', 'n', 'n', 'n', 't', 't', 't']
bool ArmArchitecture::Instruction_LDRB_T1_0000fe00_00005c00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRB");
  rInsn.SetOpcode(ARM_Opcode_Ldrb);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<0, 2>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, <Rm>]
  /* unhandled field [<Rn>, <Rm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSH<c> <Rt>, [<Rn>, <Rm>] - ['could_jmp'] - [0, 1, 0, 1, 1, 1, 1, 'm', 'm', 'm', 'n', 'n', 'n', 't', 't', 't']
bool ArmArchitecture::Instruction_LDRSH_T1_0000fe00_00005e00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSH");
  rInsn.SetOpcode(ARM_Opcode_Ldrsh);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<0, 2>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, <Rm>]
  /* unhandled field [<Rn>, <Rm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STR<c> <Rt>, [<Rn>{,#<imm>}] - [] - [0, 1, 1, 0, 0, 'i', 'i', 'i', 'i', 'i', 'n', 'n', 'n', 't', 't', 't']
bool ArmArchitecture::Instruction_STR_T1_0000f800_00006000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STR");
  rInsn.SetOpcode(ARM_Opcode_Str);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<0, 2>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>{,#<imm>}]
  /* unhandled field [<Rn>{,#<imm>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDR<c> <Rt>, [<Rn>{,#<imm>}] - ['could_jmp'] - [0, 1, 1, 0, 1, 'i', 'i', 'i', 'i', 'i', 'n', 'n', 'n', 't', 't', 't']
bool ArmArchitecture::Instruction_LDR_T1_0000f800_00006800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDR");
  rInsn.SetOpcode(ARM_Opcode_Ldr);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<0, 2>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>{,#<imm>}]
  /* unhandled field [<Rn>{,#<imm>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRB<c> <Rt>, [<Rn>, #<imm5>] - [] - [0, 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'i', 'n', 'n', 'n', 't', 't', 't']
bool ArmArchitecture::Instruction_STRB_T1_0000f800_00007000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRB");
  rInsn.SetOpcode(ARM_Opcode_Strb);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<0, 2>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm5>]
  /* unhandled field [<Rn>, #<imm5>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRB<c> <Rt>, [<Rn>{,#<imm5>}] - ['could_jmp'] - [0, 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'n', 'n', 'n', 't', 't', 't']
bool ArmArchitecture::Instruction_LDRB_T1_0000f800_00007800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRB");
  rInsn.SetOpcode(ARM_Opcode_Ldrb);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<0, 2>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>{,#<imm5>}]
  /* unhandled field [<Rn>{,#<imm5>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRH<c> <Rt>, [<Rn>{,#<imm>}] - [] - [1, 0, 0, 0, 0, 'i', 'i', 'i', 'i', 'i', 'n', 'n', 'n', 't', 't', 't']
bool ArmArchitecture::Instruction_STRH_T1_0000f800_00008000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRH");
  rInsn.SetOpcode(ARM_Opcode_Strh);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<0, 2>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>{,#<imm>}]
  /* unhandled field [<Rn>{,#<imm>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRH<c> <Rt>, [<Rn>{,#<imm>}] - ['could_jmp'] - [1, 0, 0, 0, 1, 'i', 'i', 'i', 'i', 'i', 'n', 'n', 'n', 't', 't', 't']
bool ArmArchitecture::Instruction_LDRH_T1_0000f800_00008800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRH");
  rInsn.SetOpcode(ARM_Opcode_Ldrh);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<0, 2>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>{,#<imm>}]
  /* unhandled field [<Rn>{,#<imm>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STR<c> <Rt>, [SP, #<imm>] - [] - [1, 0, 0, 1, 0, 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STR_T2_0000f800_00009000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STR");
  rInsn.SetOpcode(ARM_Opcode_Str);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<8, 10>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [SP, #<imm>]
  /* unhandled field [SP, #<imm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDR<c> <Rt>, [SP{,#<imm>}] - ['could_jmp'] - [1, 0, 0, 1, 1, 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDR_T2_0000f800_00009800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDR");
  rInsn.SetOpcode(ARM_Opcode_Ldr);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<8, 10>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [SP{,#<imm>}]
  /* unhandled field [SP{,#<imm>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADR<c> <Rd>, <label> - ['could_jmp'] - [1, 0, 1, 0, 0, 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_ADR_T1_0000f800_0000a000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADR");
  rInsn.SetOpcode(ARM_Opcode_Adr);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 10>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: label
  auto pOprd1 = Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(ARM_RegPC, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode))));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADD<c> <Rd>, SP, #<imm> - ['could_jmp'] - [1, 0, 1, 0, 1, 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_ADD_T1_0000f800_0000a800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADD");
  rInsn.SetOpcode(ARM_Opcode_Add);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 10>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: SP
  auto pOprd1 = Expr::MakeId(ARM_RegSP, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADD<c> SP, SP, #<imm> - ['could_jmp'] - [1, 0, 1, 1, 0, 0, 0, 0, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_ADD_T2_0000ff80_0000b000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADD");
  rInsn.SetOpcode(ARM_Opcode_Add);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: SP
  auto pOprd0 = Expr::MakeId(ARM_RegSP, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: SP
  auto pOprd1 = Expr::MakeId(ARM_RegSP, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 7>(ExtractBits<0, 6>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SUB<c> SP, SP, #<imm> - ['could_jmp'] - [1, 0, 1, 1, 0, 0, 0, 0, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_SUB_T1_0000ff80_0000b080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SUB");
  rInsn.SetOpcode(ARM_Opcode_Sub);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: SP
  auto pOprd0 = Expr::MakeId(ARM_RegSP, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: SP
  auto pOprd1 = Expr::MakeId(ARM_RegSP, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 7>(ExtractBits<0, 6>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SXTH<c> <Rd>, <Rm> - ['could_jmp'] - [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 'm', 'm', 'm', 'd', 'd', 'd']
bool ArmArchitecture::Instruction_SXTH_T1_0000ffc0_0000b200(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SXTH");
  rInsn.SetOpcode(ARM_Opcode_Sxth);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<0, 2>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SXTB<c> <Rd>, <Rm> - ['could_jmp'] - [1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 'm', 'm', 'm', 'd', 'd', 'd']
bool ArmArchitecture::Instruction_SXTB_T1_0000ffc0_0000b240(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SXTB");
  rInsn.SetOpcode(ARM_Opcode_Sxtb);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<0, 2>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UXTH<c> <Rd>, <Rm> - ['could_jmp'] - [1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 'm', 'm', 'm', 'd', 'd', 'd']
bool ArmArchitecture::Instruction_UXTH_T1_0000ffc0_0000b280(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UXTH");
  rInsn.SetOpcode(ARM_Opcode_Uxth);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<0, 2>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UXTB<c> <Rd>, <Rm> - ['could_jmp'] - [1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 'm', 'm', 'm', 'd', 'd', 'd']
bool ArmArchitecture::Instruction_UXTB_T1_0000ffc0_0000b2c0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UXTB");
  rInsn.SetOpcode(ARM_Opcode_Uxtb);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<0, 2>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// PUSH<c> <registers> - ['could_jmp'] - [1, 0, 1, 1, 0, 1, 0, 'M', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
bool ArmArchitecture::Instruction_PUSH_T1_0000fe00_0000b400(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("PUSH");
  rInsn.SetOpcode(ARM_Opcode_Push);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: registers
  u32 RegList = ExtractBits<0, 7>(Opcode);
  Expression::List IdExprs;
  for (u8 RegIdx = 0; RegIdx < 16; ++RegIdx)
  {
    if (RegList & (1 << RegIdx))
      IdExprs.push_back(Expr::MakeId(RegIdx + 1, &m_CpuInfo));
    if (RegIdx + 1 == ARM_RegPC)
      rInsn.SubType() |= Instruction::JumpType;
  }
  auto pOprd0 = Expr::MakeBind(IdExprs);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: stack.id -= op0.size */
    Expr::MakeAssign(
      Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo),
      Expr::MakeOp(
        OperationExpression::OpSub,
        Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo),
        Expr::MakeConst(
          32,
          (rInsn.GetOperand(0)->GetSizeInBit() / 8))));
    AllExpr.push_back(pExpr0);
    auto pExpr1 = /* Semantic: stack.mem = op0.val */
    Expr::MakeAssign(
      Expr::MakeMem(m_CpuInfo.GetSizeOfRegisterInBit(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode())), nullptr, Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo)),
      rInsn.GetOperand(0));
    AllExpr.push_back(pExpr1);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SETEND <endian_specifier> - [] - [1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, '(1)', 'E', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_SETEND_T1_0000fff7_0000b650(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SETEND");
  rInsn.SetOpcode(ARM_Opcode_Setend);
  rInsn.Length() += 2;

  // field: endian_specifier
  /* unhandled field endian_specifier */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// REV<c> <Rd>, <Rm> - ['could_jmp'] - [1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 'm', 'm', 'm', 'd', 'd', 'd']
bool ArmArchitecture::Instruction_REV_T1_0000ffc0_0000ba00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("REV");
  rInsn.SetOpcode(ARM_Opcode_Rev);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<0, 2>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// REV16<c> <Rd>, <Rm> - ['could_jmp'] - [1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 'm', 'm', 'm', 'd', 'd', 'd']
bool ArmArchitecture::Instruction_REV16_T1_0000ffc0_0000ba40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("REV16");
  rInsn.SetOpcode(ARM_Opcode_Rev16);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<0, 2>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// REVSH<c> <Rd>, <Rm> - ['could_jmp'] - [1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 'm', 'm', 'm', 'd', 'd', 'd']
bool ArmArchitecture::Instruction_REVSH_T1_0000ffc0_0000bac0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("REVSH");
  rInsn.SetOpcode(ARM_Opcode_Revsh);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<0, 2>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<3, 5>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// POP<c> <registers> - ['could_ret'] - [1, 0, 1, 1, 1, 1, 0, 'P', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
bool ArmArchitecture::Instruction_POP_T1_0000fe00_0000bc00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("POP");
  rInsn.SetOpcode(ARM_Opcode_Pop);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: registers
  u32 RegList = ExtractBits<0, 7>(Opcode);
  Expression::List IdExprs;
  for (u8 RegIdx = 0; RegIdx < 16; ++RegIdx)
  {
    if (RegList & (1 << RegIdx))
      IdExprs.push_back(Expr::MakeId(RegIdx + 1, &m_CpuInfo));
    if (RegIdx + 1 == ARM_RegPC)
      rInsn.SubType() |= Instruction::ReturnType;
  }
  auto pOprd0 = Expr::MakeBind(IdExprs);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = stack.mem */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      Expr::MakeMem(m_CpuInfo.GetSizeOfRegisterInBit(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode())), nullptr, Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo)));
    AllExpr.push_back(pExpr0);
    auto pExpr1 = /* Semantic: stack.id += op0.size */
    Expr::MakeAssign(
      Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo),
      Expr::MakeOp(
        OperationExpression::OpAdd,
        Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo),
        Expr::MakeConst(
          32,
          (rInsn.GetOperand(0)->GetSizeInBit() / 8))));
    AllExpr.push_back(pExpr1);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BKPT #<imm> - [] - [1, 0, 1, 1, 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_BKPT_T1_0000ff00_0000be00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BKPT");
  rInsn.SetOpcode(ARM_Opcode_Bkpt);
  rInsn.Length() += 2;

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// NOP<c> - [] - [1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]
bool ArmArchitecture::Instruction_NOP_T1_0000ffff_0000bf00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("NOP");
  rInsn.SetOpcode(ARM_Opcode_Nop);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// YIELD<c> - [] - [1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0]
bool ArmArchitecture::Instruction_YIELD_T1_0000ffff_0000bf10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("YIELD");
  rInsn.SetOpcode(ARM_Opcode_Yield);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// WFE<c> - [] - [1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0]
bool ArmArchitecture::Instruction_WFE_T1_0000ffff_0000bf20(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("WFE");
  rInsn.SetOpcode(ARM_Opcode_Wfe);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// WFI<c> - [] - [1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0]
bool ArmArchitecture::Instruction_WFI_T1_0000ffff_0000bf30(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("WFI");
  rInsn.SetOpcode(ARM_Opcode_Wfi);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SEV<c> - [] - [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0]
bool ArmArchitecture::Instruction_SEV_T1_0000ffff_0000bf40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SEV");
  rInsn.SetOpcode(ARM_Opcode_Sev);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// IT{x{y{z}}} <firstcond> - [] - [1, 0, 1, 1, 1, 1, 1, 1, 'firstcond', 'firstcond', 'firstcond', 'firstcond', 'mask_4', 'mask_4', 'mask_4', 'mask_4']
bool ArmArchitecture::Instruction_IT_T1_0000ff00_0000bf00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("IT");
  rInsn.SetOpcode(ARM_Opcode_It);
  rInsn.Length() += 2;

  // field: x{y{z
  /* unhandled field x{y{z */

  // field: firstcond
  /* unhandled field firstcond */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CB{N}Z <Rn>, <label> - ['cond', 'jmp'] - [1, 0, 1, 1, 'op', 0, 'i', 1, 'i', 'i', 'i', 'i', 'i', 'n', 'n', 'n']
bool ArmArchitecture::Instruction_CB_T1_0000f500_0000b100(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CB");
  rInsn.SetOpcode(ARM_Opcode_Cb);
  rInsn.Length() += 2;
  rInsn.SubType() |= Instruction::JumpType;

  // field: N
  /* unhandled field N */

  // field: Rn
  u32 RegN = ExtractBits<0, 2>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: label
  auto pOprd1 = Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(ARM_RegPC, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<3, 7>(Opcode))));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STM<c> <Rn>!,<registers> - [] - [1, 1, 0, 0, 0, 'n', 'n', 'n', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
bool ArmArchitecture::Instruction_STM_T1_0000f800_0000c000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STM");
  rInsn.SetOpcode(ARM_Opcode_Stm);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rn>!,<registers
  /* unhandled field Rn>!,<registers */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDM<c> <Rn>, <registers> - ['could_jmp'] - [1, 1, 0, 0, 1, 'n', 'n', 'n', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
bool ArmArchitecture::Instruction_LDM_T1_0000f800_0000c800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDM");
  rInsn.SetOpcode(ARM_Opcode_Ldm);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rn
  u32 RegN = ExtractBits<8, 10>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: registers
  u32 RegList = ExtractBits<0, 7>(Opcode);
  Expression::List IdExprs;
  for (u8 RegIdx = 0; RegIdx < 16; ++RegIdx)
  {
    if (RegList & (1 << RegIdx))
      IdExprs.push_back(Expr::MakeId(RegIdx + 1, &m_CpuInfo));
    if (RegIdx + 1 == ARM_RegPC)
      rInsn.SubType() |= Instruction::JumpType;
  }
  auto pOprd1 = Expr::MakeBind(IdExprs);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SVC<c> #<imm> - ['syscall'] - [1, 1, 0, 1, 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_SVC_T1_0000ff00_0000df00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SVC");
  rInsn.SetOpcode(ARM_Opcode_Svc);
  rInsn.Length() += 2;

  // field: c
  // TODO: unable to find conditional bits

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// B<c> <thumb_branch_label> - ['jmp'] - [1, 1, 0, 1, 'c', 'c', 'c', 'c', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_B_T1_0000f000_0000d000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("B");
  rInsn.SetOpcode(ARM_Opcode_B);
  rInsn.Length() += 2;
  rInsn.SubType() |= Instruction::JumpType;

  // field: c
  u8 CondField = ExtractBits<8, 11>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: thumb_branch_label
  auto pOprd0 = Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(ARM_RegPC, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)) << 1));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: program.id = op0.val */
    Expr::MakeAssign(
      Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::ProgramPointerRegister, rInsn.GetMode()), &m_CpuInfo),
      rInsn.GetOperand(0));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// B<c> <thumb_branch_label> - ['jmp'] - [1, 1, 1, 0, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_B_T2_0000f800_0000e000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("B");
  rInsn.SetOpcode(ARM_Opcode_B);
  rInsn.Length() += 2;
  rInsn.SubType() |= Instruction::JumpType;

  // field: c
  // TODO: unable to find conditional bits

  // field: thumb_branch_label
  auto pOprd0 = Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(ARM_RegPC, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 11>(ExtractBits<0, 10>(Opcode)) << 1));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: program.id = op0.val */
    Expr::MakeAssign(
      Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::ProgramPointerRegister, rInsn.GetMode()), &m_CpuInfo),
      rInsn.GetOperand(0));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STREX<c> <Rd>, <Rt>, [<Rn>{,#<imm>}] - [] - [1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STREX_T1_fff00000_e8400000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STREX");
  rInsn.SetOpcode(ARM_Opcode_Strex);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd1 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: [<Rn>{,#<imm>}]
  /* unhandled field [<Rn>{,#<imm>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDREX<c> <Rt>, [<Rn>{,#<imm>}] - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(1)', '(1)', '(1)', '(1)', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDREX_T1_fff00f00_e8500f00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDREX");
  rInsn.SetOpcode(ARM_Opcode_Ldrex);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>{,#<imm>}]
  /* unhandled field [<Rn>{,#<imm>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// PUSH<c>.W <registers> - [] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, '(0)', 'M', '(0)', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
bool ArmArchitecture::Instruction_PUSH_T2_ffffa000_e8ad0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("PUSH");
  rInsn.SetOpcode(ARM_Opcode_Push);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: registers
  u32 RegList = ExtractBits<0, 12>(Opcode);
  Expression::List IdExprs;
  for (u8 RegIdx = 0; RegIdx < 16; ++RegIdx)
  {
    if (RegList & (1 << RegIdx))
      IdExprs.push_back(Expr::MakeId(RegIdx + 1, &m_CpuInfo));
  }
  auto pOprd0 = Expr::MakeBind(IdExprs);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: stack.id -= op0.size */
    Expr::MakeAssign(
      Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo),
      Expr::MakeOp(
        OperationExpression::OpSub,
        Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo),
        Expr::MakeConst(
          32,
          (rInsn.GetOperand(0)->GetSizeInBit() / 8))));
    AllExpr.push_back(pExpr0);
    auto pExpr1 = /* Semantic: stack.mem = op0.val */
    Expr::MakeAssign(
      Expr::MakeMem(m_CpuInfo.GetSizeOfRegisterInBit(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode())), nullptr, Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo)),
      rInsn.GetOperand(0));
    AllExpr.push_back(pExpr1);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// POP<c>.W <registers> - ['could_ret'] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 'P', 'M', '(0)', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
bool ArmArchitecture::Instruction_POP_T2_ffff2000_e8bd0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("POP");
  rInsn.SetOpcode(ARM_Opcode_Pop);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: registers
  u32 RegList = ExtractBits<0, 12>(Opcode);
  Expression::List IdExprs;
  for (u8 RegIdx = 0; RegIdx < 16; ++RegIdx)
  {
    if (RegList & (1 << RegIdx))
      IdExprs.push_back(Expr::MakeId(RegIdx + 1, &m_CpuInfo));
    if (RegIdx + 1 == ARM_RegPC)
      rInsn.SubType() |= Instruction::ReturnType;
  }
  auto pOprd0 = Expr::MakeBind(IdExprs);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = stack.mem */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      Expr::MakeMem(m_CpuInfo.GetSizeOfRegisterInBit(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode())), nullptr, Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo)));
    AllExpr.push_back(pExpr0);
    auto pExpr1 = /* Semantic: stack.id += op0.size */
    Expr::MakeAssign(
      Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo),
      Expr::MakeOp(
        OperationExpression::OpAdd,
        Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo),
        Expr::MakeConst(
          32,
          (rInsn.GetOperand(0)->GetSizeInBit() / 8))));
    AllExpr.push_back(pExpr1);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STM<c>.W <Rn>{!},<registers> - [] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 'W', 0, 'n', 'n', 'n', 'n', '(0)', 'M', '(0)', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
bool ArmArchitecture::Instruction_STM_T2_ffd0a000_e8800000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STM");
  rInsn.SetOpcode(ARM_Opcode_Stm);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rn>{!},<registers
  /* unhandled field Rn>{!},<registers */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDM<c>.W <Rn>{!},<registers> - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 'W', 1, 'n', 'n', 'n', 'n', 'P', 'M', '(0)', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
bool ArmArchitecture::Instruction_LDM_T2_ffd02000_e8900000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDM");
  rInsn.SetOpcode(ARM_Opcode_Ldm);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rn>{!},<registers
  /* unhandled field Rn>{!},<registers */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STREXB<c> <Rd>, <Rt>, [<Rn>] - [] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 0, 'd', 'd', 'd', 'd']
bool ArmArchitecture::Instruction_STREXB_T1_fff00ff0_e8c00f40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STREXB");
  rInsn.SetOpcode(ARM_Opcode_Strexb);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<0, 3>(Opcode);
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd1 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd2 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STREXH<c> <Rd>, <Rt>, [<Rn>] - [] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 1, 'd', 'd', 'd', 'd']
bool ArmArchitecture::Instruction_STREXH_T1_fff00ff0_e8c00f50(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STREXH");
  rInsn.SetOpcode(ARM_Opcode_Strexh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<0, 3>(Opcode);
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd1 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd2 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STREXD<c> <Rd>, <Rt>, <Rt2>, [<Rn>] - [] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 't2', 't2', 't2', 't2', 0, 1, 1, 1, 'd', 'd', 'd', 'd']
bool ArmArchitecture::Instruction_STREXD_T1_fff000f0_e8c00070(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STREXD");
  rInsn.SetOpcode(ARM_Opcode_Strexd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<0, 3>(Opcode);
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd1 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd2 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// TBH<c> [<Rn>, <Rm>,LSL #1] - ['jmp'] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', 0, 0, 0, 'H', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_TBH_T1_fff0ffe0_e8d0f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("TBH");
  rInsn.SetOpcode(ARM_Opcode_Tbh);
  rInsn.Length() += 4;
  rInsn.SubType() |= Instruction::JumpType;

  // field: c
  // TODO: unable to find conditional bits

  // field: [<Rn>, <Rm>,LSL #1]
  /* unhandled field [<Rn>, <Rm>,LSL #1] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDREXB<c> <Rt>, [<Rn>] - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 0, '(1)', '(1)', '(1)', '(1)']
bool ArmArchitecture::Instruction_LDREXB_T1_fff00fff_e8d00f4f(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDREXB");
  rInsn.SetOpcode(ARM_Opcode_Ldrexb);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDREXH<c> <Rt>, [<Rn>] - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 1, '(1)', '(1)', '(1)', '(1)']
bool ArmArchitecture::Instruction_LDREXH_T1_fff00fff_e8d00f5f(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDREXH");
  rInsn.SetOpcode(ARM_Opcode_Ldrexh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDREXD<c> <Rt>, <Rt2>, [<Rn>] - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 't2', 't2', 't2', 't2', 0, 1, 1, 1, '(1)', '(1)', '(1)', '(1)']
bool ArmArchitecture::Instruction_LDREXD_T1_fff000ff_e8d0007f(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDREXD");
  rInsn.SetOpcode(ARM_Opcode_Ldrexd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: [<Rn>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(RegN + 1, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STMDB<c> <Rn>{!},<registers> - [] - [1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 'W', 0, 'n', 'n', 'n', 'n', '(0)', 'M', '(0)', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
bool ArmArchitecture::Instruction_STMDB_T1_ffd0a000_e9000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STMDB");
  rInsn.SetOpcode(ARM_Opcode_Stmdb);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rn>{!},<registers
  /* unhandled field Rn>{!},<registers */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDMDB<c> <Rn>{!},<registers> - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 'W', 1, 'n', 'n', 'n', 'n', 'P', 'M', '(0)', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r']
bool ArmArchitecture::Instruction_LDMDB_T1_ffd02000_e9100000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDMDB");
  rInsn.SetOpcode(ARM_Opcode_Ldmdb);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rn>{!},<registers
  /* unhandled field Rn>{!},<registers */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRD<c> <Rt>, <Rt2>, [PC,#-0] - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 0, 'P', 'U', 1, '(0)', 1, 1, 1, 1, 1, 't', 't', 't', 't', 't2', 't2', 't2', 't2', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRD_T1_fe7f0000_e85f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRD");
  rInsn.SetOpcode(ARM_Opcode_Ldrd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: [PC,#-0]
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_RegPC, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRD<c> <Rt>, <Rt2>, [<Rn>, #+/-<imm>]! - [] - [1, 1, 1, 0, 1, 0, 0, 'P', 'U', 1, 'W', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 't2', 't2', 't2', 't2', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STRD_T1_fe500000_e8400000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRD");
  rInsn.SetOpcode(ARM_Opcode_Strd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: [<Rn>, #+/-<imm>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(RegN + 1, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)))), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: !
  rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRD<c> <Rt>, <Rt2>, [<Rn>, #+/-<imm>]! - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 0, 'P', 'U', 1, 'W', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 't2', 't2', 't2', 't2', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRD_T1_fe500000_e8500000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRD");
  rInsn.SetOpcode(ARM_Opcode_Ldrd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: [<Rn>, #+/-<imm>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(RegN + 1, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)))), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: !
  rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// TST<c>.W <Rn>, <Rm>{,<shift>} - [] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_TST_T2_fff08f00_ea100f00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("TST");
  rInsn.SetOpcode(ARM_Opcode_Tst);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// AND{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 'S', 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_AND_T2_ffe08000_ea000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("AND");
  rInsn.SetOpcode(ARM_Opcode_And);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BIC{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 'S', 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_BIC_T2_ffe08000_ea200000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BIC");
  rInsn.SetOpcode(ARM_Opcode_Bic);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MOV{S}<c>.W <Rd>, <Rm> - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 'S', 1, 1, 1, 1, '(0)', 0, 0, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MOV_T3_ffeff0f0_ea4f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MOV");
  rInsn.SetOpcode(ARM_Opcode_Mov);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// RRX{S}<c> <Rd>, <Rm> - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 'S', 1, 1, 1, 1, '(0)', 0, 0, 0, 'd', 'd', 'd', 'd', 0, 0, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_RRX_T1_ffeff0f0_ea4f0030(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("RRX");
  rInsn.SetOpcode(ARM_Opcode_Rrx);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LSL{S}<c>.W <Rd>, <Rm>, #<imm5> - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 'S', 1, 1, 1, 1, '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LSL_T2_ffef8030_ea4f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LSL");
  rInsn.SetOpcode(ARM_Opcode_Lsl);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm5
  /* unhandled field imm5 */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LSR{S}<c>.W <Rd>, <Rm>, #<imm> - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 'S', 1, 1, 1, 1, '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LSR_T2_ffef8030_ea4f0010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LSR");
  rInsn.SetOpcode(ARM_Opcode_Lsr);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<6, 7>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ASR{S}<c>.W <Rd>, <Rm>, #<imm> - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 'S', 1, 1, 1, 1, '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 1, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_ASR_T2_ffef8030_ea4f0020(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ASR");
  rInsn.SetOpcode(ARM_Opcode_Asr);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<6, 7>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ROR{S}<c> <Rd>, <Rm>, #<imm> - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 'S', 1, 1, 1, 1, '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_ROR_T1_ffef8030_ea4f0030(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ROR");
  rInsn.SetOpcode(ARM_Opcode_Ror);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<6, 7>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ORR{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 'S', 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_ORR_T2_ffe08000_ea400000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ORR");
  rInsn.SetOpcode(ARM_Opcode_Orr);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MVN{S}<c>.W <Rd>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 'S', 1, 1, 1, 1, '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MVN_T2_ffef8000_ea6f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MVN");
  rInsn.SetOpcode(ARM_Opcode_Mvn);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ORN{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 'S', 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_ORN_T1_ffe08000_ea600000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ORN");
  rInsn.SetOpcode(ARM_Opcode_Orn);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// TEQ<c> <Rn>, <Rm>{,<shift>} - [] - [1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_TEQ_T1_fff08f00_ea900f00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("TEQ");
  rInsn.SetOpcode(ARM_Opcode_Teq);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// EOR{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 'S', 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_EOR_T2_ffe08000_ea800000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("EOR");
  rInsn.SetOpcode(ARM_Opcode_Eor);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// PKHTB<c> <Rd>, <Rn>, <Rm>{,ASR #<imm>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tb', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_PKHTB_T1_fff08010_eac00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("PKHTB");
  rInsn.SetOpcode(ARM_Opcode_Pkhtb);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,ASR
  /* unhandled field <Rm>{,ASR */

  // field: #<imm>}
  /* unhandled field #<imm>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CMN<c>.W <Rn>, <Rm>{,<shift>} - ['cond'] - [1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_CMN_T2_fff08f00_eb100f00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CMN");
  rInsn.SetOpcode(ARM_Opcode_Cmn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADD{S}<c>.W <Rd>, SP, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 'S', 1, 1, 0, 1, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_ADD_T3_ffef8000_eb0d0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADD");
  rInsn.SetOpcode(ARM_Opcode_Add);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: SP
  auto pOprd1 = Expr::MakeId(ARM_RegSP, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADD{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 'S', 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_ADD_T3_ffe08000_eb000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADD");
  rInsn.SetOpcode(ARM_Opcode_Add);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADC{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 'S', 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_ADC_T2_ffe08000_eb400000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADC");
  rInsn.SetOpcode(ARM_Opcode_Adc);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SBC{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 'S', 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SBC_T2_ffe08000_eb600000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SBC");
  rInsn.SetOpcode(ARM_Opcode_Sbc);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CMP<c>.W <Rn>, <Rm> {,<shift>} - ['cond'] - [1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_CMP_T3_fff08f00_ebb00f00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CMP");
  rInsn.SetOpcode(ARM_Opcode_Cmp);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: {,<shift>}
  /* unhandled field {,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SUB{S}<c> <Rd>, SP, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 'S', 1, 1, 0, 1, '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SUB_T1_ffef8000_ebad0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SUB");
  rInsn.SetOpcode(ARM_Opcode_Sub);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: SP
  auto pOprd1 = Expr::MakeId(ARM_RegSP, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SUB{S}<c>.W <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 'S', 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SUB_T2_ffe08000_eba00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SUB");
  rInsn.SetOpcode(ARM_Opcode_Sub);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// RSB{S}<c> <Rd>, <Rn>, <Rm>{,<shift>} - ['could_jmp'] - [1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 'S', 'n', 'n', 'n', 'n', '(0)', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'tp', 'tp', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_RSB_T1_ffe08000_ebc00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("RSB");
  rInsn.SetOpcode(ARM_Opcode_Rsb);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<shift>}
  /* unhandled field <Rm>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MCRR<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm> - ['support_it_block', 'could_jmp'] - [1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 't2', 't2', 't2', 't2', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc1', 'opc1', 'opc1', 'opc1', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MCRR_T1_fff00000_ec400000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MCRR");
  rInsn.SetOpcode(ARM_Opcode_Mcrr);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: opc1
  /* unhandled field opc1 */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: CRm
  /* unhandled field CRm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MRRC<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm> - ['support_it_block', 'could_jmp'] - [1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 't2', 't2', 't2', 't2', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc1', 'opc1', 'opc1', 'opc1', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MRRC_T1_fff00000_ec500000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MRRC");
  rInsn.SetOpcode(ARM_Opcode_Mrrc);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: opc
  /* unhandled field opc */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: CRm
  /* unhandled field CRm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMOV<c> <Sm>, <Sm1>, <Rt>, <Rt2> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 'op', 't2', 't2', 't2', 't2', 't', 't', 't', 't', 1, 0, 1, 0, 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMOV_T1_ffe00fd0_ec400a10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMOV");
  rInsn.SetOpcode(ARM_Opcode_Vmov);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Sm
  /* unhandled field Sm */

  // field: Sm1
  /* unhandled field Sm1 */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMOV<c> <Dm>, <Rt>, <Rt2> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 'op', 't2', 't2', 't2', 't2', 't', 't', 't', 't', 1, 0, 1, 1, 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMOV_T1_ffe00fd0_ec400b10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMOV");
  rInsn.SetOpcode(ARM_Opcode_Vmov);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dm
  /* unhandled field Dm */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VPOP <list> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 0, 1, 'D', 1, 1, 1, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VPOP_T2_ffbf0f00_ecbd0a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VPOP");
  rInsn.SetOpcode(ARM_Opcode_Vpop);
  rInsn.Length() += 4;

  // field: list
  /* unhandled field list */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VPOP <list> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 0, 1, 'D', 1, 1, 1, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VPOP_T1_ffbf0f00_ecbd0b00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VPOP");
  rInsn.SetOpcode(ARM_Opcode_Vpop);
  rInsn.Length() += 4;

  // field: list
  /* unhandled field list */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VPUSH<c> <list> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 1, 0, 'D', 1, 0, 1, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VPUSH_T2_ffbf0f00_ed2d0a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VPUSH");
  rInsn.SetOpcode(ARM_Opcode_Vpush);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: list
  /* unhandled field list */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VPUSH<c> <list> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 1, 0, 'D', 1, 0, 1, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VPUSH_T1_ffbf0f00_ed2d0b00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VPUSH");
  rInsn.SetOpcode(ARM_Opcode_Vpush);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: list
  /* unhandled field list */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSTR<c> <Sd>, [<Rn>{,#+/-<imm>}] - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 1, 'U', 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VSTR_T2_ff300f00_ed000a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSTR");
  rInsn.SetOpcode(ARM_Opcode_Vstr);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Sd
  /* unhandled field Sd */

  // field: [<Rn>{,#+/-<imm>}]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeMem(32, nullptr, Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(RegN + 1, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)))), true);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSTR<c> <Dd>, [<Rn>{,#+/-<imm>}] - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 1, 'U', 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VSTR_T1_ff300f00_ed000b00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSTR");
  rInsn.SetOpcode(ARM_Opcode_Vstr);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: [<Rn>{,#+/-<imm>}]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeMem(32, nullptr, Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(RegN + 1, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)))), true);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VLDR<c> <Sd>, [<Rn>{,#+/-<imm>}] - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 1, 'U', 'D', 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VLDR_T2_ff300f00_ed100a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VLDR");
  rInsn.SetOpcode(ARM_Opcode_Vldr);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Sd
  /* unhandled field Sd */

  // field: [<Rn>{,#+/-<imm>}]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeMem(32, nullptr, Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(RegN + 1, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)))), true);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VLDR<c> <Dd>, [<Rn>{,#+/-<imm>}] - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 1, 'U', 'D', 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VLDR_T1_ff300f00_ed100b00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VLDR");
  rInsn.SetOpcode(ARM_Opcode_Vldr);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: [<Rn>{,#+/-<imm>}]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeMem(32, nullptr, Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(RegN + 1, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)))), true);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSTM{mode}<c> <Rn>{!}, <list> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 'P', 'U', 'D', 'W', 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VSTM_T2_fe100f00_ec000a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSTM");
  rInsn.SetOpcode(ARM_Opcode_Vstm);
  rInsn.Length() += 4;

  // field: mode
  /* unhandled field mode */

  // field: c
  // TODO: unable to find conditional bits

  // field: W
  if (ExtractBit<21>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_W;

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: list
  /* unhandled field list */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSTM{mode}<c> <Rn>{!}, <list> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 'P', 'U', 'D', 'W', 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VSTM_T1_fe100f00_ec000b00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSTM");
  rInsn.SetOpcode(ARM_Opcode_Vstm);
  rInsn.Length() += 4;

  // field: mode
  /* unhandled field mode */

  // field: c
  // TODO: unable to find conditional bits

  // field: W
  if (ExtractBit<21>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_W;

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: list
  /* unhandled field list */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STC{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!} - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 'P', 'U', 'D', 'W', 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STC_T1_fe100000_ec000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STC");
  rInsn.SetOpcode(ARM_Opcode_Stc);
  rInsn.Length() += 4;

  // field: L
  /* unhandled field L */

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: CRd
  /* unhandled field CRd */

  // field: [<Rn>, #+/-<imm>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeMem(32, nullptr, Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(RegN + 1, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)))), true);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: W
  if (ExtractBit<21>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDC{L}<c> <coproc>, <CRd>, <label> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 'P', 'U', 'D', 'W', 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDC_T1_fe1f0000_ec1f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDC");
  rInsn.SetOpcode(ARM_Opcode_Ldc);
  rInsn.Length() += 4;

  // field: L
  /* unhandled field L */

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: CRd
  /* unhandled field CRd */

  // field: label
  auto pOprd0 = Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(ARM_RegPC, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode))));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VLDM{mode}<c> <Rn>{!}, <list> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 'P', 'U', 'D', 'W', 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VLDM_T2_fe100f00_ec100a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VLDM");
  rInsn.SetOpcode(ARM_Opcode_Vldm);
  rInsn.Length() += 4;

  // field: mode
  /* unhandled field mode */

  // field: c
  // TODO: unable to find conditional bits

  // field: W
  if (ExtractBit<21>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_W;

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: list
  /* unhandled field list */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VLDM{mode}<c> <Rn>{!}, <list> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 'P', 'U', 'D', 'W', 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VLDM_T1_fe100f00_ec100b00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VLDM");
  rInsn.SetOpcode(ARM_Opcode_Vldm);
  rInsn.Length() += 4;

  // field: mode
  /* unhandled field mode */

  // field: c
  // TODO: unable to find conditional bits

  // field: W
  if (ExtractBit<21>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_W;

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: list
  /* unhandled field list */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDC{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!} - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 0, 'P', 'U', 'D', 'W', 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDC_T1_fe100000_ec100000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDC");
  rInsn.SetOpcode(ARM_Opcode_Ldc);
  rInsn.Length() += 4;

  // field: L
  /* unhandled field L */

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: CRd
  /* unhandled field CRd */

  // field: [<Rn>, #+/-<imm>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeMem(32, nullptr, Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(RegN + 1, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)))), true);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: W
  if (ExtractBit<21>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMOV<c> <Sn>, <Rt> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 'op', 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 0, 1, 0, 'N', '(0)', '(0)', 1, '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VMOV_T1_ffe00f7f_ee000a10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMOV");
  rInsn.SetOpcode(ARM_Opcode_Vmov);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Sn
  /* unhandled field Sn */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op><c>.F64 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 0, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 'op', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_T2_ffb00e10_ee000a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VNMLA<c>.F64 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 0, 'D', 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 'op', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VNMLA_T1_ffb00e10_ee100a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VNMLA");
  rInsn.SetOpcode(ARM_Opcode_Vnmla);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMUL<c>.F64 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 0, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMUL_T2_ffb00e50_ee200a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMUL");
  rInsn.SetOpcode(ARM_Opcode_Vmul);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VNMUL<c>.F64 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 0, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VNMUL_T2_ffb00e50_ee200a40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VNMUL");
  rInsn.SetOpcode(ARM_Opcode_Vnmul);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VADD<c>.F64 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 0, 'D', 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VADD_T2_ffb00e50_ee300a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VADD");
  rInsn.SetOpcode(ARM_Opcode_Vadd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSUB<c>.F64 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 0, 'D', 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSUB_T2_ffb00e50_ee300a40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSUB");
  rInsn.SetOpcode(ARM_Opcode_Vsub);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMOV<c>.<size> <Dd[x]>, <Rt> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 0, 'opc1', 'opc1', 0, 'd', 'd', 'd', 'd', 't', 't', 't', 't', 1, 0, 1, 1, 'D', 'opc2', 'opc2', 1, '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VMOV_T1_ff900f1f_ee000b10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMOV");
  rInsn.SetOpcode(ARM_Opcode_Vmov);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Dd[x]
  /* unhandled field Dd[x] */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMSR<c> FPSCR, <Rt> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 't', 't', 't', 't', 1, 0, 1, 0, 0, '(0)', '(0)', 1, '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VMSR_T1_ffff0fff_eee10a10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMSR");
  rInsn.SetOpcode(ARM_Opcode_Vmsr);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: FPSCR
  /* unhandled field FPSCR */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMRS<c> <Rt>, FPSCR - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 't', 't', 't', 't', 1, 0, 1, 0, 0, '(0)', '(0)', 1, '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VMRS_T1_ffff0fff_eef10a10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMRS");
  rInsn.SetOpcode(ARM_Opcode_Vmrs);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: FPSCR
  /* unhandled field FPSCR */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VDUP<c>.<size> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'B', 'Q', 0, 'd', 'd', 'd', 'd', 't', 't', 't', 't', 1, 0, 1, 1, 'D', 0, 'E', 1, '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VDUP_T1_ff900f5f_ee800b10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VDUP");
  rInsn.SetOpcode(ARM_Opcode_Vdup);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VDIV<c>.F64 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VDIV_T1_ffb00e50_ee800a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VDIV");
  rInsn.SetOpcode(ARM_Opcode_Vdiv);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMOV<c>.F64 <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 0, 0, 0, 0, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 0, 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMOV_T2_ffbf0ed0_eeb00a40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMOV");
  rInsn.SetOpcode(ARM_Opcode_Vmov);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VABS<c>.F64 <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 0, 0, 0, 0, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 1, 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VABS_T2_ffbf0ed0_eeb00ac0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VABS");
  rInsn.SetOpcode(ARM_Opcode_Vabs);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VNEG<c>.F64 <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 0, 0, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 0, 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VNEG_T2_ffbf0ed0_eeb10a40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VNEG");
  rInsn.SetOpcode(ARM_Opcode_Vneg);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSQRT<c>.F64 <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 0, 0, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 1, 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSQRT_T1_ffbf0ed0_eeb10ac0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSQRT");
  rInsn.SetOpcode(ARM_Opcode_Vsqrt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCVT<y><c>.F32.F16 <Sd>, <Sm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 0, 0, 1, 'op', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'T', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCVT_T1_ffbe0f50_eeb20a40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCVT");
  rInsn.SetOpcode(ARM_Opcode_Vcvt);
  rInsn.Length() += 4;

  // field: y
  /* unhandled field y */

  // field: c
  // TODO: unable to find conditional bits

  // field: Sd
  /* unhandled field Sd */

  // field: Sm
  /* unhandled field Sm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCMP{E}<c>.F64 <Dd>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 0, 1, 0, 0, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'E', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCMP_T1_ffbf0e50_eeb40a40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCMP");
  rInsn.SetOpcode(ARM_Opcode_Vcmp);
  rInsn.Length() += 4;

  // field: E
  /* unhandled field E */

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCMP{E}<c>.F64 <Dd>, #0.0 - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 0, 1, 0, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'E', 1, '(0)', 0, '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VCMP_T2_ffbf0e7f_eeb50a40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCMP");
  rInsn.SetOpcode(ARM_Opcode_Vcmp);
  rInsn.Length() += 4;

  // field: E
  /* unhandled field E */

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: #0.0
  /* unhandled field #0.0 */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCVT<c>.F64.F32 <Dd>, <Sm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 0, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 1, 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCVT_T1_ffbf0ed0_eeb70ac0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCVT");
  rInsn.SetOpcode(ARM_Opcode_Vcvt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Sm
  /* unhandled field Sm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCVT<c>.<Td>.F64 <Dd>, <Dd>, #<fbits> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 1, 'op', 1, 'U', 'd', 'd', 'd', 'd', 1, 0, 1, 'sf', 'sx', 1, 'i', 0, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VCVT_T1_ffba0e50_eeba0a40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCVT");
  rInsn.SetOpcode(ARM_Opcode_Vcvt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Td
  /* unhandled field Td */

  // field: Dd
  /* unhandled field Dd */

  // field: Dd
  /* unhandled field Dd */

  // field: fbits
  /* unhandled field fbits */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCVT{R}<c>.S32.F64 <Sd>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 1, 'opc2', 'opc2', 'opc2', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', 'op', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCVT_T1_ffb80e50_eeb80a40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCVT");
  rInsn.SetOpcode(ARM_Opcode_Vcvt);
  rInsn.Length() += 4;

  // field: R
  /* unhandled field R */

  // field: c
  // TODO: unable to find conditional bits

  // field: Sd
  /* unhandled field Sd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMOV<c>.F64 <Dd>, #<imm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 1, 'D', 1, 1, 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 1, 'sz', '(0)', 0, '(0)', 0, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VMOV_T2_ffb00ef0_eeb00a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMOV");
  rInsn.SetOpcode(ARM_Opcode_Vmov);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 4>(ExtractBits<0, 3>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMOV<c>.<dt> <Rt>, <Dn[x]> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 'U', 'opc1', 'opc1', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 0, 1, 1, 'N', 'opc2', 'opc2', 1, '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_VMOV_T1_ff100f1f_ee100b10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMOV");
  rInsn.SetOpcode(ARM_Opcode_Vmov);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Dn[x]
  /* unhandled field Dn[x] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MCR<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['support_it_block', 'could_jmp'] - [1, 1, 1, 0, 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MCR_T1_ff100010_ee000010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MCR");
  rInsn.SetOpcode(ARM_Opcode_Mcr);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: opc1
  /* unhandled field opc1 */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: CRn
  /* unhandled field CRn */

  // field: <CRm>{,<opc2>}
  /* unhandled field <CRm>{,<opc2>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MRC<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['support_it_block', 'could_jmp'] - [1, 1, 1, 0, 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MRC_T1_ff100010_ee100010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MRC");
  rInsn.SetOpcode(ARM_Opcode_Mrc);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: opc1
  /* unhandled field opc1 */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: CRn
  /* unhandled field CRn */

  // field: <CRm>{,<opc2>}
  /* unhandled field <CRm>{,<opc2>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CDP<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 'opc1', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_CDP_T1_ff000010_ee000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CDP");
  rInsn.SetOpcode(ARM_Opcode_Cdp);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: opc1
  /* unhandled field opc1 */

  // field: CRd
  /* unhandled field CRd */

  // field: CRn
  /* unhandled field CRn */

  // field: CRm
  /* unhandled field CRm */

  // field: opc2
  /* unhandled field opc2 */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VAND<c> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VAND_T1_ffb00f10_ef000110(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VAND");
  rInsn.SetOpcode(ARM_Opcode_Vand);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VBIC<c> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 0, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VBIC_T1_ffb00f10_ef100110(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VBIC");
  rInsn.SetOpcode(ARM_Opcode_Vbic);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VADD<c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VADD_T1_ffa00f10_ef000d00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VADD");
  rInsn.SetOpcode(ARM_Opcode_Vadd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCEQ<c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCEQ_T2_ffa00f10_ef000e00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCEQ");
  rInsn.SetOpcode(ARM_Opcode_Vceq);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRECPS<c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRECPS_T1_ffa00f10_ef000f10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRECPS");
  rInsn.SetOpcode(ARM_Opcode_Vrecps);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VORR<c> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VORR_T1_ffb00f10_ef200110(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VORR");
  rInsn.SetOpcode(ARM_Opcode_Vorr);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VORN<c> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VORN_T1_ffb00f10_ef300110(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VORN");
  rInsn.SetOpcode(ARM_Opcode_Vorn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSUB<c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 1, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSUB_T1_ffa00f10_ef200d00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSUB");
  rInsn.SetOpcode(ARM_Opcode_Vsub);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRSQRTS<c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 1, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRSQRTS_T1_ffa00f10_ef200f10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRSQRTS");
  rInsn.SetOpcode(ARM_Opcode_Vrsqrts);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VADD<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VADD_T1_ff800f10_ef000800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VADD");
  rInsn.SetOpcode(ARM_Opcode_Vadd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VTST<c>.<size> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VTST_T1_ff800f10_ef000810(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VTST");
  rInsn.SetOpcode(ARM_Opcode_Vtst);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQDMULH<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQDMULH_T1_ff800f10_ef000b00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQDMULH");
  rInsn.SetOpcode(ARM_Opcode_Vqdmulh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VPADD<c>.<dt> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VPADD_T1_ff800f10_ef000b10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VPADD");
  rInsn.SetOpcode(ARM_Opcode_Vpadd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op><c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 'op', 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_T1_ff800f10_ef000d10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op><c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 0, 'D', 'op', 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_T1_ff800f10_ef000f00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VEXT<c>.8 <Qd>, <Qn>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 1, 'D', 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VEXT_T1_ffb00010_efb00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VEXT");
  rInsn.SetOpcode(ARM_Opcode_Vext);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 12>(ExtractBits<8, 11>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSHL<c>.I<size> <Qd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSHL_T1_ff800f10_ef800510(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSHL");
  rInsn.SetOpcode(ARM_Opcode_Vshl);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSHRN<c>.I<size> <Dd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSHRN_T1_ff800fd0_ef800810(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSHRN");
  rInsn.SetOpcode(ARM_Opcode_Vshrn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Qm
  /* unhandled field Qm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRSHRN<c>.I<size> <Dd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 0, 1, 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRSHRN_T1_ff800fd0_ef800850(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRSHRN");
  rInsn.SetOpcode(ARM_Opcode_Vrshrn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Qm
  /* unhandled field Qm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VADDHN<c>.<dt> <Dd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VADDHN_T1_ff800f50_ef800400(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VADDHN");
  rInsn.SetOpcode(ARM_Opcode_Vaddhn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSUBHN<c>.<dt> <Dd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSUBHN_T1_ff800f50_ef800600(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSUBHN");
  rInsn.SetOpcode(ARM_Opcode_Vsubhn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQD<op><c>.<dt> <Qd>, <Dn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 'op', 1, 1, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQD_T2_ff800b50_ef800340(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQD");
  rInsn.SetOpcode(ARM_Opcode_Vqd);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm[x]
  /* unhandled field Dm[x] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQDMULL_T2_ff800f50_ef800b40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQDMULL");
  rInsn.SetOpcode(ARM_Opcode_Vqdmull);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm[x]
  /* unhandled field Dm[x] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQD<op><c>.<dt> <Qd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 'op', 1, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQD_T1_ff800d50_ef800900(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQD");
  rInsn.SetOpcode(ARM_Opcode_Vqd);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQDMULL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 0, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQDMULL_T1_ff800f50_ef800d00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQDMULL");
  rInsn.SetOpcode(ARM_Opcode_Vqdmull);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MSR<c> <spec_reg>, <Rn> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 0, '(0)', 0, 'mask_4', 'mask_4', 0, 0, '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_MSR_T1_fff0f3ff_f3808000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MSR");
  rInsn.SetOpcode(ARM_Opcode_Msr);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: spec_reg
  /* unhandled field spec_reg */

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// NOP<c>.W - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, '(0)', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
bool ArmArchitecture::Instruction_NOP_T2_ffffffff_f3af8000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("NOP");
  rInsn.SetOpcode(ARM_Opcode_Nop);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// YIELD<c>.W - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, '(0)', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
bool ArmArchitecture::Instruction_YIELD_T2_ffffffff_f3af8001(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("YIELD");
  rInsn.SetOpcode(ARM_Opcode_Yield);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// WFE<c>.W - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, '(0)', 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]
bool ArmArchitecture::Instruction_WFE_T2_ffffffff_f3af8002(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("WFE");
  rInsn.SetOpcode(ARM_Opcode_Wfe);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// WFI<c>.W - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, '(0)', 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]
bool ArmArchitecture::Instruction_WFI_T2_ffffffff_f3af8003(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("WFI");
  rInsn.SetOpcode(ARM_Opcode_Wfi);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SEV<c>.W - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, '(0)', 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]
bool ArmArchitecture::Instruction_SEV_T2_ffffffff_f3af8004(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SEV");
  rInsn.SetOpcode(ARM_Opcode_Sev);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// DBG<c> #<option> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, '(0)', 0, 0, 0, 1, 1, 1, 1, 'option', 'option', 'option', 'option']
bool ArmArchitecture::Instruction_DBG_T1_fffffff0_f3af80f0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("DBG");
  rInsn.SetOpcode(ARM_Opcode_Dbg);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: option
  /* unhandled field option */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CLREX<c> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, '(1)', '(1)', '(1)', '(1)', 0, 0, 1, 0, '(1)', '(1)', '(1)', '(1)']
bool ArmArchitecture::Instruction_CLREX_T1_ffffffff_f3bf8f2f(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CLREX");
  rInsn.SetOpcode(ARM_Opcode_Clrex);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// DSB<c> #<option> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 0, 'option', 'option', 'option', 'option']
bool ArmArchitecture::Instruction_DSB_T1_fffffff0_f3bf8f40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("DSB");
  rInsn.SetOpcode(ARM_Opcode_Dsb);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: option
  /* unhandled field option */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// DMB<c> #<option> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, '(1)', '(1)', '(1)', '(1)', 0, 1, 0, 1, 'option', 'option', 'option', 'option']
bool ArmArchitecture::Instruction_DMB_T1_fffffff0_f3bf8f50(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("DMB");
  rInsn.SetOpcode(ARM_Opcode_Dmb);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: option
  /* unhandled field option */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ISB<c> #<option> - [] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, '(1)', '(1)', '(1)', '(1)', 0, 1, 1, 0, 'option', 'option', 'option', 'option']
bool ArmArchitecture::Instruction_ISB_T1_fffffff0_f3bf8f60(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ISB");
  rInsn.SetOpcode(ARM_Opcode_Isb);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: option
  /* unhandled field option */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BXJ<c> <Rm> - ['call', 'change_to_jazelle'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 'm', 'm', 'm', 'm', 1, 0, '(0)', 0, '(1)', '(1)', '(1)', '(1)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_BXJ_T1_fff0ffff_f3c08f00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BXJ");
  rInsn.SetOpcode(ARM_Opcode_Bxj);
  rInsn.Length() += 4;
  rInsn.SubType() |= Instruction::CallType;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rm
  u32 RegM = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MRS<c> <Rd>, <spec_reg> - ['could_jmp'] - [1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, '(1)', '(1)', '(1)', '(1)', 1, 0, '(0)', 0, 'd', 'd', 'd', 'd', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)', '(0)']
bool ArmArchitecture::Instruction_MRS_T1_fffff0ff_f3ef8000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MRS");
  rInsn.SetOpcode(ARM_Opcode_Mrs);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: spec_reg
  /* unhandled field spec_reg */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SSAT16<c> <Rd>, #<imm>, <Rn> - ['could_jmp'] - [1, 1, 1, 1, 0, '(0)', 1, 1, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 0, 0, 0, 0, 'd', 'd', 'd', 'd', 0, 0, '(0)', '(0)', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_SSAT16_T1_fff0f0f0_f3200000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SSAT16");
  rInsn.SetOpcode(ARM_Opcode_Ssat16);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: imm
  auto pOprd1 = Expr::MakeConst(32, SignExtend<s64, 4>(ExtractBits<0, 3>(Opcode)));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd2 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SSAT<c> <Rd>, #<imm>, <Rn>{,<shift>} - ['could_jmp'] - [1, 1, 1, 1, 0, '(0)', 1, 1, 0, 0, 'sh', 0, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', '(0)', 'sat_imm_5', 'sat_imm_5', 'sat_imm_5', 'sat_imm_5', 'sat_imm_5']
bool ArmArchitecture::Instruction_SSAT_T1_ffd08020_f3000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SSAT");
  rInsn.SetOpcode(ARM_Opcode_Ssat);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: imm
  auto pOprd1 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<6, 7>(Opcode)));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rn>{,<shift>}
  /* unhandled field <Rn>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SBFX<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - [1, 1, 1, 1, 0, '(0)', 1, 1, 0, 1, 0, 0, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', '(0)', 'widthm1', 'widthm1', 'widthm1', 'widthm1', 'widthm1']
bool ArmArchitecture::Instruction_SBFX_T1_fff08020_f3400000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SBFX");
  rInsn.SetOpcode(ARM_Opcode_Sbfx);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: lsb
  /* unhandled field lsb */

  // field: width
  /* unhandled field width */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BFC<c> <Rd>, #<lsb>, #<width> - ['could_jmp'] - [1, 1, 1, 1, 0, '(0)', 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', '(0)', 'msb', 'msb', 'msb', 'msb', 'msb']
bool ArmArchitecture::Instruction_BFC_T1_ffff8020_f36f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BFC");
  rInsn.SetOpcode(ARM_Opcode_Bfc);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: lsb
  /* unhandled field lsb */

  // field: width
  /* unhandled field width */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BFI<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - [1, 1, 1, 1, 0, '(0)', 1, 1, 0, 1, 1, 0, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', '(0)', 'msb', 'msb', 'msb', 'msb', 'msb']
bool ArmArchitecture::Instruction_BFI_T1_fff08020_f3600000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BFI");
  rInsn.SetOpcode(ARM_Opcode_Bfi);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: lsb
  /* unhandled field lsb */

  // field: width
  /* unhandled field width */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// USAT16<c> <Rd>, #<imm4>, <Rn> - ['could_jmp'] - [1, 1, 1, 1, 0, '(0)', 1, 1, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 0, 0, 0, 0, 'd', 'd', 'd', 'd', 0, 0, '(0)', '(0)', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_USAT16_T1_fff0f0f0_f3a00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("USAT16");
  rInsn.SetOpcode(ARM_Opcode_Usat16);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: imm4
  /* unhandled field imm4 */

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// USAT<c> <Rd>, #<imm5>, <Rn>{,<shift>} - ['could_jmp'] - [1, 1, 1, 1, 0, '(0)', 1, 1, 1, 0, 'sh', 0, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', '(0)', 'sat_imm_5', 'sat_imm_5', 'sat_imm_5', 'sat_imm_5', 'sat_imm_5']
bool ArmArchitecture::Instruction_USAT_T1_ffd08020_f3800000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("USAT");
  rInsn.SetOpcode(ARM_Opcode_Usat);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: imm5
  /* unhandled field imm5 */

  // field: <Rn>{,<shift>}
  /* unhandled field <Rn>{,<shift>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UBFX<c> <Rd>, <Rn>, #<lsb>, #<width> - ['could_jmp'] - [1, 1, 1, 1, 0, '(0)', 1, 1, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', '(0)', 'widthm1', 'widthm1', 'widthm1', 'widthm1', 'widthm1']
bool ArmArchitecture::Instruction_UBFX_T1_fff08020_f3c00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UBFX");
  rInsn.SetOpcode(ARM_Opcode_Ubfx);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: lsb
  /* unhandled field lsb */

  // field: width
  /* unhandled field width */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// B<c>.W <thumb_branch_label> - ['jmp'] - [1, 1, 1, 1, 0, 'S', 'c', 'c', 'c', 'c', 'i', 'i', 'i', 'i', 'i', 'i', 1, 0, 'J1', 0, 'J2', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_B_T3_f800d000_f0008000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("B");
  rInsn.SetOpcode(ARM_Opcode_B);
  rInsn.Length() += 4;
  rInsn.SubType() |= Instruction::JumpType;

  // field: c
  u8 CondField = ExtractBits<22, 25>(Opcode);
  rInsn.SetTestedFlags(CondField);
  if (CondField != 0xe)
    rInsn.SubType() |= Instruction::ConditionalType;

  // field: thumb_branch_label
  auto pOprd0 = Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(ARM_RegPC, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 11>(ExtractBits<0, 10>(Opcode)) << 1));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: program.id = op0.val */
    Expr::MakeAssign(
      Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::ProgramPointerRegister, rInsn.GetMode()), &m_CpuInfo),
      rInsn.GetOperand(0));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// B<c>.W <thumb_branch_label> - ['jmp'] - [1, 1, 1, 1, 0, 'S', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 1, 0, 'J1', 1, 'J2', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_B_T4_f800d000_f0009000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("B");
  rInsn.SetOpcode(ARM_Opcode_B);
  rInsn.Length() += 4;
  rInsn.SubType() |= Instruction::JumpType;

  // field: c
  // TODO: unable to find conditional bits

  // field: thumb_branch_label
  auto pOprd0 = Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(ARM_RegPC, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 11>(ExtractBits<0, 10>(Opcode)) << 1));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: program.id = op0.val */
    Expr::MakeAssign(
      Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::ProgramPointerRegister, rInsn.GetMode()), &m_CpuInfo),
      rInsn.GetOperand(0));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BLX<c> <label> - ['thumb_branch_label'] - [1, 1, 1, 1, 0, 'S', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 1, 1, 'J1', 0, 'J2', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 0]
bool ArmArchitecture::Instruction_BLX_T2_f800d001_f000c000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BLX");
  rInsn.SetOpcode(ARM_Opcode_Blx);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: label
  auto pOprd0 = Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(ARM_RegPC, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 11>(ExtractBits<1, 10>(Opcode))));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BL<c> <thumb_branch_label> - ['call'] - [1, 1, 1, 1, 0, 'S', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 1, 1, 'J1', 1, 'J2', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_BL_T1_f800d000_f000d000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BL");
  rInsn.SetOpcode(ARM_Opcode_Bl);
  rInsn.Length() += 4;
  rInsn.SubType() |= Instruction::CallType;

  // field: c
  // TODO: unable to find conditional bits

  // field: thumb_branch_label
  auto pOprd0 = Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(ARM_RegPC, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 11>(ExtractBits<0, 10>(Opcode)) << 1));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: lr.id = (program.id + insn.size) */
    Expr::MakeAssign(
      Expr::MakeId(ARM_RegLR, &m_CpuInfo),
      Expr::MakeOp(
        OperationExpression::OpAdd,
        Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::ProgramPointerRegister, rInsn.GetMode()), &m_CpuInfo),
        Expr::MakeConst(
          m_CpuInfo.GetSizeOfRegisterInBit(m_CpuInfo.GetRegisterByType(CpuInformation::ProgramPointerRegister, rInsn.GetMode())),
          rInsn.GetLength())));
    AllExpr.push_back(pExpr0);
    auto pExpr1 = /* Semantic: program.id = op0.val */
    Expr::MakeAssign(
      Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::ProgramPointerRegister, rInsn.GetMode()), &m_CpuInfo),
      rInsn.GetOperand(0));
    AllExpr.push_back(pExpr1);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// TST<c> <Rn>, #<const> - [] - [1, 1, 1, 1, 0, 'i', 0, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_TST_T1_fbf08f00_f0100f00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("TST");
  rInsn.SetOpcode(ARM_Opcode_Tst);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: const
  auto pOprd1 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// AND{S}<c> <Rd>, <Rn>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 0, 0, 0, 0, 'S', 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_AND_T1_fbe08000_f0000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("AND");
  rInsn.SetOpcode(ARM_Opcode_And);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: const
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// BIC{S}<c> <Rd>, <Rn>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 0, 0, 0, 1, 'S', 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_BIC_T1_fbe08000_f0200000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("BIC");
  rInsn.SetOpcode(ARM_Opcode_Bic);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: const
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MOV{S}<c>.W <Rd>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 0, 0, 1, 0, 'S', 1, 1, 1, 1, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_MOV_T2_fbef8000_f04f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MOV");
  rInsn.SetOpcode(ARM_Opcode_Mov);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: const
  auto pOprd1 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ORR{S}<c> <Rd>, <Rn>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 0, 0, 1, 0, 'S', 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_ORR_T1_fbe08000_f0400000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ORR");
  rInsn.SetOpcode(ARM_Opcode_Orr);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: const
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MVN{S}<c> <Rd>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 0, 0, 1, 1, 'S', 1, 1, 1, 1, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_MVN_T1_fbef8000_f06f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MVN");
  rInsn.SetOpcode(ARM_Opcode_Mvn);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: const
  auto pOprd1 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ORN{S}<c> <Rd>, <Rn>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 0, 0, 1, 1, 'S', 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_ORN_T1_fbe08000_f0600000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ORN");
  rInsn.SetOpcode(ARM_Opcode_Orn);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: const
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// TEQ<c> <Rn>, #<const> - [] - [1, 1, 1, 1, 0, 'i', 0, 0, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_TEQ_T1_fbf08f00_f0900f00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("TEQ");
  rInsn.SetOpcode(ARM_Opcode_Teq);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: const
  auto pOprd1 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// EOR{S}<c> <Rd>, <Rn>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 0, 1, 0, 0, 'S', 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_EOR_T1_fbe08000_f0800000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("EOR");
  rInsn.SetOpcode(ARM_Opcode_Eor);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: const
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CMN<c> <Rn>, #<const> - ['cond'] - [1, 1, 1, 1, 0, 'i', 0, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_CMN_T1_fbf08f00_f1100f00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CMN");
  rInsn.SetOpcode(ARM_Opcode_Cmn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: const
  auto pOprd1 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADD{S}<c>.W <Rd>, SP, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 1, 0, 0, 0, 'S', 1, 1, 0, 1, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_ADD_T3_fbef8000_f10d0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADD");
  rInsn.SetOpcode(ARM_Opcode_Add);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: SP
  auto pOprd1 = Expr::MakeId(ARM_RegSP, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: const
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADD{S}<c>.W <Rd>, <Rn>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 1, 0, 0, 0, 'S', 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_ADD_T3_fbe08000_f1000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADD");
  rInsn.SetOpcode(ARM_Opcode_Add);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: const
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADC{S}<c> <Rd>, <Rn>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 1, 0, 1, 0, 'S', 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_ADC_T1_fbe08000_f1400000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADC");
  rInsn.SetOpcode(ARM_Opcode_Adc);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: const
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SBC{S}<c> <Rd>, <Rn>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 1, 0, 1, 1, 'S', 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_SBC_T1_fbe08000_f1600000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SBC");
  rInsn.SetOpcode(ARM_Opcode_Sbc);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: const
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CMP<c>.W <Rn>, #<const> - ['cond'] - [1, 1, 1, 1, 0, 'i', 0, 1, 1, 0, 1, 1, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_CMP_T2_fbf08f00_f1b00f00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CMP");
  rInsn.SetOpcode(ARM_Opcode_Cmp);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: const
  auto pOprd1 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SUB{S}<c>.W <Rd>, SP, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 1, 1, 0, 1, 'S', 1, 1, 0, 1, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_SUB_T2_fbef8000_f1ad0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SUB");
  rInsn.SetOpcode(ARM_Opcode_Sub);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: SP
  auto pOprd1 = Expr::MakeId(ARM_RegSP, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: const
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SUB{S}<c>.W <Rd>, <Rn>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 1, 1, 0, 1, 'S', 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_SUB_T3_fbe08000_f1a00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SUB");
  rInsn.SetOpcode(ARM_Opcode_Sub);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: const
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// RSB{S}<c>.W <Rd>, <Rn>, #<const> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 0, 1, 1, 1, 0, 'S', 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_RSB_T2_fbe08000_f1c00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("RSB");
  rInsn.SetOpcode(ARM_Opcode_Rsb);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: const
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADDW<c> <Rd>, SP, #<imm> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_ADDW_T4_fbff8000_f20d0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADDW");
  rInsn.SetOpcode(ARM_Opcode_Addw);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: SP
  auto pOprd1 = Expr::MakeId(ARM_RegSP, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADR<c>.W <Rd>, <label> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_ADR_T3_fbff8000_f20f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADR");
  rInsn.SetOpcode(ARM_Opcode_Adr);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: label
  auto pOprd1 = Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(ARM_RegPC, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode))));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ADDW<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 1, 0, 0, 0, 0, 0, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_ADDW_T4_fbf08000_f2000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ADDW");
  rInsn.SetOpcode(ARM_Opcode_Addw);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MOVW<c> <Rd>, #<imm> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 1, 0, 0, 1, 0, 0, 'i', 'i', 'i', 'i', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_MOVW_T3_fbf08000_f2400000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MOVW");
  rInsn.SetOpcode(ARM_Opcode_Movw);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: imm
  auto pOprd1 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SUBW<c> <Rd>, SP, #<imm> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_SUBW_T3_fbff8000_f2ad0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SUBW");
  rInsn.SetOpcode(ARM_Opcode_Subw);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: SP
  auto pOprd1 = Expr::MakeId(ARM_RegSP, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SUB <Rd>, PC, #0 - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_SUB_T2_fbff8000_f2af0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SUB");
  rInsn.SetOpcode(ARM_Opcode_Sub);
  rInsn.Length() += 4;

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: PC
  auto pOprd1 = Expr::MakeId(ARM_RegPC, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: #0
  auto pOprd2 = Expr::MakeConst(32, 0);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SUBW<c> <Rd>, <Rn>, #<imm> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 1, 0, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_SUBW_T4_fbf08000_f2a00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SUBW");
  rInsn.SetOpcode(ARM_Opcode_Subw);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: imm
  auto pOprd2 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MOVT<c> <Rd>, #<imm> - ['could_jmp'] - [1, 1, 1, 1, 0, 'i', 1, 0, 1, 1, 0, 0, 'i', 'i', 'i', 'i', 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_MOVT_T1_fbf08000_f2c00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MOVT");
  rInsn.SetOpcode(ARM_Opcode_Movt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: imm
  auto pOprd1 = Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)));
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRB<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 0, 0, 0, 0, 0, 0, 'i', 'i', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_STRB_T2_fff00fc0_f8000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRB");
  rInsn.SetOpcode(ARM_Opcode_Strb);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, <Rm>{,LSL #<imm>}]
  /* unhandled field [<Rn>, <Rm>{,LSL #<imm>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRBT<c> <Rt>, [<Rn>, #<imm>] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STRBT_T1_fff00f00_f8000e00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRBT");
  rInsn.SetOpcode(ARM_Opcode_Strbt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRB<c> <Rt>, [<Rn>, #<imm>]! - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 'P', 'U', 'W', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STRB_T3_fff00800_f8000800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRB");
  rInsn.SetOpcode(ARM_Opcode_Strb);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */

  // field: !
  rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRB<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 0, 0, 0, 0, 0, 0, 'i', 'i', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LDRB_T2_fff00fc0_f8100000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRB");
  rInsn.SetOpcode(ARM_Opcode_Ldrb);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, <Rm>{,LSL #<imm>}]
  /* unhandled field [<Rn>, <Rm>{,LSL #<imm>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRBT<c> <Rt>, [<Rn>, #<imm>] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRBT_T1_fff00f00_f8100e00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRBT");
  rInsn.SetOpcode(ARM_Opcode_Ldrbt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRB<c> <Rt>, [<Rn>, #<imm>]! - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 'P', 'U', 'W', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRB_T3_fff00800_f8100800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRB");
  rInsn.SetOpcode(ARM_Opcode_Ldrb);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */

  // field: !
  rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRH<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 0, 0, 0, 0, 0, 0, 'i', 'i', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_STRH_T2_fff00fc0_f8200000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRH");
  rInsn.SetOpcode(ARM_Opcode_Strh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, <Rm>{,LSL #<imm>}]
  /* unhandled field [<Rn>, <Rm>{,LSL #<imm>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRHT<c> <Rt>, [<Rn>, #<imm>] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STRHT_T1_fff00f00_f8200e00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRHT");
  rInsn.SetOpcode(ARM_Opcode_Strht);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRH<c> <Rt>, [<Rn>, #<imm>]! - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 'P', 'U', 'W', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STRH_T3_fff00800_f8200800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRH");
  rInsn.SetOpcode(ARM_Opcode_Strh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */

  // field: !
  rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRH<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 0, 0, 0, 0, 0, 0, 'i', 'i', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LDRH_T2_fff00fc0_f8300000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRH");
  rInsn.SetOpcode(ARM_Opcode_Ldrh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, <Rm>{,LSL #<imm>}]
  /* unhandled field [<Rn>, <Rm>{,LSL #<imm>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRHT<c> <Rt>, [<Rn>, #<imm>] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRHT_T1_fff00f00_f8300e00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRHT");
  rInsn.SetOpcode(ARM_Opcode_Ldrht);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRH<c> <Rt>, [<Rn>, #<imm>]! - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 'P', 'U', 'W', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRH_T3_fff00800_f8300800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRH");
  rInsn.SetOpcode(ARM_Opcode_Ldrh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */

  // field: !
  rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// PLD{R}<c> [<Rn>, <Rm>{,LSL #<imm>}] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 'R', 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 'i', 'i', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_PLD_T1_ffd0ffc0_f810f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("PLD");
  rInsn.SetOpcode(ARM_Opcode_Pld);
  rInsn.Length() += 4;

  // field: R
  /* unhandled field R */

  // field: c
  // TODO: unable to find conditional bits

  // field: [<Rn>, <Rm>{,LSL #<imm>}]
  /* unhandled field [<Rn>, <Rm>{,LSL #<imm>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// PLD{R}<c> [<Rn>, #-<imm>] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 'R', 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 1, 1, 0, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_PLD_T2_ffd0ff00_f810fc00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("PLD");
  rInsn.SetOpcode(ARM_Opcode_Pld);
  rInsn.Length() += 4;

  // field: R
  /* unhandled field R */

  // field: c
  // TODO: unable to find conditional bits

  // field: [<Rn>, #-<imm>]
  /* unhandled field [<Rn>, #-<imm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// PUSH<c>.W <Rt> - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 't', 't', 't', 't', 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0]
bool ArmArchitecture::Instruction_PUSH_T3_ffff0fff_f84d0d04(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("PUSH");
  rInsn.SetOpcode(ARM_Opcode_Push);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: stack.id -= op0.size */
    Expr::MakeAssign(
      Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo),
      Expr::MakeOp(
        OperationExpression::OpSub,
        Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo),
        Expr::MakeConst(
          32,
          (rInsn.GetOperand(0)->GetSizeInBit() / 8))));
    AllExpr.push_back(pExpr0);
    auto pExpr1 = /* Semantic: stack.mem = op0.val */
    Expr::MakeAssign(
      Expr::MakeMem(m_CpuInfo.GetSizeOfRegisterInBit(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode())), nullptr, Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo)),
      rInsn.GetOperand(0));
    AllExpr.push_back(pExpr1);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STR<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 0, 0, 0, 0, 0, 0, 'i', 'i', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_STR_T2_fff00fc0_f8400000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STR");
  rInsn.SetOpcode(ARM_Opcode_Str);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, <Rm>{,LSL #<imm>}]
  /* unhandled field [<Rn>, <Rm>{,LSL #<imm>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRT<c> <Rt>, [<Rn>, #<imm>] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STRT_T1_fff00f00_f8400e00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRT");
  rInsn.SetOpcode(ARM_Opcode_Strt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STR<c> <Rt>, [<Rn>, #<imm>]! - [] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 'P', 'U', 'W', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STR_T4_fff00800_f8400800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STR");
  rInsn.SetOpcode(ARM_Opcode_Str);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */

  // field: !
  rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// POP<c>.W <Rt> - ['could_ret'] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 't', 't', 't', 't', 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0]
bool ArmArchitecture::Instruction_POP_T3_ffff0fff_f85d0b04(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("POP");
  rInsn.SetOpcode(ARM_Opcode_Pop);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::ReturnType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = stack.mem */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      Expr::MakeMem(m_CpuInfo.GetSizeOfRegisterInBit(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode())), nullptr, Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo)));
    AllExpr.push_back(pExpr0);
    auto pExpr1 = /* Semantic: stack.id += op0.size */
    Expr::MakeAssign(
      Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo),
      Expr::MakeOp(
        OperationExpression::OpAdd,
        Expr::MakeId(m_CpuInfo.GetRegisterByType(CpuInformation::StackPointerRegister, rInsn.GetMode()), &m_CpuInfo),
        Expr::MakeConst(
          32,
          (rInsn.GetOperand(0)->GetSizeInBit() / 8))));
    AllExpr.push_back(pExpr1);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDR<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 0, 0, 0, 0, 0, 0, 'i', 'i', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LDR_T2_fff00fc0_f8500000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDR");
  rInsn.SetOpcode(ARM_Opcode_Ldr);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, <Rm>{,LSL #<imm>}]
  /* unhandled field [<Rn>, <Rm>{,LSL #<imm>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRT<c> <Rt>, [<Rn>, #<imm>] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRT_T1_fff00f00_f8500e00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRT");
  rInsn.SetOpcode(ARM_Opcode_Ldrt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDR<c> <Rt>, [<Rn>, #<imm>]! - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 'P', 'U', 'W', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDR_T4_fff00800_f8500800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDR");
  rInsn.SetOpcode(ARM_Opcode_Ldr);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */

  // field: !
  rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRB<c>.W <Rt>, [<Rn>, #<imm>] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STRB_T2_fff00000_f8800000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRB");
  rInsn.SetOpcode(ARM_Opcode_Strb);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRB<c>.W <Rt>, [<Rn>{,#<imm>}] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRB_T2_fff00000_f8900000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRB");
  rInsn.SetOpcode(ARM_Opcode_Ldrb);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>{,#<imm>}]
  /* unhandled field [<Rn>{,#<imm>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STRH<c>.W <Rt>, [<Rn>{,#<imm>}] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STRH_T2_fff00000_f8a00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STRH");
  rInsn.SetOpcode(ARM_Opcode_Strh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>{,#<imm>}]
  /* unhandled field [<Rn>{,#<imm>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRH<c>.W <Rt>, [<Rn>{,#<imm>}] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRH_T2_fff00000_f8b00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRH");
  rInsn.SetOpcode(ARM_Opcode_Ldrh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>{,#<imm>}]
  /* unhandled field [<Rn>{,#<imm>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// PLD{R}<c> [<Rn>, #<imm>] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 'R', 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_PLD_T1_ffd0f000_f890f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("PLD");
  rInsn.SetOpcode(ARM_Opcode_Pld);
  rInsn.Length() += 4;

  // field: R
  /* unhandled field R */

  // field: c
  // TODO: unable to find conditional bits

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STR<c>.W <Rt>, [<Rn>, #<imm>] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STR_T3_fff00000_f8c00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STR");
  rInsn.SetOpcode(ARM_Opcode_Str);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDR<c>.W <Rt>, [<Rn>{,#<imm>}] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDR_T3_fff00000_f8d00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDR");
  rInsn.SetOpcode(ARM_Opcode_Ldr);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>{,#<imm>}]
  /* unhandled field [<Rn>{,#<imm>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRB<c> <Rt>, [PC,#-0] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 'U', 0, 0, 1, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRB_T1_ff7f0000_f81f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRB");
  rInsn.SetOpcode(ARM_Opcode_Ldrb);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [PC,#-0]
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_RegPC, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRH<c> <Rt>, [PC,#-0] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 'U', 0, 1, 1, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRH_T1_ff7f0000_f83f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRH");
  rInsn.SetOpcode(ARM_Opcode_Ldrh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [PC,#-0]
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_RegPC, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// PLD<c> [PC,#-0] - [] - [1, 1, 1, 1, 1, 0, 0, 0, 'U', 0, '(0)', 1, 1, 1, 1, 1, 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_PLD_T1_ff7ff000_f81ff000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("PLD");
  rInsn.SetOpcode(ARM_Opcode_Pld);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: [PC,#-0]
  auto pOprd0 = Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_RegPC, &m_CpuInfo), true);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDR<c>.W <Rt>, [PC,#-0] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 0, 'U', 1, 0, 1, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDR_T2_ff7f0000_f85f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDR");
  rInsn.SetOpcode(ARM_Opcode_Ldr);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [PC,#-0]
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_RegPC, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    auto pExpr0 = /* Semantic: op0.val = op1.val */
    Expr::MakeAssign(
      rInsn.GetOperand(0),
      rInsn.GetOperand(1));
    AllExpr.push_back(pExpr0);
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// PLI<c> [<Rn>, <Rm>{,LSL #<imm>}] - [] - [1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 'i', 'i', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_PLI_T1_fff0ffc0_f910f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("PLI");
  rInsn.SetOpcode(ARM_Opcode_Pli);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: [<Rn>, <Rm>{,LSL #<imm>}]
  /* unhandled field [<Rn>, <Rm>{,LSL #<imm>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// PLI<c> [<Rn>,#-<imm>] - [] - [1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 1, 1, 0, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_PLI_T2_fff0ff00_f910fc00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("PLI");
  rInsn.SetOpcode(ARM_Opcode_Pli);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: [<Rn>,#-<imm>]
  /* unhandled field [<Rn>,#-<imm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSB<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 0, 0, 0, 0, 0, 0, 'i', 'i', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LDRSB_T2_fff00fc0_f9100000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSB");
  rInsn.SetOpcode(ARM_Opcode_Ldrsb);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, <Rm>{,LSL #<imm>}]
  /* unhandled field [<Rn>, <Rm>{,LSL #<imm>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSBT<c> <Rt>, [<Rn>, #<imm>] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRSBT_T1_fff00f00_f9100e00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSBT");
  rInsn.SetOpcode(ARM_Opcode_Ldrsbt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSB<c> <Rt>, [<Rn>, #<imm>]! - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 'P', 'U', 'W', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRSB_T2_fff00800_f9100800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSB");
  rInsn.SetOpcode(ARM_Opcode_Ldrsb);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */

  // field: !
  rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSH<c>.W <Rt>, [<Rn>, <Rm>{,LSL #<imm>}] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 0, 0, 0, 0, 0, 0, 'i', 'i', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LDRSH_T2_fff00fc0_f9300000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSH");
  rInsn.SetOpcode(ARM_Opcode_Ldrsh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, <Rm>{,LSL #<imm>}]
  /* unhandled field [<Rn>, <Rm>{,LSL #<imm>}] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSHT<c> <Rt>, [<Rn>, #<imm>] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 1, 1, 0, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRSHT_T1_fff00f00_f9300e00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSHT");
  rInsn.SetOpcode(ARM_Opcode_Ldrsht);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSH<c> <Rt>, [<Rn>, #<imm>]! - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 1, 'P', 'U', 'W', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRSH_T2_fff00800_f9300800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSH");
  rInsn.SetOpcode(ARM_Opcode_Ldrsh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */

  // field: !
  rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VST1<c>.<size> <list>, [<Rn>{@<align>}]{!} - ['support_it_block'] - [1, 1, 1, 1, 1, 0, 0, 1, 0, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'tp', 'tp', 'tp', 'tp', 'i', 'i', 'align', 'align', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VST1_T1_ffb00000_f9000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VST1");
  rInsn.SetOpcode(ARM_Opcode_Vst1);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: list
  /* unhandled field list */

  // field: [<Rn>{@<align>}]
  /* unhandled field [<Rn>{@<align>}] */

  // field: W
  if (ExtractBits<0, 3>(Opcode) != 15)
    rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VLD1<c>.<size> <list>, [<Rn>{@<align>}]{!} - ['support_it_block'] - [1, 1, 1, 1, 1, 0, 0, 1, 0, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'tp', 'tp', 'tp', 'tp', 'i', 'i', 'align', 'align', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VLD1_T1_ffb00000_f9200000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VLD1");
  rInsn.SetOpcode(ARM_Opcode_Vld1);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: list
  /* unhandled field list */

  // field: [<Rn>{@<align>}]
  /* unhandled field [<Rn>{@<align>}] */

  // field: W
  if (ExtractBits<0, 3>(Opcode) != 15)
    rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// PLI<c> [<Rn>,#<imm>] - [] - [1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_PLI_T1_fff0f000_f990f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("PLI");
  rInsn.SetOpcode(ARM_Opcode_Pli);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: [<Rn>,#<imm>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeMem(32, nullptr, Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(RegN + 1, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 12>(ExtractBits<0, 11>(Opcode)))), true);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSB<c> <Rt>, [<Rn>, #<imm>] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRSB_T1_fff00000_f9900000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSB");
  rInsn.SetOpcode(ARM_Opcode_Ldrsb);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSH<c> <Rt>, [<Rn>, #<imm>] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRSH_T1_fff00000_f9b00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSH");
  rInsn.SetOpcode(ARM_Opcode_Ldrsh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [<Rn>, #<imm>]
  /* unhandled field [<Rn>, #<imm>] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VST1<c>.<size> <list>, [<Rn>{@<align>}]{!} - ['support_it_block'] - [1, 1, 1, 1, 1, 0, 0, 1, 1, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 0, 0, 'index_align', 'index_align', 'index_align', 'index_align', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VST1_T1_ffb00300_f9800000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VST1");
  rInsn.SetOpcode(ARM_Opcode_Vst1);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: list
  /* unhandled field list */

  // field: [<Rn>{@<align>}]
  /* unhandled field [<Rn>{@<align>}] */

  // field: W
  if (ExtractBits<0, 3>(Opcode) != 15)
    rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VLD1<c>.<size> <list>, [<Rn>{@<align>}]{!} - ['support_it_block'] - [1, 1, 1, 1, 1, 0, 0, 1, 1, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 0, 'i', 'i', 'T', 'A', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VLD1_T1_ffb00f00_f9a00c00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VLD1");
  rInsn.SetOpcode(ARM_Opcode_Vld1);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: list
  /* unhandled field list */

  // field: [<Rn>{@<align>}]
  /* unhandled field [<Rn>{@<align>}] */

  // field: W
  if (ExtractBits<0, 3>(Opcode) != 15)
    rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VLD1<c>.<size> <list>, [<Rn>{@<align>}]{!} - ['support_it_block'] - [1, 1, 1, 1, 1, 0, 0, 1, 1, 'D', 1, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'i', 'i', 0, 0, 'index_align', 'index_align', 'index_align', 'index_align', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VLD1_T1_ffb00300_f9a00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VLD1");
  rInsn.SetOpcode(ARM_Opcode_Vld1);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: list
  /* unhandled field list */

  // field: [<Rn>{@<align>}]
  /* unhandled field [<Rn>{@<align>}] */

  // field: W
  if (ExtractBits<0, 3>(Opcode) != 15)
    rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// PLI<c> [PC,#-0] - [] - [1, 1, 1, 1, 1, 0, 0, 1, 'U', 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_PLI_T3_ff7ff000_f91ff000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("PLI");
  rInsn.SetOpcode(ARM_Opcode_Pli);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: [PC,#-0]
  auto pOprd0 = Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_RegPC, &m_CpuInfo), true);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSB<c> <Rt>, [PC,#-0] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 1, 'U', 0, 0, 1, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRSB_T1_ff7f0000_f91f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSB");
  rInsn.SetOpcode(ARM_Opcode_Ldrsb);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [PC,#-0]
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_RegPC, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDRSH<c> <Rt>, [PC,#-0] - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 0, 1, 'U', 0, 1, 1, 1, 1, 1, 1, 't', 't', 't', 't', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDRSH_T1_ff7f0000_f93f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDRSH");
  rInsn.SetOpcode(ARM_Opcode_Ldrsh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: [PC,#-0]
  auto pOprd1 = Expr::MakeMem(32, nullptr, Expr::MakeId(ARM_RegPC, &m_CpuInfo), true);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SXTH<c>.W <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SXTH_T2_fffff0c0_fa0ff080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SXTH");
  rInsn.SetOpcode(ARM_Opcode_Sxth);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SXTAH<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SXTAH_T1_fff0f0c0_fa00f080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SXTAH");
  rInsn.SetOpcode(ARM_Opcode_Sxtah);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UXTH<c>.W <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UXTH_T2_fffff0c0_fa1ff080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UXTH");
  rInsn.SetOpcode(ARM_Opcode_Uxth);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UXTAH<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UXTAH_T1_fff0f0c0_fa10f080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UXTAH");
  rInsn.SetOpcode(ARM_Opcode_Uxtah);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LSL{S}<c>.W <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 'S', 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LSL_T2_ffe0f0f0_fa00f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LSL");
  rInsn.SetOpcode(ARM_Opcode_Lsl);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SXTB16<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SXTB16_T1_fffff0c0_fa2ff080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SXTB16");
  rInsn.SetOpcode(ARM_Opcode_Sxtb16);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SXTAB16<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SXTAB16_T1_fff0f0c0_fa20f080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SXTAB16");
  rInsn.SetOpcode(ARM_Opcode_Sxtab16);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UXTB16<c> <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UXTB16_T1_fffff0c0_fa3ff080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UXTB16");
  rInsn.SetOpcode(ARM_Opcode_Uxtb16);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UXTAB16<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UXTAB16_T1_fff0f0c0_fa30f080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UXTAB16");
  rInsn.SetOpcode(ARM_Opcode_Uxtab16);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LSR{S}<c>.W <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 'S', 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_LSR_T2_ffe0f0f0_fa20f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LSR");
  rInsn.SetOpcode(ARM_Opcode_Lsr);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SXTB<c>.W <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SXTB_T2_fffff0c0_fa4ff080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SXTB");
  rInsn.SetOpcode(ARM_Opcode_Sxtb);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SXTAB<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SXTAB_T1_fff0f0c0_fa40f080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SXTAB");
  rInsn.SetOpcode(ARM_Opcode_Sxtab);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UXTB<c>.W <Rd>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UXTB_T2_fffff0c0_fa5ff080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UXTB");
  rInsn.SetOpcode(ARM_Opcode_Uxtb);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UXTAB<c> <Rd>, <Rn>, <Rm>{,<rotation>} - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, '(0)', 'rotate', 'rotate', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UXTAB_T1_fff0f0c0_fa50f080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UXTAB");
  rInsn.SetOpcode(ARM_Opcode_Uxtab);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: <Rm>{,<rotation>}
  /* unhandled field <Rm>{,<rotation>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ASR{S}<c>.W <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 'S', 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_ASR_T2_ffe0f0f0_fa40f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ASR");
  rInsn.SetOpcode(ARM_Opcode_Asr);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// ROR{S}<c>.W <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 'S', 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_ROR_T2_ffe0f0f0_fa60f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("ROR");
  rInsn.SetOpcode(ARM_Opcode_Ror);
  rInsn.Length() += 4;

  // field: S
  if (ExtractBit<20>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_S;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SADD8_T1_fff0f0f0_fa80f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SADD8");
  rInsn.SetOpcode(ARM_Opcode_Sadd8);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// QADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_QADD8_T1_fff0f0f0_fa80f010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("QADD8");
  rInsn.SetOpcode(ARM_Opcode_Qadd8);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SHADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SHADD8_T1_fff0f0f0_fa80f020(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SHADD8");
  rInsn.SetOpcode(ARM_Opcode_Shadd8);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UADD8_T1_fff0f0f0_fa80f040(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UADD8");
  rInsn.SetOpcode(ARM_Opcode_Uadd8);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UQADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UQADD8_T1_fff0f0f0_fa80f050(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UQADD8");
  rInsn.SetOpcode(ARM_Opcode_Uqadd8);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UHADD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UHADD8_T1_fff0f0f0_fa80f060(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UHADD8");
  rInsn.SetOpcode(ARM_Opcode_Uhadd8);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// QADD<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_QADD_T1_fff0f0f0_fa80f080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("QADD");
  rInsn.SetOpcode(ARM_Opcode_Qadd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd2 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// QDADD<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_QDADD_T1_fff0f0f0_fa80f090(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("QDADD");
  rInsn.SetOpcode(ARM_Opcode_Qdadd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd2 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// QSUB<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_QSUB_T1_fff0f0f0_fa80f0a0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("QSUB");
  rInsn.SetOpcode(ARM_Opcode_Qsub);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd2 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// QDSUB<c> <Rd>, <Rm>, <Rn> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_QDSUB_T1_fff0f0f0_fa80f0b0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("QDSUB");
  rInsn.SetOpcode(ARM_Opcode_Qdsub);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd2 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// REV<c>.W <Rd>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 'm', 'm', 'm', 'm', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_REV_T2_fff0f0f0_fa90f080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("REV");
  rInsn.SetOpcode(ARM_Opcode_Rev);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// REV16<c>.W <Rd>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 'm', 'm', 'm', 'm', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_REV16_T2_fff0f0f0_fa90f090(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("REV16");
  rInsn.SetOpcode(ARM_Opcode_Rev16);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// RBIT<c> <Rd>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 'm', 'm', 'm', 'm', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_RBIT_T1_fff0f0f0_fa90f0a0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("RBIT");
  rInsn.SetOpcode(ARM_Opcode_Rbit);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// REVSH<c>.W <Rd>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 'm', 'm', 'm', 'm', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_REVSH_T2_fff0f0f0_fa90f0b0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("REVSH");
  rInsn.SetOpcode(ARM_Opcode_Revsh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SADD16_T1_fff0f0f0_fa90f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SADD16");
  rInsn.SetOpcode(ARM_Opcode_Sadd16);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// QADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_QADD16_T1_fff0f0f0_fa90f010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("QADD16");
  rInsn.SetOpcode(ARM_Opcode_Qadd16);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SHADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SHADD16_T1_fff0f0f0_fa90f020(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SHADD16");
  rInsn.SetOpcode(ARM_Opcode_Shadd16);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UADD16<c> <Rd>, <Rn>, <Rm> - [] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UADD16_T1_fff0f0f0_fa90f040(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UADD16");
  rInsn.SetOpcode(ARM_Opcode_Uadd16);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  return true;
}
// UQADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UQADD16_T1_fff0f0f0_fa90f050(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UQADD16");
  rInsn.SetOpcode(ARM_Opcode_Uqadd16);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UHADD16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UHADD16_T1_fff0f0f0_fa90f060(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UHADD16");
  rInsn.SetOpcode(ARM_Opcode_Uhadd16);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SASX_T1_fff0f0f0_faa0f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SASX");
  rInsn.SetOpcode(ARM_Opcode_Sasx);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// QASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_QASX_T1_fff0f0f0_faa0f010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("QASX");
  rInsn.SetOpcode(ARM_Opcode_Qasx);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SHASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SHASX_T1_fff0f0f0_faa0f020(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SHASX");
  rInsn.SetOpcode(ARM_Opcode_Shasx);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UASX_T1_fff0f0f0_faa0f040(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UASX");
  rInsn.SetOpcode(ARM_Opcode_Uasx);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UQASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UQASX_T1_fff0f0f0_faa0f050(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UQASX");
  rInsn.SetOpcode(ARM_Opcode_Uqasx);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UHASX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UHASX_T1_fff0f0f0_faa0f060(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UHASX");
  rInsn.SetOpcode(ARM_Opcode_Uhasx);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SEL<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SEL_T1_fff0f0f0_faa0f080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SEL");
  rInsn.SetOpcode(ARM_Opcode_Sel);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CLZ<c> <Rd>, <Rm> - [] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 'm', 'm', 'm', 'm', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_CLZ_T1_fff0f0f0_fab0f080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CLZ");
  rInsn.SetOpcode(ARM_Opcode_Clz);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SSUB8_T1_fff0f0f0_fac0f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SSUB8");
  rInsn.SetOpcode(ARM_Opcode_Ssub8);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// QSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_QSUB8_T1_fff0f0f0_fac0f010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("QSUB8");
  rInsn.SetOpcode(ARM_Opcode_Qsub8);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SHSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SHSUB8_T1_fff0f0f0_fac0f020(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SHSUB8");
  rInsn.SetOpcode(ARM_Opcode_Shsub8);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// USUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_USUB8_T1_fff0f0f0_fac0f040(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("USUB8");
  rInsn.SetOpcode(ARM_Opcode_Usub8);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UQSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UQSUB8_T1_fff0f0f0_fac0f050(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UQSUB8");
  rInsn.SetOpcode(ARM_Opcode_Uqsub8);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UHSUB8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UHSUB8_T1_fff0f0f0_fac0f060(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UHSUB8");
  rInsn.SetOpcode(ARM_Opcode_Uhsub8);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SSUB16_T1_fff0f0f0_fad0f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SSUB16");
  rInsn.SetOpcode(ARM_Opcode_Ssub16);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// QSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_QSUB16_T1_fff0f0f0_fad0f010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("QSUB16");
  rInsn.SetOpcode(ARM_Opcode_Qsub16);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SHSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SHSUB16_T1_fff0f0f0_fad0f020(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SHSUB16");
  rInsn.SetOpcode(ARM_Opcode_Shsub16);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// USUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_USUB16_T1_fff0f0f0_fad0f040(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("USUB16");
  rInsn.SetOpcode(ARM_Opcode_Usub16);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UQSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UQSUB16_T1_fff0f0f0_fad0f050(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UQSUB16");
  rInsn.SetOpcode(ARM_Opcode_Uqsub16);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UHSUB16<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UHSUB16_T1_fff0f0f0_fad0f060(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UHSUB16");
  rInsn.SetOpcode(ARM_Opcode_Uhsub16);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SSAX_T1_fff0f0f0_fae0f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SSAX");
  rInsn.SetOpcode(ARM_Opcode_Ssax);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// QSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_QSAX_T1_fff0f0f0_fae0f010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("QSAX");
  rInsn.SetOpcode(ARM_Opcode_Qsax);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SHSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SHSAX_T1_fff0f0f0_fae0f020(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SHSAX");
  rInsn.SetOpcode(ARM_Opcode_Shsax);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// USAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_USAX_T1_fff0f0f0_fae0f040(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("USAX");
  rInsn.SetOpcode(ARM_Opcode_Usax);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UQSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UQSAX_T1_fff0f0f0_fae0f050(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UQSAX");
  rInsn.SetOpcode(ARM_Opcode_Uqsax);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UHSAX<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UHSAX_T1_fff0f0f0_fae0f060(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UHSAX");
  rInsn.SetOpcode(ARM_Opcode_Uhsax);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MUL<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MUL_T2_fff0f0f0_fb00f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MUL");
  rInsn.SetOpcode(ARM_Opcode_Mul);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MLA<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 'n', 'n', 'n', 'n', 'a', 'a', 'a', 'a', 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MLA_T1_fff000f0_fb000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MLA");
  rInsn.SetOpcode(ARM_Opcode_Mla);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: Ra
  u32 RegA = ExtractBits<12, 15>(Opcode);
  auto pOprd3 = Expr::MakeId(RegA + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MLS<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 'n', 'n', 'n', 'n', 'a', 'a', 'a', 'a', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MLS_T1_fff000f0_fb000010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MLS");
  rInsn.SetOpcode(ARM_Opcode_Mls);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: Ra
  u32 RegA = ExtractBits<12, 15>(Opcode);
  auto pOprd3 = Expr::MakeId(RegA + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMUL<x><y><c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 'N', 'M', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SMUL_T1_fff0f0c0_fb10f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMUL");
  rInsn.SetOpcode(ARM_Opcode_Smul);
  rInsn.Length() += 4;

  // field: x
  /* unhandled field x */

  // field: y
  /* unhandled field y */

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMLA<x><y><c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 'n', 'n', 'n', 'n', 'a', 'a', 'a', 'a', 'd', 'd', 'd', 'd', 0, 0, 'N', 'M', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SMLA_T1_fff000c0_fb100000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMLA");
  rInsn.SetOpcode(ARM_Opcode_Smla);
  rInsn.Length() += 4;

  // field: x
  /* unhandled field x */

  // field: y
  /* unhandled field y */

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: Ra
  u32 RegA = ExtractBits<12, 15>(Opcode);
  auto pOprd3 = Expr::MakeId(RegA + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMUAD{X}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 'M', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SMUAD_T1_fff0f0e0_fb20f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMUAD");
  rInsn.SetOpcode(ARM_Opcode_Smuad);
  rInsn.Length() += 4;

  // field: X
  /* unhandled field X */

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMLAD{X}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 'n', 'n', 'n', 'n', 'a', 'a', 'a', 'a', 'd', 'd', 'd', 'd', 0, 0, 0, 'M', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SMLAD_T1_fff000e0_fb200000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMLAD");
  rInsn.SetOpcode(ARM_Opcode_Smlad);
  rInsn.Length() += 4;

  // field: X
  /* unhandled field X */

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: Ra
  u32 RegA = ExtractBits<12, 15>(Opcode);
  auto pOprd3 = Expr::MakeId(RegA + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMULW<y><c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 'M', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SMULW_T1_fff0f0e0_fb30f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMULW");
  rInsn.SetOpcode(ARM_Opcode_Smulw);
  rInsn.Length() += 4;

  // field: y
  /* unhandled field y */

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMLAW<y><c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 'n', 'n', 'n', 'n', 'a', 'a', 'a', 'a', 'd', 'd', 'd', 'd', 0, 0, 0, 'M', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SMLAW_T1_fff000e0_fb300000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMLAW");
  rInsn.SetOpcode(ARM_Opcode_Smlaw);
  rInsn.Length() += 4;

  // field: y
  /* unhandled field y */

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: Ra
  u32 RegA = ExtractBits<12, 15>(Opcode);
  auto pOprd3 = Expr::MakeId(RegA + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMUSD{X}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 'M', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SMUSD_T1_fff0f0e0_fb40f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMUSD");
  rInsn.SetOpcode(ARM_Opcode_Smusd);
  rInsn.Length() += 4;

  // field: X
  /* unhandled field X */

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMLSD{X}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 'n', 'n', 'n', 'n', 'a', 'a', 'a', 'a', 'd', 'd', 'd', 'd', 0, 0, 0, 'M', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SMLSD_T1_fff000e0_fb400000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMLSD");
  rInsn.SetOpcode(ARM_Opcode_Smlsd);
  rInsn.Length() += 4;

  // field: X
  /* unhandled field X */

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: Ra
  u32 RegA = ExtractBits<12, 15>(Opcode);
  auto pOprd3 = Expr::MakeId(RegA + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMMUL{R}<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 'R', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SMMUL_T1_fff0f0e0_fb50f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMMUL");
  rInsn.SetOpcode(ARM_Opcode_Smmul);
  rInsn.Length() += 4;

  // field: R
  /* unhandled field R */

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMMLA{R}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 'n', 'n', 'n', 'n', 'a', 'a', 'a', 'a', 'd', 'd', 'd', 'd', 0, 0, 0, 'R', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SMMLA_T1_fff000e0_fb500000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMMLA");
  rInsn.SetOpcode(ARM_Opcode_Smmla);
  rInsn.Length() += 4;

  // field: R
  /* unhandled field R */

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: Ra
  u32 RegA = ExtractBits<12, 15>(Opcode);
  auto pOprd3 = Expr::MakeId(RegA + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMMLS{R}<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 'n', 'n', 'n', 'n', 'a', 'a', 'a', 'a', 'd', 'd', 'd', 'd', 0, 0, 0, 'R', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SMMLS_T1_fff000e0_fb600000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMMLS");
  rInsn.SetOpcode(ARM_Opcode_Smmls);
  rInsn.Length() += 4;

  // field: R
  /* unhandled field R */

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: Ra
  u32 RegA = ExtractBits<12, 15>(Opcode);
  auto pOprd3 = Expr::MakeId(RegA + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// USAD8<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 'n', 'n', 'n', 'n', 1, 1, 1, 1, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_USAD8_T1_fff0f0f0_fb70f000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("USAD8");
  rInsn.SetOpcode(ARM_Opcode_Usad8);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// USADA8<c> <Rd>, <Rn>, <Rm>, <Ra> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 'n', 'n', 'n', 'n', 'a', 'a', 'a', 'a', 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_USADA8_T1_fff000f0_fb700000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("USADA8");
  rInsn.SetOpcode(ARM_Opcode_Usada8);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);

  // field: Ra
  u32 RegA = ExtractBits<12, 15>(Opcode);
  auto pOprd3 = Expr::MakeId(RegA + 1, &m_CpuInfo);
  if (pOprd3 == nullptr)
    return false;
  rInsn.AddOperand(pOprd3);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMULL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 'n', 'n', 'n', 'n', 'dlo', 'dlo', 'dlo', 'dlo', 'dhi', 'dhi', 'dhi', 'dhi', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SMULL_T1_fff000f0_fb800000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMULL");
  rInsn.SetOpcode(ARM_Opcode_Smull);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: RdLo
  /* unhandled field RdLo */

  // field: RdHi
  /* unhandled field RdHi */

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SDIV<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 'n', 'n', 'n', 'n', '(1)', '(1)', '(1)', '(1)', 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SDIV_T1_fff0f0f0_fb90f0f0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SDIV");
  rInsn.SetOpcode(ARM_Opcode_Sdiv);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UMULL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 'n', 'n', 'n', 'n', 'dlo', 'dlo', 'dlo', 'dlo', 'dhi', 'dhi', 'dhi', 'dhi', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UMULL_T1_fff000f0_fba00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UMULL");
  rInsn.SetOpcode(ARM_Opcode_Umull);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: RdLo
  /* unhandled field RdLo */

  // field: RdHi
  /* unhandled field RdHi */

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UDIV<c> <Rd>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 'n', 'n', 'n', 'n', '(1)', '(1)', '(1)', '(1)', 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UDIV_T1_fff0f0f0_fbb0f0f0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UDIV");
  rInsn.SetOpcode(ARM_Opcode_Udiv);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Rd
  u32 RegD = ExtractBits<8, 11>(Opcode);
  if (RegD + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegD + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd1 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd2 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd2 == nullptr)
    return false;
  rInsn.AddOperand(pOprd2);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMLAL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 'dlo', 'dlo', 'dlo', 'dlo', 'dhi', 'dhi', 'dhi', 'dhi', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SMLAL_T1_fff000f0_fbc00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMLAL");
  rInsn.SetOpcode(ARM_Opcode_Smlal);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: RdLo
  /* unhandled field RdLo */

  // field: RdHi
  /* unhandled field RdHi */

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMLAL<x><y><c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 'dlo', 'dlo', 'dlo', 'dlo', 'dhi', 'dhi', 'dhi', 'dhi', 1, 0, 'N', 'M', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SMLAL_T1_fff000c0_fbc00080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMLAL");
  rInsn.SetOpcode(ARM_Opcode_Smlal);
  rInsn.Length() += 4;

  // field: x
  /* unhandled field x */

  // field: y
  /* unhandled field y */

  // field: c
  // TODO: unable to find conditional bits

  // field: RdLo
  /* unhandled field RdLo */

  // field: RdHi
  /* unhandled field RdHi */

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMLALD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 'n', 'n', 'n', 'n', 'dlo', 'dlo', 'dlo', 'dlo', 'dhi', 'dhi', 'dhi', 'dhi', 1, 1, 0, 'M', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SMLALD_T1_fff000e0_fbc000c0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMLALD");
  rInsn.SetOpcode(ARM_Opcode_Smlald);
  rInsn.Length() += 4;

  // field: X
  /* unhandled field X */

  // field: c
  // TODO: unable to find conditional bits

  // field: RdLo
  /* unhandled field RdLo */

  // field: RdHi
  /* unhandled field RdHi */

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// SMLSLD{X}<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 'n', 'n', 'n', 'n', 'dlo', 'dlo', 'dlo', 'dlo', 'dhi', 'dhi', 'dhi', 'dhi', 1, 1, 0, 'M', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_SMLSLD_T1_fff000e0_fbd000c0(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("SMLSLD");
  rInsn.SetOpcode(ARM_Opcode_Smlsld);
  rInsn.Length() += 4;

  // field: X
  /* unhandled field X */

  // field: c
  // TODO: unable to find conditional bits

  // field: RdLo
  /* unhandled field RdLo */

  // field: RdHi
  /* unhandled field RdHi */

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UMLAL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 'n', 'n', 'n', 'n', 'dlo', 'dlo', 'dlo', 'dlo', 'dhi', 'dhi', 'dhi', 'dhi', 0, 0, 0, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UMLAL_T1_fff000f0_fbe00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UMLAL");
  rInsn.SetOpcode(ARM_Opcode_Umlal);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: RdLo
  /* unhandled field RdLo */

  // field: RdHi
  /* unhandled field RdHi */

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// UMAAL<c> <RdLo>, <RdHi>, <Rn>, <Rm> - ['could_jmp'] - [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 'n', 'n', 'n', 'n', 'dlo', 'dlo', 'dlo', 'dlo', 'dhi', 'dhi', 'dhi', 'dhi', 0, 1, 1, 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_UMAAL_T1_fff000f0_fbe00060(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("UMAAL");
  rInsn.SetOpcode(ARM_Opcode_Umaal);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: RdLo
  /* unhandled field RdLo */

  // field: RdHi
  /* unhandled field RdHi */

  // field: Rn
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeId(RegN + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rm
  u32 RegM = ExtractBits<0, 3>(Opcode);
  auto pOprd1 = Expr::MakeId(RegM + 1, &m_CpuInfo);
  if (pOprd1 == nullptr)
    return false;
  rInsn.AddOperand(pOprd1);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MCRR2<c> <coproc>, <opc1>, <Rt>, <Rt2>, <CRm> - ['support_it_block', 'could_jmp'] - [1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 't2', 't2', 't2', 't2', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc1', 'opc1', 'opc1', 'opc1', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MCRR2_T2_fff00000_fc400000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MCRR2");
  rInsn.SetOpcode(ARM_Opcode_Mcrr2);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: opc1
  /* unhandled field opc1 */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: CRm
  /* unhandled field CRm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MRRC2<c> <coproc>, <opc>, <Rt>, <Rt2>, <CRm> - ['support_it_block', 'could_jmp'] - [1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 't2', 't2', 't2', 't2', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc1', 'opc1', 'opc1', 'opc1', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MRRC2_T2_fff00000_fc500000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MRRC2");
  rInsn.SetOpcode(ARM_Opcode_Mrrc2);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: opc
  /* unhandled field opc */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: Rt2
  /* unhandled field Rt2 */

  // field: CRm
  /* unhandled field CRm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// STC2{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!} - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 0, 'P', 'U', 'D', 'W', 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_STC2_T2_fe100000_fc000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("STC2");
  rInsn.SetOpcode(ARM_Opcode_Stc2);
  rInsn.Length() += 4;

  // field: L
  /* unhandled field L */

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: CRd
  /* unhandled field CRd */

  // field: [<Rn>, #+/-<imm>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeMem(32, nullptr, Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(RegN + 1, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)))), true);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: W
  if (ExtractBit<21>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDC2{L}<c> <coproc>, <CRd>, <label> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 0, 'P', 'U', 'D', 'W', 1, 1, 1, 1, 1, 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDC2_T2_fe1f0000_fc1f0000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDC2");
  rInsn.SetOpcode(ARM_Opcode_Ldc2);
  rInsn.Length() += 4;

  // field: L
  /* unhandled field L */

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: CRd
  /* unhandled field CRd */

  // field: label
  auto pOprd0 = Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(ARM_RegPC, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode))));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// LDC2{L}<c> <coproc>, <CRd>, [<Rn>, #+/-<imm>]{!} - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 0, 'P', 'U', 'D', 'W', 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_LDC2_T2_fe100000_fc100000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("LDC2");
  rInsn.SetOpcode(ARM_Opcode_Ldc2);
  rInsn.Length() += 4;

  // field: L
  /* unhandled field L */

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: CRd
  /* unhandled field CRd */

  // field: [<Rn>, #+/-<imm>]
  u32 RegN = ExtractBits<16, 19>(Opcode);
  auto pOprd0 = Expr::MakeMem(32, nullptr, Expr::MakeOp(OperationExpression::OpAdd,
    Expr::MakeId(RegN + 1, &m_CpuInfo),
    Expr::MakeConst(32, SignExtend<s64, 8>(ExtractBits<0, 7>(Opcode)))), true);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: W
  if (ExtractBit<21>(Opcode))
    rInsn.Prefix() |= ARM_Prefix_W;
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MCR2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['support_it_block', 'could_jmp'] - [1, 1, 1, 1, 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 0, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MCR2_T2_ff100010_fe000010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MCR2");
  rInsn.SetOpcode(ARM_Opcode_Mcr2);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: opc1
  /* unhandled field opc1 */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: CRn
  /* unhandled field CRn */

  // field: <CRm>{,<opc2>}
  /* unhandled field <CRm>{,<opc2>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// MRC2<c> <coproc>, <opc1>, <Rt>, <CRn>, <CRm>{,<opc2>} - ['support_it_block', 'could_jmp'] - [1, 1, 1, 1, 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 1, 'n', 'n', 'n', 'n', 't', 't', 't', 't', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_MRC2_T2_ff100010_fe100010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("MRC2");
  rInsn.SetOpcode(ARM_Opcode_Mrc2);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: opc1
  /* unhandled field opc1 */

  // field: Rt
  u32 RegT = ExtractBits<12, 15>(Opcode);
  if (RegT + 1 == ARM_RegPC)
    rInsn.SubType() |= Instruction::JumpType;
  auto pOprd0 = Expr::MakeId(RegT + 1, &m_CpuInfo);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);

  // field: CRn
  /* unhandled field CRn */

  // field: <CRm>{,<opc2>}
  /* unhandled field <CRm>{,<opc2>} */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// CDP2<c> <coproc>, <opc1>, <CRd>, <CRn>, <CRm>, <opc2> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 0, 'opc1', 'opc1', 'opc1', 'opc1', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 'coproc', 'coproc', 'coproc', 'coproc', 'opc2', 'opc2', 'opc2', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_CDP2_T2_ff000010_fe000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("CDP2");
  rInsn.SetOpcode(ARM_Opcode_Cdp2);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: coproc
  /* unhandled field coproc */

  // field: opc1
  /* unhandled field opc1 */

  // field: CRd
  /* unhandled field CRd */

  // field: CRn
  /* unhandled field CRn */

  // field: CRm
  /* unhandled field CRm */

  // field: opc2
  /* unhandled field opc2 */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VEOR<c> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 0, 0, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VEOR_T1_ffb00f10_ff000110(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VEOR");
  rInsn.SetOpcode(ARM_Opcode_Veor);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VPADD<c>.F32 - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VPADD_T1_ffa00f10_ff000d00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VPADD");
  rInsn.SetOpcode(ARM_Opcode_Vpadd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMUL<c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMUL_T1_ffa00f10_ff000d10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMUL");
  rInsn.SetOpcode(ARM_Opcode_Vmul);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCGE<c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 0, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCGE_T2_ffa00f10_ff000e00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCGE");
  rInsn.SetOpcode(ARM_Opcode_Vcge);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VABD<c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 1, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VABD_T1_ffa00f10_ff200d00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VABD");
  rInsn.SetOpcode(ARM_Opcode_Vabd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCGT<c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 1, 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCGT_T2_ffa00f10_ff200e00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCGT");
  rInsn.SetOpcode(ARM_Opcode_Vcgt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSUB<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSUB_T1_ff800f10_ff000800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSUB");
  rInsn.SetOpcode(ARM_Opcode_Vsub);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCEQ<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCEQ_T1_ff800f10_ff000810(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCEQ");
  rInsn.SetOpcode(ARM_Opcode_Vceq);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQRDMULH<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQRDMULH_T1_ff800f10_ff000b00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQRDMULH");
  rInsn.SetOpcode(ARM_Opcode_Vqrdmulh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op><c> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 'op', 'op', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_T1_ff800f10_ff000110(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op><c>.F32 <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 'op', 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_T1_ff800f10_ff000e10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VP<op><c>.F32 <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 0, 'D', 'op', 'sz', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VP_T1_ff800f10_ff000f00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VP");
  rInsn.SetOpcode(ARM_Opcode_Vp);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VREV<n><c>.<size> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 'op', 'op', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VREV_T1_ffb30e10_ffb00000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VREV");
  rInsn.SetOpcode(ARM_Opcode_Vrev);
  rInsn.Length() += 4;

  // field: n
  /* unhandled field n */

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VPADDL<c>.<dt> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'op', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VPADDL_T1_ffb30f10_ffb00200(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VPADDL");
  rInsn.SetOpcode(ARM_Opcode_Vpaddl);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCLS<c>.<dt> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 0, 0, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCLS_T1_ffb30f90_ffb00400(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCLS");
  rInsn.SetOpcode(ARM_Opcode_Vcls);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCLZ<c>.<dt> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 0, 0, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCLZ_T1_ffb30f90_ffb00480(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCLZ");
  rInsn.SetOpcode(ARM_Opcode_Vclz);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCNT<c>.8 <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 0, 1, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCNT_T1_ffb30f90_ffb00500(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCNT");
  rInsn.SetOpcode(ARM_Opcode_Vcnt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMVN<c> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 0, 1, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMVN_T1_ffb30f90_ffb00580(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMVN");
  rInsn.SetOpcode(ARM_Opcode_Vmvn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VPADAL<c>.<dt> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'op', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VPADAL_T1_ffb30f10_ffb00600(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VPADAL");
  rInsn.SetOpcode(ARM_Opcode_Vpadal);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQABS<c>.<dt> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 1, 1, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQABS_T1_ffb30f90_ffb00700(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQABS");
  rInsn.SetOpcode(ARM_Opcode_Vqabs);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQNEG<c>.<dt> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 0, 'd', 'd', 'd', 'd', 0, 1, 1, 1, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQNEG_T1_ffb30f90_ffb00780(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQNEG");
  rInsn.SetOpcode(ARM_Opcode_Vqneg);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCGT<c>.<dt> <Qd>, <Qm>, #0 - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 0, 0, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCGT_T1_ffb30b90_ffb10000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCGT");
  rInsn.SetOpcode(ARM_Opcode_Vcgt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */

  // field: #0
  auto pOprd0 = Expr::MakeConst(32, 0);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCGE<c>.<dt> <Qd>, <Qm>, #0 - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 0, 0, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCGE_T1_ffb30b90_ffb10080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCGE");
  rInsn.SetOpcode(ARM_Opcode_Vcge);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */

  // field: #0
  auto pOprd0 = Expr::MakeConst(32, 0);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCEQ<c>.<dt> <Qd>, <Qm>, #0 - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 0, 1, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCEQ_T1_ffb30b90_ffb10100(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCEQ");
  rInsn.SetOpcode(ARM_Opcode_Vceq);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */

  // field: #0
  auto pOprd0 = Expr::MakeConst(32, 0);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCLE<c>.<dt> <Qd>, <Qm>, #0 - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 0, 1, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCLE_T1_ffb30b90_ffb10180(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCLE");
  rInsn.SetOpcode(ARM_Opcode_Vcle);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */

  // field: #0
  auto pOprd0 = Expr::MakeConst(32, 0);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCLT<c>.<dt> <Qd>, <Qm>, #0 - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 1, 0, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCLT_T1_ffb30b90_ffb10200(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCLT");
  rInsn.SetOpcode(ARM_Opcode_Vclt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */

  // field: #0
  auto pOprd0 = Expr::MakeConst(32, 0);
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VABS<c>.<dt> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 1, 1, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VABS_T1_ffb30b90_ffb10300(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VABS");
  rInsn.SetOpcode(ARM_Opcode_Vabs);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VNEG<c>.<dt> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 0, 1, 'd', 'd', 'd', 'd', 0, 'F', 1, 1, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VNEG_T1_ffb30b90_ffb10380(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VNEG");
  rInsn.SetOpcode(ARM_Opcode_Vneg);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSWP<c> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSWP_T1_ffb30f90_ffb20000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSWP");
  rInsn.SetOpcode(ARM_Opcode_Vswp);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VTRN<c>.<size> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 0, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VTRN_T1_ffb30f90_ffb20080(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VTRN");
  rInsn.SetOpcode(ARM_Opcode_Vtrn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VUZP<c>.<size> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 1, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VUZP_T1_ffb30f90_ffb20100(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VUZP");
  rInsn.SetOpcode(ARM_Opcode_Vuzp);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VZIP<c>.<size> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 0, 1, 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VZIP_T1_ffb30f90_ffb20180(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VZIP");
  rInsn.SetOpcode(ARM_Opcode_Vzip);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMOVN<c>.<dt> <Dd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 0, 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMOVN_T1_ffb30fd0_ffb20200(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMOVN");
  rInsn.SetOpcode(ARM_Opcode_Vmovn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQMOV{op}N<c>.<type><size> <Dd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'op', 'op', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQMOV_T1_ffb30f10_ffb20200(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQMOV");
  rInsn.SetOpcode(ARM_Opcode_Vqmov);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: type
  /* unhandled field type */

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSHLL<c>.<type_4><size> <Qd>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 0, 1, 1, 0, 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSHLL_T2_ffb30fd0_ffb20300(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSHLL");
  rInsn.SetOpcode(ARM_Opcode_Vshll);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Dm
  /* unhandled field Dm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 20>(ExtractBits<18, 19>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCVT<c>.F32.F16 <Qd>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 0, 'd', 'd', 'd', 'd', 0, 1, 1, 'op', 0, 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCVT_T1_ffb30ed0_ffb20600(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCVT");
  rInsn.SetOpcode(ARM_Opcode_Vcvt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRECPE<c>.<dt> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 'F', 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRECPE_T1_ffb30e90_ffb30400(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRECPE");
  rInsn.SetOpcode(ARM_Opcode_Vrecpe);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRSQRTE<c>.<dt> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 1, 'd', 'd', 'd', 'd', 0, 1, 0, 'F', 1, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRSQRTE_T1_ffb30e90_ffb30480(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRSQRTE");
  rInsn.SetOpcode(ARM_Opcode_Vrsqrte);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCVT<c>.<Td>.<Tm> <Qd>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 1, 1, 'd', 'd', 'd', 'd', 0, 1, 1, 'op', 'op', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCVT_T1_ffb30e10_ffb30600(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCVT");
  rInsn.SetOpcode(ARM_Opcode_Vcvt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Td
  /* unhandled field Td */

  // field: Tm
  /* unhandled field Tm */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VDUP<c>.<size> <Qd>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 1, 0, 0, 0, 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VDUP_T1_ffb00f90_ffb00c00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VDUP");
  rInsn.SetOpcode(ARM_Opcode_Vdup);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Dm[x]
  /* unhandled field Dm[x] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op><c>.8 <Dd>, <list>, <Dm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 'len', 'len', 'N', 'op', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_T1_ffb00c10_ffb00800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: Dd
  /* unhandled field Dd */

  // field: list
  /* unhandled field list */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSRI<c>.<size> <Qd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSRI_T1_ff800f10_ff800410(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSRI");
  rInsn.SetOpcode(ARM_Opcode_Vsri);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSLI<c>.<size> <Qd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSLI_T1_ff800f10_ff800510(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSLI");
  rInsn.SetOpcode(ARM_Opcode_Vsli);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRADDHN<c>.<dt> <Dd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRADDHN_T1_ff800f50_ff800400(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRADDHN");
  rInsn.SetOpcode(ARM_Opcode_Vraddhn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRSUBHN<c>.<dt> <Dd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRSUBHN_T1_ff800f50_ff800600(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRSUBHN");
  rInsn.SetOpcode(ARM_Opcode_Vrsubhn);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op><c>.<dt> <Qd>, <Qn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 'Q', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 'op', 0, 'F', 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_T1_ef800a50_ef800040(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Dm[x]
  /* unhandled field Dm[x] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMUL<c>.<dt> <Qd>, <Qn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 'Q', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 'F', 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMUL_T1_ef800e50_ef800840(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMUL");
  rInsn.SetOpcode(ARM_Opcode_Vmul);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Dm[x]
  /* unhandled field Dm[x] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQDMULH<c>.<dt> <Qd>, <Qn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 'Q', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 0, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQDMULH_T2_ef800f50_ef800c40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQDMULH");
  rInsn.SetOpcode(ARM_Opcode_Vqdmulh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Dm[x]
  /* unhandled field Dm[x] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQRDMULH<c>.<dt> <Qd>, <Qn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 'Q', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 0, 1, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQRDMULH_T2_ef800f50_ef800d40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQRDMULH");
  rInsn.SetOpcode(ARM_Opcode_Vqrdmulh);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Dm[x]
  /* unhandled field Dm[x] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQADD<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQADD_T1_ef800f10_ef000010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQADD");
  rInsn.SetOpcode(ARM_Opcode_Vqadd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRHADD<c> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRHADD_T1_ef800f10_ef000100(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRHADD");
  rInsn.SetOpcode(ARM_Opcode_Vrhadd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQSUB<c>.<type_4><size> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQSUB_T1_ef800f10_ef000210(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQSUB");
  rInsn.SetOpcode(ARM_Opcode_Vqsub);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCGT<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCGT_T1_ef800f10_ef000300(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCGT");
  rInsn.SetOpcode(ARM_Opcode_Vcgt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCGE<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 1, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCGE_T1_ef800f10_ef000310(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCGE");
  rInsn.SetOpcode(ARM_Opcode_Vcge);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VH<op><c> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 'op', 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VH_T1_ef800d10_ef000000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VH");
  rInsn.SetOpcode(ARM_Opcode_Vh);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSHL<c>.I<size> <Qd>, <Qm>, <Qn> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSHL_T1_ef800f10_ef000400(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSHL");
  rInsn.SetOpcode(ARM_Opcode_Vshl);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */

  // field: Qn
  /* unhandled field Qn */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQSHL<c>.<type_4><size> <Qd>, <Qm>, <Qn> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 0, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQSHL_T1_ef800f10_ef000410(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQSHL");
  rInsn.SetOpcode(ARM_Opcode_Vqshl);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */

  // field: Qn
  /* unhandled field Qn */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRSHL<c>.<type_4><size> <Qd>, <Qm>, <Qn> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRSHL_T1_ef800f10_ef000500(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRSHL");
  rInsn.SetOpcode(ARM_Opcode_Vrshl);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */

  // field: Qn
  /* unhandled field Qn */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQRSHL<c>.<type><size> <Qd>, <Qm>, <Qn> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQRSHL_T1_ef800f10_ef000510(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQRSHL");
  rInsn.SetOpcode(ARM_Opcode_Vqrshl);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: type
  /* unhandled field type */

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */

  // field: Qn
  /* unhandled field Qn */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op><c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 0, 'N', 'Q', 'M', 'op', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_T1_ef800f00_ef000600(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VABD<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VABD_T1_ef800f10_ef000700(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VABD");
  rInsn.SetOpcode(ARM_Opcode_Vabd);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VABA<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VABA_T1_ef800f10_ef000710(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VABA");
  rInsn.SetOpcode(ARM_Opcode_Vaba);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VP<op><c>.<dt> <Dd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'N', 'Q', 'M', 'op', 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VP_T1_ef800f00_ef000a00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VP");
  rInsn.SetOpcode(ARM_Opcode_Vp);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Dd
  /* unhandled field Dd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMOVL<c>.<dt> <Qd>, <Dm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 0, 0, 0, 'd', 'd', 'd', 'd', 1, 0, 1, 0, 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMOVL_T1_ef870fd0_ef800a10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMOVL");
  rInsn.SetOpcode(ARM_Opcode_Vmovl);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSHR<c>.<type_4><size> <Qd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 0, 0, 0, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSHR_T1_ef800f10_ef800010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSHR");
  rInsn.SetOpcode(ARM_Opcode_Vshr);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSRA<c>.<type_4><size> <Qd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 0, 0, 1, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSRA_T1_ef800f10_ef800110(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSRA");
  rInsn.SetOpcode(ARM_Opcode_Vsra);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRSHR<c>.<type_4><size> <Qd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 0, 1, 0, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRSHR_T1_ef800f10_ef800210(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRSHR");
  rInsn.SetOpcode(ARM_Opcode_Vrshr);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VRSRA<c>.<type_4><size> <Qd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 0, 1, 1, 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VRSRA_T1_ef800f10_ef800310(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VRSRA");
  rInsn.SetOpcode(ARM_Opcode_Vrsra);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQSHL{op}<c>.<type_4><size> <Qd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 0, 1, 1, 'op', 'L', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQSHL_T1_ef800e10_ef800610(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQSHL");
  rInsn.SetOpcode(ARM_Opcode_Vqshl);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQSHR{op}N<c>.<type_4><size> <Dd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 0, 'op', 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQSHR_T1_ef800ed0_ef800810(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQSHR");
  rInsn.SetOpcode(ARM_Opcode_Vqshr);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Qm
  /* unhandled field Qm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VQRSHR{op}N<c>.<type_4><size> <Dd>, <Qm>, #<imm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 0, 'op', 0, 1, 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VQRSHR_T1_ef800ed0_ef800850(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VQRSHR");
  rInsn.SetOpcode(ARM_Opcode_Vqrshr);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Dd
  /* unhandled field Dd */

  // field: Qm
  /* unhandled field Qm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSHLL<c>.<type_4><size> <Qd>, <Dm>, #<imm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 0, 0, 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSHLL_T1_ef800fd0_ef800a10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSHLL");
  rInsn.SetOpcode(ARM_Opcode_Vshll);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: type_4
  /* unhandled field type_4 */

  // field: size
  /* unhandled field size */

  // field: Qd
  /* unhandled field Qd */

  // field: Dm
  /* unhandled field Dm */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 22>(ExtractBits<16, 21>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VCVT<c>.<Td>.<Tm> <Qd>, <Qm>, #<fbits> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'i', 'i', 'i', 'i', 'd', 'd', 'd', 'd', 1, 1, 1, 'op', 0, 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VCVT_T1_ef800e90_ef800e10(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VCVT");
  rInsn.SetOpcode(ARM_Opcode_Vcvt);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: Td
  /* unhandled field Td */

  // field: Tm
  /* unhandled field Tm */

  // field: Qd
  /* unhandled field Qd */

  // field: Qm
  /* unhandled field Qm */

  // field: fbits
  /* unhandled field fbits */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VADDL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 0, 'op', 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VADDL_T1_ef800e50_ef800000(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VADDL");
  rInsn.SetOpcode(ARM_Opcode_Vaddl);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VSUBL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 0, 1, 'op', 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VSUBL_T1_ef800e50_ef800200(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VSUBL");
  rInsn.SetOpcode(ARM_Opcode_Vsubl);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VABAL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 0, 1, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VABAL_T2_ef800f50_ef800500(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VABAL");
  rInsn.SetOpcode(ARM_Opcode_Vabal);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VABDL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 1, 1, 1, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VABDL_T2_ef800f50_ef800700(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VABDL");
  rInsn.SetOpcode(ARM_Opcode_Vabdl);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op>L<c>.<dt> <Qd>, <Dn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 0, 'op', 1, 0, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_T2_ef800b50_ef800240(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm[x]
  /* unhandled field Dm[x] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMULL<c>.<dt> <Qd>, <Dn>, <Dm[x]> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 1, 0, 'N', 1, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMULL_T2_ef800f50_ef800a40(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMULL");
  rInsn.SetOpcode(ARM_Opcode_Vmull);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm[x]
  /* unhandled field Dm[x] */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op>L<c>.<dt> <Qd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 'op', 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_T2_ef800d50_ef800800(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMULL<c>.<dt> <Qd>, <Dn>, <Dm> - ['support_it_block'] - [1, 1, 1, 'U', 1, 1, 1, 1, 1, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 1, 'op', 0, 'N', 0, 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMULL_T2_ef800d50_ef800c00(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMULL");
  rInsn.SetOpcode(ARM_Opcode_Vmull);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Dn
  /* unhandled field Dn */

  // field: Dm
  /* unhandled field Dm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VORR<c>.<dt> <Qd>, #<imm> - ['support_it_block'] - [1, 1, 1, 'i', 1, 1, 1, 1, 1, 'D', 0, 0, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'cmode', 'cmode', 'cmode', 'cmode', 0, 'Q', 0, 1, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VORR_T1_efb800b0_ef800010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VORR");
  rInsn.SetOpcode(ARM_Opcode_Vorr);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 4>(ExtractBits<0, 3>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VBIC<c>.<dt> <Qd>, #<imm> - ['support_it_block'] - [1, 1, 1, 'i', 1, 1, 1, 1, 1, 'D', 0, 0, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'cmode', 'cmode', 'cmode', 'cmode', 0, 'Q', 1, 1, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VBIC_T1_efb800b0_ef800030(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VBIC");
  rInsn.SetOpcode(ARM_Opcode_Vbic);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 4>(ExtractBits<0, 3>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMOV<c>.<dt> <Qd>, #<imm> - ['support_it_block'] - [1, 1, 1, 'i', 1, 1, 1, 1, 1, 'D', 0, 0, 0, 'i', 'i', 'i', 'd', 'd', 'd', 'd', 'cmode', 'cmode', 'cmode', 'cmode', 0, 'Q', 'op', 1, 'i', 'i', 'i', 'i']
bool ArmArchitecture::Instruction_VMOV_T1_efb80090_ef800010(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMOV");
  rInsn.SetOpcode(ARM_Opcode_Vmov);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: imm
  auto pOprd0 = Expr::MakeConst(32, SignExtend<s64, 4>(ExtractBits<0, 3>(Opcode)));
  if (pOprd0 == nullptr)
    return false;
  rInsn.AddOperand(pOprd0);
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// V<op><c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'op', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 1, 'N', 'Q', 'M', 0, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_V_T1_ef800f10_ef000900(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("V");
  rInsn.SetOpcode(ARM_Opcode_V);
  rInsn.Length() += 4;

  // field: op
  /* unhandled field op */

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
// VMUL<c>.<dt> <Qd>, <Qn>, <Qm> - ['support_it_block'] - [1, 1, 1, 'op', 1, 1, 1, 1, 0, 'D', 'i', 'i', 'n', 'n', 'n', 'n', 'd', 'd', 'd', 'd', 1, 0, 0, 1, 'N', 'Q', 'M', 1, 'm', 'm', 'm', 'm']
bool ArmArchitecture::Instruction_VMUL_T1_ef800f10_ef000910(BinaryStream const& rBinStrm, TOffset Offset, u32 Opcode, Instruction& rInsn)
{
  rInsn.SetName("VMUL");
  rInsn.SetOpcode(ARM_Opcode_Vmul);
  rInsn.Length() += 4;

  // field: c
  // TODO: unable to find conditional bits

  // field: dt
  /* unhandled field dt */

  // field: Qd
  /* unhandled field Qd */

  // field: Qn
  /* unhandled field Qn */

  // field: Qm
  /* unhandled field Qm */
  {
    Expression::List AllExpr;
    Expression::SPType spResExpr;
    rInsn.SetSemantic(AllExpr);
  }
  return true;
}
